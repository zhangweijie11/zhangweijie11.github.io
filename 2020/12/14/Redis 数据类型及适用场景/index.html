

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="zhangweijie">
  <meta name="keywords" content="">
  
    <meta name="description" content="Redis 数据类型及适用场景Redis 核心对象在 Redis 中有一个 核心对象叫做 Redisobject，是用来表示所有的 key 和 value ，redis 常见的数据类型有五种，包括string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合） 还有一些使用频率不高的数据结构，包括 hyperloglog、bitmap（位图）、geohash（地图）">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 数据类型及适用场景">
<meta property="og:url" content="http://example.com/2020/12/14/Redis%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/index.html">
<meta property="og:site_name" content="ffreedom">
<meta property="og:description" content="Redis 数据类型及适用场景Redis 核心对象在 Redis 中有一个 核心对象叫做 Redisobject，是用来表示所有的 key 和 value ，redis 常见的数据类型有五种，包括string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合） 还有一些使用频率不高的数据结构，包括 hyperloglog、bitmap（位图）、geohash（地图）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126493.png">
<meta property="og:image" content="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126925.png">
<meta property="og:image" content="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126170.png">
<meta property="og:image" content="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126719.png">
<meta property="og:image" content="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126607.png">
<meta property="og:image" content="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126501.png">
<meta property="og:image" content="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126566.png">
<meta property="og:image" content="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126901.png">
<meta property="og:image" content="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081127500.png">
<meta property="og:image" content="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081127409.png">
<meta property="og:image" content="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081127957.png">
<meta property="og:image" content="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081127559.png">
<meta property="article:published_time" content="2020-12-14T02:36:31.000Z">
<meta property="article:modified_time" content="2023-03-27T08:16:37.829Z">
<meta property="article:author" content="zhangweijie">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126493.png">
  
  
  <title>Redis 数据类型及适用场景 - ffreedom</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"J0a9dxcs8XGWWoDR84hMXA01-gzGzoHsz","app_key":"WbImCRYLaCb0AN9W178IBFBs","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ffreedom</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Redis 数据类型及适用场景">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-14 10:36" pubdate>
        2020年12月14日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.6k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      80 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Redis 数据类型及适用场景</h1>
            
            <div class="markdown-body">
              <h2 id="Redis-数据类型及适用场景"><a href="#Redis-数据类型及适用场景" class="headerlink" title="Redis 数据类型及适用场景"></a>Redis 数据类型及适用场景</h2><h3 id="Redis-核心对象"><a href="#Redis-核心对象" class="headerlink" title="Redis 核心对象"></a>Redis 核心对象</h3><p>在 Redis 中有一个 <strong>核心对象</strong>叫做 Redisobject，是用来表示所有的 key 和 value ，redis 常见的数据类型有五种，包括string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）</p>
<p>还有一些使用频率不高的数据结构，包括 hyperloglog、bitmap（位图）、geohash（地图）</p>
<img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126493.png" srcset="/img/loading.gif" lazyload alt="image-20201112093801027" style="zoom:50%;" />

<p>​                                                                                                            redis 基本数据结构</p>
<img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126925.png" srcset="/img/loading.gif" lazyload alt="image-20201112175201239" style="zoom:50%;" />





<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>string 的 三种内部编码分别是：int，embstr，raw。</p>
<p><strong>int</strong> 类型，当一个 key 的 value 是整数型时，redis 就将其编码为 int 类型（条件就是把这个 value当做字符串看待，他的长度不能超过 20）。这种编码类型是为了节省内存，redis 默认会缓存 10000个整型值，这就意味着，如果有 10 个不同的 key，但是其 value 都是 10000 以内的值，事实上全部都是共享同一个对象</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; set test <span class="hljs-number">1234</span><br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; object encoding test<br><span class="hljs-string">&quot;int&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong>embstr</strong> 条件是编码的长度不能超过 44，embstr 编码创建字符串对象所需的空间分配次数为一次，并且 embstr 编码的字符串对象的所以数据都保存在一块连续的内存中，所以可以更好地利用缓存带来的优势，并且释放 embstr 编码的字符串对象只需要调用一次内存释放函数</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; set test a1234567890123456789012345678901234567890123<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; object encoding test<br><span class="hljs-string">&quot;embstr&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong>raw</strong> 条件是编码长度超过 44，raw 编码创建字符串对象所需的空间分配次数为两次， <strong>raw</strong> 编码的字符串对象的数据可能保存在一块不连续的内存中，并且释放 <strong>raw</strong> 编码的字符串对象需要调用两次内存释放函数</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; set test a1234567890123456789012345678901234567890123456<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; object encoding test<br><span class="hljs-string">&quot;raw&quot;</span><br></code></pre></td></tr></table></figure>

<p>redis 是使用 C 语言开发的，但是 redis 字符串中，并没有使用 C 语言中的字符串，而是使用一种被称为 SDS（simple dynamic string）的结构体来保存字符串</p>
<img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126170.png" srcset="/img/loading.gif" lazyload alt="image-20201112094301192" style="zoom:50%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sdshdr</span> &#123;<br>	<span class="hljs-type">int</span> len;<br>	<span class="hljs-type">int</span> free;<br>	<span class="hljs-type">char</span> buf[]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>SDS 结构如上图：</p>
<ul>
<li><strong>len</strong>：用于记录 buf 中已使用的空间的长度</li>
<li><strong>free</strong>：buf 中空闲空间的长度</li>
<li>**buf[]**：实际存储的内容</li>
</ul>
<p>exp：执行命令 set key value，key 和 value 都是一个 SDS 类型的结构存储在内存中</p>
<h3 id="SDS-与-C-字符串的区别"><a href="#SDS-与-C-字符串的区别" class="headerlink" title="SDS 与 C 字符串的区别"></a>SDS 与 C 字符串的区别</h3><ol>
<li><p>常数时间内获得字符串的长度</p>
<p>C 字符串本身不记录长度信息，每次获取长度信息都是需要遍历整个字符串，复杂度为**O(n)**；C 字符串遍历时遇到 <strong>’\0’</strong> 即结束遍历</p>
<p>SDS 中 <strong>len</strong>字段保存着字符串的长度，所以每次都能在常数时间内获取字符串的长度，复杂度为 <strong>O(1)</strong></p>
</li>
<li><p>避免缓冲区溢出</p>
<p>假设在内存中有两个紧挨着的字符串，分别为 s1&#x3D;“123” 和 s2&#x3D;“678”</p>
<p>由于在内存上紧紧相连，当我们对s1 进行扩充的时候，将 s1&#x3D;“123”变为s1&#x3D;“1234”的时候，由于没有进行相应的内存重新分配，导致s2 会被 s1 莫名其妙的修改，会造成缓冲区溢出的问题</p>
<p>但是 SDS 的 API 对 zfc 修改时首先会检查空间是否足够，如果不充足会分配新的空间，避免缓冲区溢出的问题</p>
</li>
<li><p>减少字符串修改时带来的内存重新分配的次数</p>
<p>在 C 语言中，当我们频繁的对一个字符串进行修改操作的时候，需要频繁的进行内存重新分配，十分影响性能。如果不小心忘记，就可能导致内存溢出或者内存泄漏，对于 redis 来说，本来就会很频繁的进行数据的修改，所以使用 C 字符串并不合适。而 SDS 实现了空间的预分配和惰性空间释放两种优化策略：</p>
<ul>
<li><p><strong>空间预分配</strong> 当 SDS 的 API 对一个 SDS 修改以后，并且对 SDS的空间进行扩充，程序不仅会为 SDS 分配所需要的必须的空间，还会额外分配未使用的空闲空间</p>
<p>分配规则如下：如果对 SDS 修改后，<strong>len</strong>的长度小于 1M，那么程序将分配和 <strong>len</strong>相同长度的未使用空间。举个例子，如果 <strong>len&#x3D;10</strong>，重新分配后，buf 的实际长度就是 <strong>10（已使用空间）+ 10（空闲空间）+ 1（空字符）&#x3D;21（实际分配空间）</strong>，如果对 SDS 修改后 <strong>len</strong>长度大于 1M，那么程序将分配 1M 的未使用空间</p>
</li>
<li><p>惰性空间释放 当对 SDS 进行缩短操作的时候，程序并不会回收多余的不再被使用的内存空间，而是使用 <strong>free 字段</strong>将这些字节数量记录下来，后边如果需要进行 append 操作，则直接使用 <strong>free 字段</strong>中未使用的空间，减少内存再分配的次数</p>
</li>
</ul>
</li>
<li><p>二进制安全</p>
<p>在 redis 中不仅可以存储 string 类型的数据，也可以存储一些二进制数据。二进制数据并不是规则的字符串格式，其中就可能会包含以下特殊的字符，比如 <strong>“\0”</strong>。在 C 中遇到 <strong>“\0”</strong> 表示的是字符串的结束，但是在 SDS中，标志字符串结束的 <strong>len 属性</strong></p>
</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>存储图片</li>
<li>常规计数，比如统计微博粉丝数等</li>
<li>共享 session</li>
<li>限速（例如单位时间内不能获取 N次验证码）</li>
</ol>
<h2 id="Hash（字典）"><a href="#Hash（字典）" class="headerlink" title="Hash（字典）"></a>Hash（字典）</h2><p>Hash对象的实现方式有两种分别是ziplist、hashtable，其中hashtable的存储方式key是String类型的，value也是以key value的形式进行存储。</p>
<p>字典类型的底层就是hashtable实现的，明白了字典的底层实现原理也就是明白了hashtable的实现原理</p>
<p>我们知道hash表最大的问题就是hash冲突，为了解决hash冲突，假如hashtable中不同的key通过计算得到同一个index，就会形成单向链表（<strong>「链地址法」</strong>），如下图所示：</p>
<img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126719.png" srcset="/img/loading.gif" lazyload alt="image-20201112175627751" style="zoom:50%;" />

<p>字典的数据结构如下所示</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> dict&#123;<br>	dictTypr *<span class="hljs-keyword">type</span>;<br>	<span class="hljs-keyword">void</span> *privdata;<br>	dictht ht[<span class="hljs-number">2</span>]<br>	<span class="hljs-keyword">int</span> trehashidx<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino">tyepedef <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dicth</span>&#123;<br>	<span class="hljs-comment">// 	哈希表数组</span><br>	dectEntrt **table;<br>	<span class="hljs-comment">// 哈希表大小</span><br>	<span class="hljs-type">unsigned</span> Long size;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br>	<span class="hljs-comment">// 哈希表已有节点数量</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>由上段代码，我们可知 dict 中存储了一个 dictht 的数组，长度为 2，表明这个数据结构中实际存储着两个哈希表 ht[0] 和 ht[1]，为什么要存储两张 hash 表呢？</p>
<p>当然是为了 Rehash，Rehash 的过程如下：</p>
<ul>
<li>为 ht[1] 分配空间。如果是扩容操作，ht[1] 的大小为第一个大于等于 ht[0].used*2 的 2^n；如果是缩容操作，ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n。</li>
<li>将 ht[0] 中的键值 Rehash 到 ht[1] 中。</li>
<li>当 ht[0] 全部迁移到 ht[1] 中后，释放 ht[0]，将 ht[1] 置为 ht[0]，并为 ht[1] 创建一张新表，为下次 Rehash 做准备</li>
</ul>
<h3 id="渐进式-Rehash"><a href="#渐进式-Rehash" class="headerlink" title="渐进式 Rehash"></a>渐进式 Rehash</h3><p>由于 Redis 的 Rehash 操作是将 ht[0] 中的键值全部迁移到 ht[1]，如果数据量小，则迁移过程很快。但如果数据量很大，一个 Hash 表中存储了几万甚至几百万几千万的键值时，迁移过程很慢并会影响到其他用户的使用</p>
<p>为了避免 Rehash 对服务器性能造成影响，Redis 采用了一种渐进式 Rehash 的策略，分多次、渐进的将 ht[0] 中的数据迁移到 ht[1] 中</p>
<p>前一过程如下：</p>
<ul>
<li>为 ht[1] 分配空间，让字典同时拥有 ht[0] 和 ht[1] 两个哈希表</li>
<li>字典中维护一个 rehashidx，并将它置为 0，表示 Rehash 开始</li>
<li>在 Rehash 期间，每次对字典操作时，程序还顺便将 ht[0] 在 rehashidx 索引上的所有键值对 rehash 到 ht[1] 中，当 Rehash 完成后，将 rehashidx 属性+1。当全部 rehash 完成后，将 rehashidx 置为 -1，表示 rehash 完成</li>
</ul>
<p>注意，由于维护了两张 Hash 表，所以在 Rehash 的过程中内存会增长。另外，在 Rehash 过程中，字典会同时使用 ht[0] 和 ht[1]</p>
<p>所以在删除、查找、更新时会在两张表中操作，在查询时会现在第一张表中查询，如果第一张表中没有，则会在第二张表中查询。但新增时一律会在 ht[1] 中进行，确保 ht[0] 中的数据只会减少不会增加</p>
<h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><p>当 <strong>哈希类型</strong> 无法满足 <code>ziplist</code> 的条件时，<code>Redis</code> 会使用 <code>hashtable</code> 作为 <strong>哈希</strong> 的 <strong>内部实现</strong>，因为此时 <code>ziplist</code> 的 <strong>读写效率</strong> 会下降，而 <code>hashtable</code> 的读写 <strong>时间复杂度</strong> 为 <code>O（1）</code></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; hmset hashkey f1 v1 f2 v2<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; object encoding hashkey<br><span class="hljs-string">&quot;ziplist&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>当有 <code>value</code> <strong>大于</strong> <code>64</code> 字节时，<strong>内部编码</strong> 会由 <code>ziplist</code> 变为 <code>hashtable</code>：</li>
</ul>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; hset hashkey f3 <span class="hljs-string">&quot;one string is bigger than 64 byte...忽略...&quot;</span><br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; object encoding hashkey<br><span class="hljs-string">&quot;hashtable&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>当 <code>field</code> 个数 <strong>超过</strong> <code>512</code>，<strong>内部编码</strong> 也会由 <code>ziplist</code> 变为 <code>hashtable</code>：</li>
</ul>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; hmset hashkey f1 v1 f2 v2 f3 v3 ... f513 v513<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; object encoding hashkey<br><span class="hljs-string">&quot;hashtable&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>压缩列表（ziplist）是一组连续内存块组成的顺序的数据结构，压缩列表能够节省空间，压缩列表中使用多个节点来存储数据</p>
<p>压缩列表是列表键和哈希键底层实现的原理之一，<strong>压缩列表并不是以某种压缩算法进行压缩存储数据，而是它表示一组连续的内存空间的使用，节省空间</strong>，压缩列表的内存结构图如下：</p>
<img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126607.png" srcset="/img/loading.gif" lazyload alt="image-20201112175908202" style="zoom:50%;" />

<p>压缩列表中每一个节点表示的含义如下所示：</p>
<p><strong>zlbytes</strong>：4个字节的大小，记录压缩列表占用内存的字节数</p>
<ol>
<li><strong>zltail</strong>：4个字节大小，记录表尾节点距离起始地址的偏移量，用于快速定位到尾节点的地址</li>
<li><strong>zllen</strong>：2个字节的大小，记录压缩列表中的节点数</li>
<li><strong>entry</strong>：表示列表中的每一个节点</li>
<li><strong>zlend</strong>：表示压缩列表的特殊结束符号’0xFF’</li>
</ol>
<p>再压缩列表中每一个entry节点又有三部分组成，包括<strong>previous_entry_ength</strong>、<strong>encoding</strong>、<strong>content</strong></p>
<ol>
<li><strong>previous_entry_ength</strong>表示前一个节点entry的长度，可用于计算前一个节点的其实地址，因为他们的地址是连续的</li>
<li><strong>encoding</strong>：这里保存的是content的内容类型和长度</li>
<li><strong>content</strong>：content保存的是每一个节点的内容</li>
</ol>
<img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126501.png" srcset="/img/loading.gif" lazyload alt="image-20201112175945189" style="zoom: 50%;" />

<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>哈希表相对于 string 类型存储信息更加的直观，操作也更加的方便，经常会用来做为用户数据的管理，存储用户的信息</p>
<p>hash 也可以用作高并发场景下使用 redis 生成唯一的 id</p>
<ol>
<li><p>存储用户数据</p>
<p>当我们要存储用户数据的时候，肯定是会为用户生成一个唯一标识 id，保持唯一性，用户的其他信息比如生日，年龄，身高、体重等就可以作为 value 值存储</p>
<p>若是传统的实现，就是简单地将用户的全部信息封装成一个对象，然后通过序列化存储数据，当需要获取用户信息的时候再反序列化去拿到用户信息，这样其实也可以，但是如果仅仅是修改了用户的某个信息，就需要将整套数据重新进行序列化存储，对于机器的性能消耗十分巨大</p>
<img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126566.png" srcset="/img/loading.gif" lazyload alt="image-20201112180709684" style="zoom:50%;" /></li>
</ol>
<p>若是使用 Redis 的 hash 来存储用户数据，可以将原来的 value 即用户的详细信息也存储成key、value 的形式，这样就不会带来序列化和反序列化造成的性能开销的问题</p>
<img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081126901.png" srcset="/img/loading.gif" lazyload alt="image-20201112180855998" style="zoom:50%;" />



<h3 id="hash-结构与关系型表"><a href="#hash-结构与关系型表" class="headerlink" title="hash 结构与关系型表"></a>hash 结构与关系型表</h3><p>需要注意的是哈希结构和关系型表有不同之处：</p>
<ol>
<li><strong>哈希类型</strong> 是 <strong>稀疏的</strong>，而 <strong>关系型数据库</strong> 是 <strong>完全结构化</strong>的，例如 <strong>哈希类型</strong> 每个 <strong>键</strong> 可以有不同的 <code>field</code>，而 <strong>关系型数据库</strong> 一旦添加新的 <strong>列</strong>，<strong>所有行</strong> 都要为其 <strong>设置值</strong>（即使为 <code>NULL</code>）</li>
<li><strong>关系型数据库</strong> 可以做复杂的 <strong>关系查询</strong>，而使用 <code>Redis</code> 去模拟关系型复杂查询 <strong>开发困难</strong>，<strong>维护成本高</strong></li>
</ol>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>Redis中的列表在<strong>3.2</strong>之前的版本是使用ziplist和linkedlist进行实现的。在<strong>3.2</strong>之后的版本就是引入了quicklist</p>
<p>ziplist 压缩列表上面已经讲过了，我们来看看linkedlist和quicklist的结构是怎么样的</p>
<p><strong>linkedlist</strong>是一个双向链表，他和普通的链表一样都是由指向前后节点的指针。插入、修改、更新的时间复杂度尾<strong>O(1)<strong>，但是查询的时间复杂度确实</strong>O(n)</strong></p>
<p><strong>linkedlist</strong>和<strong>quicklist</strong>的底层实现是采用链表进行实现，在c语言中并没有内置的链表这种数据结构，Redis实现了自己的链表结构</p>
<img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081127500.png" srcset="/img/loading.gif" lazyload alt="image-20201112181040809" style="zoom:50%;" />

<p>Redis中链表的特性：</p>
<ol>
<li>每一个节点都有指向前一个节点和后一个节点的指针</li>
<li>头节点和尾节点的prev和next指针指向为null，所以链表是无环的</li>
<li>链表有自己长度的信息，获取长度的时间复杂度为O(1)</li>
</ol>
<ul>
<li>当元素 <strong>个数较少</strong> 且 <strong>没有大元素</strong> 时，<strong>内部编码</strong> 为 <code>ziplist</code>：</li>
</ul>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; rpush listkey e1 e2 e3<br>(integer) <span class="hljs-number">3</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; object encoding listkey<br><span class="hljs-string">&quot;ziplist&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>当元素个数超过 <code>512</code> 个，<strong>内部编码</strong> 变为 <code>linkedlist</code>：</li>
</ul>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; rpush listkey e4 e5 ... e512 e513<br>(integer) <span class="hljs-number">513</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; object encoding listkey<br><span class="hljs-string">&quot;linkedlist&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>当某个元素超过 <code>64</code> <strong>字节</strong>，<strong>内部编码</strong> 也会变为 <code>linkedlist</code>：</li>
</ul>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; rpush listkey <span class="hljs-string">&quot;one string is bigger than 64 byte...&quot;</span><br>(integer) <span class="hljs-number">4</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; object encoding listkey<br><span class="hljs-string">&quot;linkedlist&quot;</span><br></code></pre></td></tr></table></figure>



<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>微博列表</li>
<li>热门文章列表</li>
<li>微博热门</li>
<li>消息队列</li>
</ol>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>Redis中列表和集合都可以用来存储字符串，但是<strong>Set是不可重复的集合，而List列表可以存储相同的字符串</strong>，Set集合是无序的这个和后面讲的ZSet有序集合相对</p>
<p>Set的底层实现是<strong>hashtable和intset</strong></p>
<p><strong>inset</strong> 也叫做整数集合，用于保存整数值的数据结构类型，它可以保存int16_t、int32_t 或者int64_t 的整数值</p>
<p>在整数集合中，有三个属性值 <strong>encoding</strong>、<strong>length</strong>、**contents[]**，分别表示编码方式、整数集合的长度、以及元素内容，length就是记录contents里面的大小</p>
<p>在整数集合新增元素的时候，若是超出了原集合的长度大小，就会对集合进行升级，具体的升级过程如下：</p>
<ol>
<li>首先扩展底层数组的大小，并且数组的类型为新元素的类型</li>
<li>然后将原来的数组中的元素转为新元素的类型，并放到扩展后数组对应的位置</li>
<li>整数集合升级后就不会再降级，编码会一直保持升级后的状态</li>
</ol>
<h3 id="内部编码为整数集合"><a href="#内部编码为整数集合" class="headerlink" title="内部编码为整数集合"></a>内部编码为整数集合</h3><p>当元素个数 <strong>较少</strong> 且都为 <strong>整数</strong> 时，<strong>内部编码</strong> 为 <strong>intset</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd setkey <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>(integer) <span class="hljs-number">4</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; object encoding setkey<br><span class="hljs-string">&quot;intset&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="内部编码为哈希"><a href="#内部编码为哈希" class="headerlink" title="内部编码为哈希"></a>内部编码为哈希</h3><p>当 <strong>元素个数</strong> 超过 <code>512</code> 个，<strong>内部编码</strong> 变为 <strong>hashtable</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd setkey <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> ... <span class="hljs-number">512</span> <span class="hljs-number">513</span><br>(integer) <span class="hljs-number">513</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; scard setkey<br>(integer) <span class="hljs-number">513</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; object encoding listkey<br><span class="hljs-string">&quot;hashtable&quot;</span><br></code></pre></td></tr></table></figure>

<p>当某个元素 <strong>不为整数</strong> 时，<strong>内部编码</strong> 也会变为 <strong>hashtable</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd setkey a<br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; object encoding setkey<br><span class="hljs-string">&quot;hashtable&quot;</span><br></code></pre></td></tr></table></figure>



<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>共同好友</li>
<li>二度好友</li>
<li>抽奖</li>
</ol>
<h2 id="ZSet（有序集合）"><a href="#ZSet（有序集合）" class="headerlink" title="ZSet（有序集合）"></a>ZSet（有序集合）</h2><p>ZSet是有序集合，从上面的图中可以看到ZSet的底层实现是<strong>ziplist</strong>和<strong>skiplist</strong>实现的</p>
<p><strong>skiplist</strong> 也叫做<strong>跳跃表</strong>，跳跃表是一种有序的数据结构，它通过每一个节点维持多个指向其它节点的指针，从而达到快速访问的目的</p>
<p>skiplist由如下几个特点：</p>
<ol>
<li>有很多层组成，由上到下节点数逐渐密集，最上层的节点最稀疏，跨度也最大</li>
<li>每一层都是一个有序链表，只扫包含两个节点，头节点和尾节点</li>
<li>每一层的每一个每一个节点都含有指向同一层下一个节点和下一层同一个位置节点的指针</li>
<li>如果一个节点在某一层出现，那么该以下的所有链表同一个位置都会出现该节点</li>
</ol>
<img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081127409.png" srcset="/img/loading.gif" lazyload alt="image-20201112181732228" style="zoom:50%;" />

<p>在跳跃表的结构中有head和tail表示指向头节点和尾节点的指针，能后快速的实现定位。level表示层数，len表示跳跃表的长度，BW表示后退指针，在从尾向前遍历的时候使用</p>
<p>BW下面还有两个值分别表示分值（score）和成员对象（各个节点保存的成员对象）</p>
<p>跳跃表的实现中，除了最底层的一层保存的是原始链表的完整数据，上层的节点数会越来越少，并且跨度会越来越大</p>
<p>跳跃表的上面层就相当于索引层，都是为了找到最后的数据而服务的，数据量越大，条表所体现的查询的效率就越高，和平衡树的查询效率相差无几</p>
<h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>微博热搜，首页按照阅读量高低推荐</li>
<li>各种排行榜</li>
</ol>
<h2 id="BitMap（位图）"><a href="#BitMap（位图）" class="headerlink" title="BitMap（位图）"></a>BitMap（位图）</h2><p>这个就是Redis实现的BloomFilter，BloomFilter非常简单，如下图所示，假设已经有3个元素a、b和c，分别通过3个hash算法h1()、h2()和h2()计算然后对一个bit进行赋值，接下来假设需要判断d是否已经存在，那么也需要使用3个hash算法h1()、h2()和h2()对d进行计算，然后得到3个bit的值，恰好这3个bit的值为1，这就能够说明：<strong>d可能存在集合中</strong>。再判断e，由于h1(e)算出来的bit之前的值是0，那么说明：<strong>e一定不存在集合中</strong>：</p>
<img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081127957.png" srcset="/img/loading.gif" lazyload alt="image-20201112182807211" style="zoom:50%;" />

<p>需要说明的是，bitmap并不是一种真实的数据结构，它本质上是String数据结构，只不过操作的粒度变成了位，即bit。因为String类型最大长度为512MB，所以bitmap最多可以存储2^32个bit</p>
<h2 id="GEO（位置）"><a href="#GEO（位置）" class="headerlink" title="GEO（位置）"></a>GEO（位置）</h2><p>GEO数据结构可以在Redis中存储地理坐标，并且坐标有限制，由EPSG:900913 &#x2F; EPSG:3785 &#x2F; OSGEO:41001 规定如下：</p>
<ul>
<li>有效的经度从-180度到180度</li>
<li>有效的纬度从-85.05112878度到85.05112878度</li>
</ul>
<p>但是，需要说明的是，Geo本身不是一种数据结构，它<strong>本质上还是借助于Sorted Set（ZSET）</strong>，并且使用<strong>GeoHash</strong>技术进行填充。Redis中将经纬度使用52位的整数进行编码，放进zset中，score就是GeoHash的52位整数值。在使用Redis进行Geo查询时，其内部对应的操作其实就是zset(skiplist)的操作。通过zset的score进行排序就可以得到坐标附近的其它元素，通过将score还原成坐标值就可以得到元素的原始坐标。</p>
<p>总之，Redis中处理这些地理位置坐标点的思想是：二维平面坐标点 –&gt; 一维整数编码值 –&gt; zset(score为编码值) –&gt; zrangebyrank(获取score相近的元素)、zrangebyscore –&gt; 通过score(整数编码值)反解坐标点 –&gt; 附近点的地理位置坐标。</p>
<h3 id="GEOHASH-原理"><a href="#GEOHASH-原理" class="headerlink" title="GEOHASH 原理"></a>GEOHASH 原理</h3><p>使用wiki上的例子，纬度为42.6，经度为-5.6的点，转化为base32的话要如何转呢？首先拿纬度来进行说明，纬度的范围为-90到90，将这个范围划为两段，则为[-90,0]、[0,90]，然后看给定的纬度在哪个范围，在前面的范围的话，就设当前位为0，后面的话值便为1.然后继续将确定的范围1分为2，继续以确定值在前段还是后段来确定bit的值。就这样慢慢的缩小范围，一般最多缩小13次就可以了(经纬度的二进制位相加最多25位，经度13位，纬度12位)。这时的中间值，将跟给定的值最相近。如下图所示：</p>
<img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081127559.png" srcset="/img/loading.gif" lazyload alt="image-20201112182945940" style="zoom:50%;" />

<p>第1行，纬度42.6位于[0, 90]之间，所以bit&#x3D;1；第2行，纬度42.6位于[0, 45]之间，所以bit&#x3D;0；第3行，纬度42.6位于[22.5, 45]之间，所以bit&#x3D;1，以此类推。这样，取出图中的bit位：1011 1100 1001，同样的方法，将经度(范围-180到180)算出来为 ：0111 1100 0000 0。结果对其如下：</p>
<ol>
<li><code># 经度0111 1100 0000 0</code></li>
<li><code># 纬度1011 1100 1001</code></li>
</ol>
<p>得到了经纬度的二进制位后，下面需要将两者进行结合：从经度、纬度的循环，每次取其二进制的一位(不足位取0)，合并为新的二进制数：01101111 11110000 01000001 0。每5位为一个十进制数，结合base32对应表映射为base32值为：ezs42。这样就完成了encode的过程。</p>
<h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p>这是Redis5.0引入的全新数据结构，用一句话概括Streams就是Redis实现的内存版kafka。而且，Streams也有<strong>Consumer Groups</strong>的概念。通过Redis源码中对stream的定义我们可知，streams底层的数据结构是<strong>radix tree</strong></p>
<h2 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h2><p>HyperLoglog是redis新支持的两种类型中的另外一种(上一种是位图类型Bitmaps)。主要适用场景是海量数据的计算。特点是速度快。占用空间小。</p>
<p>同样是用于计算，HyperLoglog在适用场景方面与Bitmaps方面有什么不同呢。我个人的理解是，Bitmaps更适合用于验证的大数据，比如签到，</p>
<p>记录某用户是不是当天进行了签到，签到了多少天的时候。也就是说，你不光需要记录数据，还需要对数据进行验证的时候使用Bitmaps。</p>
<p>HyperLoglog则用于只记录的时候，比如访问的uv统计。</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p><strong>基数</strong> 比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/">Redis</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                    
                      <a class="hover-with-bg" href="/tags/Redis/">Redis</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/01/21/Golang%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Golang 配置文件相关操作</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/12/Redis%20%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">
                        <span class="hidden-mobile">Redis 基本介绍及性能分析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"J0a9dxcs8XGWWoDR84hMXA01-gzGzoHsz","appKey":"WbImCRYLaCb0AN9W178IBFBs","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>

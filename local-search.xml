<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用 Ettercap嗅探工具进行 DNS 欺骗实验</title>
    <link href="/2022/03/01/%E4%BD%BF%E7%94%A8%20Ettercap%E5%97%85%E6%8E%A2%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%20DNS%20%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C/"/>
    <url>/2022/03/01/%E4%BD%BF%E7%94%A8%20Ettercap%E5%97%85%E6%8E%A2%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%20DNS%20%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="使用-Ettercap嗅探工具进行-DNS-欺骗实验"><a href="#使用-Ettercap嗅探工具进行-DNS-欺骗实验" class="headerlink" title="使用 Ettercap嗅探工具进行 DNS 欺骗实验"></a>使用 Ettercap嗅探工具进行 DNS 欺骗实验</h1><blockquote><p>前提条件：需要安装<code>kali 虚拟机</code>，或者自己安装<code>ettercap 工具</code></p><p>涉及服务器：本地服务器（172.30.0.56）、kali 虚拟机（172.30.0.133）、网关（172.30.0.1，172.30.0.254）</p></blockquote><h2 id="一、实验名称"><a href="#一、实验名称" class="headerlink" title="一、实验名称"></a>一、实验名称</h2><p><strong>DNS欺骗</strong></p><h2 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a>二、实验原理</h2><p>冒充域名服务器，将查询的 IP 地址设置为攻击者的 IP 地址，这样用户上网就只能看到攻击者主主页，而不是用户访问的真实的页面。</p><p><strong>正常情况</strong></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281509294.png" alt="image-20220228141758055"></p><p><strong>异常情况</strong></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281509975.png" alt="image-20220228141830850"></p><h2 id="三、实验步骤"><a href="#三、实验步骤" class="headerlink" title="三、实验步骤"></a>三、实验步骤</h2><h3 id="1、清除攻击机和靶机的-DNS-缓存数据"><a href="#1、清除攻击机和靶机的-DNS-缓存数据" class="headerlink" title="1、清除攻击机和靶机的 DNS 缓存数据"></a>1、清除攻击机和靶机的 DNS 缓存数据</h3><ul><li><p>MAC系统</p><figure class="highlight ebnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo killall -HUP mDNSResponder</span><br><span class="hljs-attribute">sudo dscacheutil -flushcache</span><br></code></pre></td></tr></table></figure></li><li><p>Windows 系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看 DNS 缓存内容</span><br>ipconfig/displaydns<br><span class="hljs-comment"># 清除 DNS 缓存内容</span><br>ifconfig /flushdns<br></code></pre></td></tr></table></figure></li><li><p>Linux 系统</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># Step 1. 查看 DNS 缓存状况</span><br>sudo systemd-<span class="hljs-built_in">resolve</span> <span class="hljs-comment">--statistics</span><br><br><span class="hljs-comment"># Step 2. 清除 DNS 缓存，systemd-resolve daemon 默认在所有的 Ubuntu 系统上运行</span><br>sudo systemd-<span class="hljs-built_in">resolve</span> <span class="hljs-comment">--flush-caches</span><br><br><span class="hljs-comment"># Step 3. 正在查看验证结果（SYSIN）</span><br>sudo systemd-<span class="hljs-built_in">resolve</span> <span class="hljs-comment">--statistics</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2、修改相关-DNS-文件（攻击机）"><a href="#2、修改相关-DNS-文件（攻击机）" class="headerlink" title="2、修改相关 DNS 文件（攻击机）"></a>2、修改相关 DNS 文件（攻击机）</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 输入命令</span><br><span class="hljs-attribute">vim</span> /etc/ettercap/etter.dns<br><span class="hljs-comment"># 添加内容</span><br>*  A   <span class="hljs-number">172.30.0.133</span><br>*  PTR <span class="hljs-number">172.30.0.133</span><br></code></pre></td></tr></table></figure><h3 id="3、开启自带的-Apache-服务"><a href="#3、开启自带的-Apache-服务" class="headerlink" title="3、开启自带的 Apache 服务"></a>3、开启自带的 Apache 服务</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 开启服务</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">service </span>apache2 start<br><br><span class="hljs-comment"># 查询状态</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">service </span>apache2 status<br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281455623.png" alt="image-20220228145536734"></p><h3 id="4、开启-ettercap-图形界面"><a href="#4、开启-ettercap-图形界面" class="headerlink" title="4、开启 ettercap 图形界面"></a>4、开启 ettercap 图形界面</h3><ul><li><p>方式一</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ettercap -G</span><br></code></pre></td></tr></table></figure></li><li><p>方式二</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281432316.png" alt="image-20220228143217106"></p></li></ul><h3 id="5、选择网卡"><a href="#5、选择网卡" class="headerlink" title="5、选择网卡"></a>5、选择网卡</h3><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281433117.png" alt="image-20220228143315708"></p><h3 id="6、扫描网关下的所有存活主机"><a href="#6、扫描网关下的所有存活主机" class="headerlink" title="6、扫描网关下的所有存活主机"></a>6、扫描网关下的所有存活主机</h3><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281435479.png" alt="image-20220228143537655"></p><p><strong>扫描结果</strong></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281436063.png" alt="image-20220228143633113"></p><h3 id="7、选择攻击目标"><a href="#7、选择攻击目标" class="headerlink" title="7、选择攻击目标"></a>7、选择攻击目标</h3><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281438910.png" alt="image-20220228143810935"></p><h3 id="8、开启-ARP-投毒"><a href="#8、开启-ARP-投毒" class="headerlink" title="8、开启 ARP 投毒"></a>8、开启 ARP 投毒</h3><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281439827.png" alt="image-20220228143935749"></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281440789.png" alt="image-20220228143959644"></p><h3 id="9、使用插件开启-DNS-欺骗"><a href="#9、使用插件开启-DNS-欺骗" class="headerlink" title="9、使用插件开启 DNS 欺骗"></a>9、使用插件开启 DNS 欺骗</h3><p>Plugins –&gt; manage plugins –&gt; dns spoof</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281440797.png" alt="image-20220228144057221"></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281442111.png" alt="image-20220228144218575"></p><h3 id="10、验证结果"><a href="#10、验证结果" class="headerlink" title="10、验证结果"></a>10、验证结果</h3><p><strong>当发生 DNS 欺骗后，靶机请求的数据都会在 ettercap 工具中展示出来！</strong></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281451243.png" alt="image-20220228145135214"></p><p><strong>此时靶机再去请求数据时，页面就会显示我们预想的 Apache 的默认页面！</strong></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281456734.png" alt="image-20220228145652393"></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281457571.png" alt="image-20220228145726419"></p>]]></content>
    
    
    <categories>
      
      <category>安全研究</category>
      
      <category>域名知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS 欺骗</tag>
      
      <tag>安全工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 常见错误及解决办法</title>
    <link href="/2022/01/19/Git%20%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2022/01/19/Git%20%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-常见错误及解决办法"><a href="#Git-常见错误及解决办法" class="headerlink" title="Git 常见错误及解决办法"></a>Git 常见错误及解决办法</h1><blockquote><p>收录使用 Git 过程中遇到的问题</p></blockquote><p>[TOC]</p><h2 id="1、fatal-refusing-to-merge-unrelated-histories"><a href="#1、fatal-refusing-to-merge-unrelated-histories" class="headerlink" title="1、fatal: refusing to merge unrelated histories"></a>1、<code>fatal: refusing to merge unrelated histories</code></h2><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>这种错误在两个分支合并或者<code>git pull</code>以及<code>git push </code>都会出现，这个是因为两个分支没有去的关系，或者远程分支没有和本地分支关联</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>在操作命令后添加<code>--allow-unrelated-history</code></p><h2 id="2、Could-not-read-from-remote-repository"><a href="#2、Could-not-read-from-remote-repository" class="headerlink" title="2、Could not read from remote repository."></a>2、<code>Could not read from remote repository.</code></h2><h3 id="问题描述：-1"><a href="#问题描述：-1" class="headerlink" title="问题描述："></a>问题描述：</h3><p><code>git push</code>过程中出现错误，是因为<code> ssh-key</code> 的问题，本地没有正确配置 <code>ssh-key</code></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs livecodeserver">git@github.com: Permission denied (publickey).<br>fatal: Could <span class="hljs-keyword">not</span> <span class="hljs-built_in">read</span> <span class="hljs-built_in">from</span> remote repository.<br><br>Please make sure you have <span class="hljs-keyword">the</span> correct access rights<br><span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> repository exists.<br></code></pre></td></tr></table></figure><h3 id="解决办法：-1"><a href="#解决办法：-1" class="headerlink" title="解决办法："></a>解决办法：</h3><p>首先查看是否有 ssh 数据   <code>ssh-add -l</code></p><p>如果不存在的话会出现 <code>The agent has no identities.</code></p><p>需要添加<code>ssh-key</code>:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ssh-add ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_github<br>ssh-add ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_github<br></code></pre></td></tr></table></figure><p>添加完毕以后再次验证 <code>ssh-add -l</code></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2048 </span>SHA256:izQU3fcuygtE2jr8KLFhujoS6c/bB46k09uyu/VCRzk xxx@email (RSA)<br><span class="hljs-symbol">2048 </span>SHA256:jH+IeruPI+si++vSWPrr/e14ZDT+flI4xGioGQXF+gc xxx@email (RSA)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git本地仓库关联远程仓库</title>
    <link href="/2022/01/19/Git%20%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <url>/2022/01/19/Git%20%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-本地仓库关联远程仓库"><a href="#Git-本地仓库关联远程仓库" class="headerlink" title="Git 本地仓库关联远程仓库"></a>Git 本地仓库关联远程仓库</h1><h2 id="1、建立远程仓库"><a href="#1、建立远程仓库" class="headerlink" title="1、建立远程仓库"></a>1、建立远程仓库</h2><h2 id="2、初始化本地仓库"><a href="#2、初始化本地仓库" class="headerlink" title="2、初始化本地仓库"></a>2、初始化本地仓库</h2><figure class="highlight csharp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><h2 id="3、修改git-config"><a href="#3、修改git-config" class="headerlink" title="3、修改git config"></a>3、修改git config</h2><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">git config <span class="hljs-literal">user</span>.<span class="hljs-keyword">name</span> <span class="hljs-string">&quot;zhangweijie&quot;</span><br>git config <span class="hljs-literal">user</span>.email <span class="hljs-string">&quot;15538088057@163.com&quot;</span><br></code></pre></td></tr></table></figure><h2 id="4、添加基础文件"><a href="#4、添加基础文件" class="headerlink" title="4、添加基础文件"></a>4、添加基础文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# bubble&quot;</span> &gt;&gt; README.md<br></code></pre></td></tr></table></figure><h2 id="5、提交代码并推送"><a href="#5、提交代码并推送" class="headerlink" title="5、提交代码并推送"></a>5、提交代码并推送</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> README.md<br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>git branch -M main<br>git remote <span class="hljs-built_in">add</span> origin git@github.com:zhangweijie11/bubble.git<br>git push -u origin main<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 代码编译问题</title>
    <link href="/2022/01/19/Golang%20%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/19/Golang%20%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-代码编译问题"><a href="#Golang-代码编译问题" class="headerlink" title="Golang 代码编译问题"></a>Golang 代码编译问题</h1><ul><li>Windows</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 编译代码</span><br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">CGO_ENABLED</span>=0<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">GOOS</span>=darwin<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">GOARCH</span>=amd64<br>go build main.go<br><br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">CGO_ENABLED</span>=0<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">GOOS</span>=linux<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">GOARCH</span>=amd64<br>go build main.go<br></code></pre></td></tr></table></figure><ul><li>Linux</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 编译代码</span><br><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=darwin <span class="hljs-attribute">GOARCH</span>=amd64 go build main.go<br><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=windows <span class="hljs-attribute">GOARCH</span>=amd64 go build main.go<br></code></pre></td></tr></table></figure><ul><li>MAC</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 编译代码</span><br><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=linux <span class="hljs-attribute">GOARCH</span>=amd64 go build main.go  # linux<br><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=windows <span class="hljs-attribute">GOARCH</span>=amd64 go build main.go  # windows<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 配置文件相关操作</title>
    <link href="/2021/01/21/Golang%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/01/21/Golang%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-配置文件相关操作"><a href="#Golang-配置文件相关操作" class="headerlink" title="Golang 配置文件相关操作"></a>Golang 配置文件相关操作</h1><blockquote><p>本文以读取数据库配置文件为例</p></blockquote><h2 id="1、JSON-文件"><a href="#1、JSON-文件" class="headerlink" title="1、JSON 文件"></a>1、JSON 文件</h2><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 解析 json 格式的配置文件</span><br><span class="hljs-comment">文件内容如下：</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  &quot;type&quot;: &quot;json&quot;,</span><br><span class="hljs-comment">  &quot;postgres&quot;: &#123;</span><br><span class="hljs-comment">    &quot;host&quot;: &quot;localhost&quot;,</span><br><span class="hljs-comment">    &quot;port&quot;: 5432,</span><br><span class="hljs-comment">    &quot;username&quot;: &quot;postgres&quot;,</span><br><span class="hljs-comment">    &quot;password&quot;: &quot;postgres&quot;,</span><br><span class="hljs-comment">    &quot;dbname&quot;: &quot;bubble&quot;</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">// 定义第一级配置文件的结构体</span><br><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>Type     <span class="hljs-type">string</span><br>Postgres DbConf <span class="hljs-comment">// 数据类型为第二级配置文件的结构体名称</span><br>&#125;<br><br><span class="hljs-comment">// 定义第二级配置文件的结构体   注意数据类型</span><br><span class="hljs-keyword">type</span> DbConf <span class="hljs-keyword">struct</span> &#123;<br>Host     <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;host&quot;`</span><br>Port     <span class="hljs-type">uint</span>   <span class="hljs-string">`json:&quot;port&quot;`</span><br>Username <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;username&quot;`</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;password&quot;`</span><br>DbName   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;dbname&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// 定义配置文件结构体</span><br><span class="hljs-keyword">type</span> JsonStruct <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// 创建配置文件的构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewJsonStruct</span><span class="hljs-params">()</span></span> *JsonStruct &#123;<br><span class="hljs-keyword">return</span> &amp;JsonStruct&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 加载配置文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(jt *JsonStruct)</span></span> Load(filename <span class="hljs-type">string</span>, v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-comment">// 读取配置文件</span><br>data, err := ioutil.ReadFile(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 解析配置文件</span><br>err = json.Unmarshal(data, v)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>JsonParse := NewJsonStruct()<br>v := Config&#123;&#125;<br><span class="hljs-comment">// 获取配置文件路径</span><br>osGwd, _ := os.Getwd()<br>confPath := osGwd + <span class="hljs-string">&quot;/conf_json.json&quot;</span><br><span class="hljs-comment">// 加载配置文件</span><br>JsonParse.Load(confPath, &amp;v)<br>fmt.Printf(<span class="hljs-string">&quot;配置文件的类型为 %s \n&quot;</span>, v.Type)<br>fmt.Printf(<span class="hljs-string">&quot;PG 数据库的配置为 %s \n&quot;</span>, v.Postgres)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2、YAML-文件-推荐"><a href="#2、YAML-文件-推荐" class="headerlink" title="2、YAML 文件(推荐)"></a>2、YAML 文件(<strong>推荐</strong>)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">解析 yaml 格式的配置文件</span><br><span class="hljs-comment">文件内容如下：</span><br><span class="hljs-comment">database:</span><br><span class="hljs-comment">  postgres:</span><br><span class="hljs-comment">    host: localhost</span><br><span class="hljs-comment">    port: 5432</span><br><span class="hljs-comment">    username: postgres</span><br><span class="hljs-comment">    password: postgres</span><br><span class="hljs-comment">    dbname: bubble</span><br><span class="hljs-comment">&#125; */</span><br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;gopkg.in/yaml.v2&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> YamlStruct <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewYamlStruct</span><span class="hljs-params">()</span></span> *YamlStruct &#123;<br><span class="hljs-keyword">return</span> &amp;YamlStruct&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> YamlConfig <span class="hljs-keyword">struct</span> &#123;<br>DataBase DataBase <span class="hljs-string">`yaml:&quot;database&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> DataBase <span class="hljs-keyword">struct</span> &#123;<br>PgConf PgConf <span class="hljs-string">`yaml:&quot;postgres&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> PgConf <span class="hljs-keyword">struct</span> &#123;<br>Host     <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;host&quot;`</span><br>Port     <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;port&quot;`</span><br>Username <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;username&quot;`</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;password&quot;`</span><br>DbName   <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;dbname&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(yam *YamlStruct)</span></span> Load(filename <span class="hljs-type">string</span>, v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>data, err := ioutil.ReadFile(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err.Error())<br>&#125;<br>err = yaml.Unmarshal(data, v)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err.Error())<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>YamlStruct := NewYamlStruct()<br>v := YamlConfig&#123;&#125;<br>osGwd, _ := os.Getwd()<br>confPath := osGwd + <span class="hljs-string">&quot;/conf_yaml.yaml&quot;</span><br>YamlStruct.Load(confPath, &amp;v)<br>fmt.Printf(<span class="hljs-string">&quot;配置文件的数据为 %s \n&quot;</span>, v.DataBase)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3、INI-文件"><a href="#3、INI-文件" class="headerlink" title="3、INI 文件"></a>3、INI 文件</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 解析 ini 格式的配置文件</span><br><span class="hljs-comment">文件内容如下：</span><br><span class="hljs-comment">mode=debug</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">[postgres]</span><br><span class="hljs-comment">host=localhost</span><br><span class="hljs-comment">port=5432</span><br><span class="hljs-comment">username=postgres</span><br><span class="hljs-comment">password=postgres</span><br><span class="hljs-comment">dbname=bubble</span><br><span class="hljs-comment"> */</span><br><br>import (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/go-ini/ini&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">//type Postgres struct &#123;</span><br><span class="hljs-comment">//Host     string</span><br><span class="hljs-comment">//Port     uint</span><br><span class="hljs-comment">//Username string</span><br><span class="hljs-comment">//Password string</span><br><span class="hljs-comment">//DbName   string</span><br><span class="hljs-comment">//&#125;</span><br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br>osGwd, _ := os<span class="hljs-selector-class">.Getwd</span>()<br>confPath := osGwd + <span class="hljs-string">&quot;/conf_ini.ini&quot;</span><br>config, err := ini<span class="hljs-selector-class">.Load</span>(confPath)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-built_in">panic</span>(err<span class="hljs-selector-class">.Error</span>())<br>&#125;<br><span class="hljs-comment">// 可以直接读取配置，并设置默认值</span><br>mode := config<span class="hljs-selector-class">.Section</span>(<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-selector-class">.Key</span>(<span class="hljs-string">&quot;mode&quot;</span>)<span class="hljs-selector-class">.MustString</span>(<span class="hljs-string">&quot;debug&quot;</span>)<br>fmt<span class="hljs-selector-class">.Println</span>(mode)<br>postgres, err := config<span class="hljs-selector-class">.GetSection</span>(<span class="hljs-string">&quot;postgres&quot;</span>)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-built_in">panic</span>(err<span class="hljs-selector-class">.Error</span>())<br>&#125;<br><span class="hljs-comment">// 可通过 Key 去取值</span><br>fmt<span class="hljs-selector-class">.Println</span>(postgres<span class="hljs-selector-class">.Key</span>(<span class="hljs-string">&quot;host&quot;</span>))  <span class="hljs-comment">// localhost</span><br>fmt<span class="hljs-selector-class">.Println</span>(postgres<span class="hljs-selector-class">.Keys</span>())       <span class="hljs-comment">//  [localhost 5432 postgres postgres bubble]</span><br>fmt<span class="hljs-selector-class">.Println</span>(postgres<span class="hljs-selector-class">.KeyStrings</span>()) <span class="hljs-comment">// [host port username password dbname]</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置 GitHub 以及 GitLab 账户</title>
    <link href="/2020/03/17/%E9%85%8D%E7%BD%AE%20GitHub%20%E4%BB%A5%E5%8F%8A%20Gitlab%20%E8%B4%A6%E6%88%B7/"/>
    <url>/2020/03/17/%E9%85%8D%E7%BD%AE%20GitHub%20%E4%BB%A5%E5%8F%8A%20Gitlab%20%E8%B4%A6%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="配置-GitHub-以及-Gitlab-账户"><a href="#配置-GitHub-以及-Gitlab-账户" class="headerlink" title="配置 GitHub 以及 Gitlab 账户"></a>配置 GitHub 以及 Gitlab 账户</h2><h3 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h3><p>全局配置 Git 账户</p><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-comment">// 配置全局用户名，如Github上注册的用户名</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;yyy@mail.com&quot;</span> <span class="hljs-comment">// 配置全局邮箱，如Github上配置的邮箱</span><br></code></pre></td></tr></table></figure><p>这个<code>--global</code>选项，是指这里配置的<code>user.name</code>和<code>user.email</code>是相对于全局进行配置的，即不同的Git仓库默认的用户名和邮箱都是这个值。由于需要管理多个账户，所以仅仅使用这个全局值是不够的，<strong>需要在每个仓库中单独配置</strong>。对此，有两种处理方法：</p><p>如果之前已经使用该命令进行配置，则先使用如下命令清除</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> user<span class="hljs-selector-class">.name</span><br>git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> user.email<br></code></pre></td></tr></table></figure><p>如果不确定是否已经配置过，可以使用下面的命令查看</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.name</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.email</span><br></code></pre></td></tr></table></figure><h3 id="2、开始配置"><a href="#2、开始配置" class="headerlink" title="2、开始配置"></a>2、开始配置</h3><h4 id="2-1-针对不同的账户生成不同的密匙"><a href="#2-1-针对不同的账户生成不同的密匙" class="headerlink" title="2.1 针对不同的账户生成不同的密匙"></a>2.1 针对不同的账户生成不同的密匙</h4><p>进入保存密匙的目录</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/.ssh</span> <span class="hljs-string">//</span> 进入目录，该目录下保存生成的秘钥<br></code></pre></td></tr></table></figure><p>然后，根据账户邮箱生成秘钥。例如我在GitHub上的邮箱是<a href="mailto:&#120;&#120;&#x78;&#x40;&#121;&#x79;&#x79;&#x2e;&#99;&#x6f;&#x6d;">&#120;&#120;&#x78;&#x40;&#121;&#x79;&#x79;&#x2e;&#99;&#x6f;&#x6d;</a>，则命令为：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;xxx@yyy.com&quot;</span><br></code></pre></td></tr></table></figure><p>输入完成后，会有如下提示：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Generating <span class="hljs-keyword">public</span>/<span class="hljs-keyword">private</span> rsa key pair.<br>Enter <span class="hljs-keyword">file</span> in which to save the key (<span class="hljs-regexp">/Users/</span>zhangweijie<span class="hljs-regexp">/.ssh/i</span>d_rsa):<span class="hljs-regexp">/Users/</span>zhangweijie<span class="hljs-regexp">/.ssh/i</span>d_rsa_github<br></code></pre></td></tr></table></figure><p>这里要求对秘钥进行命名，默认的文件名是<code>id_rsa</code>。为了方便区分，我这里命名为<code>id_rsa_github</code>。接下来的提示都直接进行回车，直到秘钥生成。通过<code>ls</code>命令，可以看到刚刚生成的密钥对<code>id_rsa_github</code>和<code>id_rsa_github.pub</code>。其中<code>id_rsa_github.pub</code>是公钥。</p><p>同样，对于GitLab上的账户，我是用另一个邮箱注册的，按照同样的步骤生成<code>id_rsa_gitlab</code>的秘钥对。接下来的步骤，除额外说明外，两个账户的操作完全相同。</p><h4 id="2-2-私匙添加到本地"><a href="#2-2-私匙添加到本地" class="headerlink" title="2.2 私匙添加到本地"></a>2.2 私匙添加到本地</h4><p>SSH协议的原理，就是在托管网站上使用公钥，在本地使用私钥，这样本地仓库就可以和远程仓库进行通信。在上一步已经生成了秘钥文件，接下来需要使用秘钥文件，首先是在本地使用秘钥文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">ssh-add ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_github <span class="hljs-regexp">//</span> 将GitHub私钥添加到本地<br>ssh-add ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_gitlab <span class="hljs-regexp">//</span> 将GitLab私钥添加到本地<br></code></pre></td></tr></table></figure><p>为了检验本地是否添加成功，可以使用<code>ssh-add -l</code>命令进行查看</p><h4 id="2-3-对本地秘钥进行配置"><a href="#2-3-对本地秘钥进行配置" class="headerlink" title="2.3  对本地秘钥进行配置"></a>2.3  对本地秘钥进行配置</h4><p>由于添加了多个密钥文件，所以需要对这多个密钥进行管理。在<code>.ssh</code>目录下新建一个config文件：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">touch config<br></code></pre></td></tr></table></figure><p>文件中的内容如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">Host github <span class="hljs-regexp">//</span> 网站的别名，随意取<br>HostName github.com <span class="hljs-regexp">//</span> 托管网站的域名<br>User liugui <span class="hljs-regexp">//</span> 托管网站上的用户名<br>IdentityFile ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_github <span class="hljs-regexp">//</span> 使用的密钥文件<br><br><span class="hljs-regexp">//</span> GitLab的配置相同<br>Host gitlab<br>HostName gitlab.com<br>User liugui<br>IdentityFile ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_gitlab<br></code></pre></td></tr></table></figure><h4 id="2-4-公匙添加到托管网站"><a href="#2-4-公匙添加到托管网站" class="headerlink" title="2.4 公匙添加到托管网站"></a>2.4 公匙添加到托管网站</h4><p>以GitHub为例，先在本地复制公钥。进入<code>.ssh</code>目录，使用<code>vim id_rsa_github.pub</code>查看生成的GitHub公钥，全选进行复制。</p><p>登录GitHub，点击右上角头像选择<code>settings</code>，在打开的页面中选择SSH and GPG keys，</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081111553.png" alt="图片描述"></p><p>在打开的页面的Key输入框中粘贴刚刚复制的公钥，title的名字自己随便去，然后点击下方的<code>Add SSH key</code>按钮：<br><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081111010.png" alt="图片描述"></p><p>至此，托管网站的公钥添加完成。总结来说，就是针对每个托管网站分别生成一对密钥，然后分别添加到本地和托管网站。</p><p>这时候，可以测试一下配置是否成功，测试命令使用别名。例如，对于GitHub，本来应该使用的测试命令是：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><p>在config文件中，给GitHub网站配置的别名就是github，所以直接使用别名，就是</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span><br></code></pre></td></tr></table></figure><h3 id="3、如何使用"><a href="#3、如何使用" class="headerlink" title="3、如何使用"></a>3、如何使用</h3><p>使用有两种情况，一种情况是从远端拉取代码到本地，一种是本地已有仓库需要与远程仓库关联。</p><h4 id="3-1-从远端拉取代码"><a href="#3-1-从远端拉取代码" class="headerlink" title="3.1 从远端拉取代码"></a>3.1 从远端拉取代码</h4><p>选择SSH协议的复制命令，如对于GitLab上代码库test，其复制命令为</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@gitlab.com:liugui/test.git<br></code></pre></td></tr></table></figure><p>由于使用了别名gitlab，所以实际使用的复制命令应当为：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">git clone git<span class="hljs-variable">@gitlab</span><span class="hljs-symbol">:liugui/test</span>.git<br></code></pre></td></tr></table></figure><p>也可以不进行修改，git 会自己找到对应的域名</p><h4 id="3-2-本地已有的仓库"><a href="#3-2-本地已有的仓库" class="headerlink" title="3.2 本地已有的仓库"></a>3.2 本地已有的仓库</h4><p>这种情况适用于本地新建的仓库需要与远端进行关联，或者之前已经使用sourceTree等图形界面软件拷贝的仓库。进入本地仓库文件夹，需要单独配置该仓库的用户名和邮箱</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">git config <span class="hljs-literal">user</span>.<span class="hljs-keyword">name</span> <span class="hljs-string">&quot;xxx&quot;</span><br>git config <span class="hljs-literal">user</span>.email <span class="hljs-string">&quot;xxx@yyy.com&quot;</span><br></code></pre></td></tr></table></figure><p>然后，进入本地仓库的git目录，打开config文件</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">.git</span> <span class="hljs-string">//</span> 该目录是隐藏的，<span class="hljs-keyword">ls</span>命令不可见，但是可以直接进入，如果是新建的文件夹需要先执行git init<br>vim config<br></code></pre></td></tr></table></figure><p>在config文件中，修改（config文件中已有remote “origin”信息）或者添加（config文件中不包含remote “origin”信息）分支信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[remote <span class="hljs-string">&quot;origin&quot;</span>]<br>        url = git<span class="hljs-variable">@gitlab</span><span class="hljs-symbol">:xxx/test</span>.git<br>        fetch = +refs/heads/*<span class="hljs-symbol">:refs/remotes/origin/*</span><br></code></pre></td></tr></table></figure><p>主要是URL部分，原生的信息一般是<code>git@gitlab.com:xxx/test.git</code>，需要将gitlab.com使用别名gitlab代替。</p><p>可以看到，仓库中的关键是要配置好用户名和邮箱，以及使用别名。使用别名的目的是为了通过别名，将本地仓库与密钥目录<code>.ssh</code>文件夹下的密钥进行管理，这样就完成了本地仓库使用的私钥与托管网站使用的公钥的配对，而用户名和邮箱是该仓库使用SSH协议时需要用到的信息</p>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>GitLab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kibana简介</title>
    <link href="/2020/02/06/kibana%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/02/06/kibana%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Kibana简介"><a href="#Kibana简介" class="headerlink" title="Kibana简介"></a>Kibana简介</h2><h3 id="1、kibana-下载"><a href="#1、kibana-下载" class="headerlink" title="1、kibana 下载"></a>1、kibana 下载</h3><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.elastic.co<span class="hljs-regexp">/cn/</span>downloads/kibana<br></code></pre></td></tr></table></figure><h3 id="2、kibana-启动"><a href="#2、kibana-启动" class="headerlink" title="2、kibana 启动"></a>2、kibana 启动</h3><p>解压后进入该目录，首先启动kibana</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kibana <span class="hljs-comment"># 启动命令</span><br>网址为：localhost:5601 <span class="hljs-comment"># 查看是否启动成功</span><br></code></pre></td></tr></table></figure><h3 id="3、插件管理"><a href="#3、插件管理" class="headerlink" title="3、插件管理"></a>3、插件管理</h3><p>查看插件信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kiban-plugin list<br></code></pre></td></tr></table></figure><p>下载插件</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bin/kiban-plugin </span><span class="hljs-keyword">install </span>plugin_location <br></code></pre></td></tr></table></figure><h3 id="4、DSL-基本命令"><a href="#4、DSL-基本命令" class="headerlink" title="4、DSL 基本命令"></a>4、DSL 基本命令</h3>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>ELK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ELK</tag>
      
      <tag>Kibana</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>logstash 简介</title>
    <link href="/2020/02/05/logstash%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/02/05/logstash%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="logstash-简介"><a href="#logstash-简介" class="headerlink" title="logstash 简介"></a>logstash 简介</h2><h3 id="1、下载及启动"><a href="#1、下载及启动" class="headerlink" title="1、下载及启动"></a>1、下载及启动</h3><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.elastic.co<span class="hljs-regexp">/cn/</span>downloads/logstash  <span class="hljs-comment"># 下载地址</span><br></code></pre></td></tr></table></figure><p>解压后进入该目录，将写好的配置文件放进 bin 文件夹</p><p>文件如下</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs puppet"><span class="hljs-keyword">input</span> &#123;<br>  file &#123;<br>    <span class="hljs-attr">path</span> =&gt; <span class="hljs-string">&quot;/Users/zhangweijie/ELK/logstash-7.5.2/bin/movies.csv&quot;</span><br>    <span class="hljs-attr">start_position</span> =&gt; <span class="hljs-string">&quot;beginning&quot;</span><br>    <span class="hljs-attr">sincedb_path</span> =&gt; <span class="hljs-string">&quot;/dev/null&quot;</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">filter</span> &#123;<br>  csv &#123;<br>    <span class="hljs-attr">separator</span> =&gt; <span class="hljs-string">&quot;,&quot;</span><br>    <span class="hljs-attr">columns</span> =&gt; [<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>,<span class="hljs-string">&quot;genre&quot;</span>]<br>  &#125;<br><br>  <span class="hljs-keyword">mutate</span> &#123;<br>    <span class="hljs-attr">split</span> =&gt; &#123; <span class="hljs-string">&quot;genre&quot;</span> =&gt; <span class="hljs-string">&quot;|&quot;</span> &#125;<br>    <span class="hljs-keyword">remove_field</span> =&gt; [<span class="hljs-string">&quot;path&quot;</span>, <span class="hljs-string">&quot;host&quot;</span>,<span class="hljs-string">&quot;@timestamp&quot;</span>,<span class="hljs-string">&quot;message&quot;</span>]<br>  &#125;<br><br>  <span class="hljs-keyword">mutate</span> &#123;<br><br>    <span class="hljs-attr">split</span> =&gt; [<span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-string">&quot;(&quot;</span>]<br>    <span class="hljs-attr">add_field</span> =&gt; &#123; <span class="hljs-string">&quot;title&quot;</span> =&gt; <span class="hljs-string">&quot;%&#123;[content][0]&#125;&quot;</span>&#125;<br>    <span class="hljs-keyword">add_field</span> =&gt; &#123; <span class="hljs-string">&quot;year&quot;</span> =&gt; <span class="hljs-string">&quot;%&#123;[content][1]&#125;&quot;</span>&#125;<br>  &#125;<br><br>  <span class="hljs-keyword">mutate</span> &#123;<br>    <span class="hljs-attr">convert</span> =&gt; &#123;<br>      <span class="hljs-string">&quot;year&quot;</span> =&gt; <span class="hljs-string">&quot;integer&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">strip</span> =&gt; [<span class="hljs-string">&quot;title&quot;</span>]<br>    remove_field =&gt; [<span class="hljs-string">&quot;path&quot;</span>, <span class="hljs-string">&quot;host&quot;</span>,<span class="hljs-string">&quot;@timestamp&quot;</span>,<span class="hljs-string">&quot;message&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>]<br>  &#125;<br><br>&#125;<br><span class="hljs-keyword">output</span> &#123;<br>   elasticsearch &#123;<br>     <span class="hljs-attr">hosts</span> =&gt; <span class="hljs-string">&quot;http://localhost:9200&quot;</span><br>     <span class="hljs-attr">index</span> =&gt; <span class="hljs-string">&quot;movies&quot;</span><br>     <span class="hljs-attr">document_id</span> =&gt; <span class="hljs-string">&quot;%&#123;id&#125;&quot;</span><br>   &#125;<br>  <span class="hljs-keyword">stdout</span> &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ./logstash -f logstash.conf<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>ELK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ELK</tag>
      
      <tag>logstash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch 简介</title>
    <link href="/2020/02/05/Elasticsearch%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/02/05/Elasticsearch%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch简介"><a href="#Elasticsearch简介" class="headerlink" title="Elasticsearch简介"></a>Elasticsearch简介</h2><h3 id="1、Elasticsearch-下载及启动"><a href="#1、Elasticsearch-下载及启动" class="headerlink" title="1、Elasticsearch 下载及启动"></a>1、Elasticsearch 下载及启动</h3><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.elastic.co<span class="hljs-regexp">/cn/</span>downloads/elasticsearch   <span class="hljs-comment"># 下载地址</span><br></code></pre></td></tr></table></figure><p>下载完成后解压进入该文件目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/elasticsearch  <span class="hljs-comment"># 启动 elasticsearch</span><br>网址输入为：localhost:9200  <span class="hljs-comment"># 查看是否启动成功</span><br></code></pre></td></tr></table></figure><h3 id="2、插件管理"><a href="#2、插件管理" class="headerlink" title="2、插件管理"></a>2、插件管理</h3><p>查看插件目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/elasticsearch-plugins list<br></code></pre></td></tr></table></figure><p>安装插件</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bin/elasticsearch-plugins </span><span class="hljs-keyword">install </span>analysis-icu<br></code></pre></td></tr></table></figure><p>如何查看插件是否安装成功</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">bin/elasticsearch <span class="hljs-comment"># 启动 elasticsearch</span><br>网址输入为：localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_cat/</span>plugins   <span class="hljs-comment"># _cat 为一个查询API</span><br></code></pre></td></tr></table></figure><h3 id="3、node-管理"><a href="#3、node-管理" class="headerlink" title="3、node 管理"></a>3、node 管理</h3><p>启动多个elasticsearch 实例</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># node.name为节点名称或实例名称   cluster.name为集群名称  path.data为存放数据路径</span><br>bin/elasticsearch -E node.<span class="hljs-attribute">name</span>=node0 -E cluster.<span class="hljs-attribute">name</span>=geektime -E path.<span class="hljs-attribute">data</span>=node0_data -d<br>bin/elasticsearch -E node.<span class="hljs-attribute">name</span>=node1 -E cluster.<span class="hljs-attribute">name</span>=geektime -E path.<span class="hljs-attribute">data</span>=node1_data -d<br></code></pre></td></tr></table></figure><p>查看 node</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">网址为：localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_cat/</span>nodes<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>ELK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ELK</tag>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>inint与 new 方法</title>
    <link href="/2019/11/20/init%20%E4%B8%8E%20new%20%E6%96%B9%E6%B3%95/"/>
    <url>/2019/11/20/init%20%E4%B8%8E%20new%20%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="init-与-new-方法"><a href="#init-与-new-方法" class="headerlink" title="__init__与 __new__ 方法"></a><code>__init__</code>与 <code>__new__</code> 方法</h2><h3 id="new-和-init-参数的不同"><a href="#new-和-init-参数的不同" class="headerlink" title="__new__和__init__参数的不同"></a><code>__new__</code>和<code>__init__</code>参数的不同</h3><p><code>__new__</code>所接收的第一个参数是<code>cls</code>，而<code>__init__</code>所接收的第一个参数是<code>self</code>。这是因为当我们调用<code>__new__</code>的时候，该类的实例还并不存在（也就是<code>self</code>所引用的对象还不存在），所以需要接收一个类作为参数，从而产生一个实例。而当我们调用<code>__init__</code>的时候，实例已经存在，因此<code>__init__</code>接受<code>self</code>作为第一个参数并对该实例进行必要的初始化操作。这也意味着<code>__init__</code>是在<code>__new__</code>之后被调用的。</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">newStyleClass</span>(<span class="hljs-title class_ inherited__">object</span>): <br>    <span class="hljs-comment"># In Python2, we need to specify the object as the base.</span><br>    <span class="hljs-comment"># In Python3 it&#x27;s default.</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;__new__ is called&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(newStyleClass, cls).__new__(cls)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;__init__ is called&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;self is: &quot;</span>, self)<br><br>n=newStyleClass()<br><span class="hljs-built_in">print</span>(n)<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">__new__ <span class="hljs-keyword">is</span> called<br>__init__ <span class="hljs-keyword">is</span> called<br>self <span class="hljs-keyword">is</span>: &lt;__main__.newStyleClass <span class="hljs-keyword">at</span> <span class="hljs-number">0</span>x109290890&gt;<br>&lt;__main__.newStyleClass <span class="hljs-keyword">at</span> <span class="hljs-number">0</span>x109290890&gt;<br></code></pre></td></tr></table></figure><p>创建类实例并初始化的过程中<code>__new__</code>和<code>__init__</code>被调用的顺序也能从上面代码的输出结果中看出：<code>__new__</code>函数首先被调用，构造了一个<code>newStyleClass</code>的实例，接着<code>__init__</code>函数在<code>__new__</code>函数返回一个实例的时候被调用，并且这个实例作为<code>self</code>参数被传入了<code>__init__</code>函数。****</p><p>这里需要注意的是，如果<code>__new__</code>函数返回一个已经存在的实例（不论是哪个类的），<code>__init__</code>不会被调用。如下面代码所示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">obj = <span class="hljs-number">12</span> <br># obj can be an <span class="hljs-keyword">object</span> from any <span class="hljs-keyword">class</span>, even <span class="hljs-keyword">object</span>.<span class="hljs-constructor">__new__(<span class="hljs-params">object</span>)</span><br><br><span class="hljs-keyword">class</span> return<span class="hljs-constructor">ExistedObj(<span class="hljs-params">object</span>)</span>:<br>    def <span class="hljs-constructor">__new__(<span class="hljs-params">cls</span>)</span>:<br>        print(<span class="hljs-string">&quot;__new__ is called&quot;</span>)<br>        return obj<br><br>    def <span class="hljs-constructor">__init(<span class="hljs-params">self</span>)</span>:<br>        print(<span class="hljs-string">&quot;__init__ is called&quot;</span>)<br><br>r=return<span class="hljs-constructor">ExistedObj()</span><br>print(r)<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">__new__ <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span><br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>同时另一个需要注意的点是：</p><p>如果我们在<code>__new__</code>函数中不返回任何对象，则<code>__init__</code>函数也不会被调用。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">notReturnObj</span>(<span class="hljs-symbol">object</span>):<br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">__new__</span>(<span class="hljs-symbol">cls</span>):<br>        <span class="hljs-symbol">print</span>(&quot;<span class="hljs-symbol">__new__</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">called</span>&quot;)<br><br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">__init__</span>(<span class="hljs-symbol">self</span>):<br>        <span class="hljs-symbol">print</span>(&quot;<span class="hljs-symbol">__init__</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">called</span>&quot;)<br><br><span class="hljs-symbol">print</span>(<span class="hljs-symbol">notReturnObj</span>())<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">__new__ <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span><br><span class="hljs-keyword">None</span><br></code></pre></td></tr></table></figure><p>可见如果<code>__new__</code>函数不返回对象的话，不会有任何对象被创建，<code>__init__</code>函数也不会被调用来初始化对象，<code>__new__</code>返回 None</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>__init__</code>不能有返回值</li><li><code>__new__</code>函数直接上可以返回别的类的实例。如上面例子中的<code>returnExistedObj</code>类的<code>__new__</code>函数返回了一个<code>int</code>值。</li><li>只有在<code>__new__</code>返回一个新创建属于该类的实例时当前类的<code>__init__</code>才会被调用.</li><li>![image-20191120105155474](&#x2F;Users&#x2F;zhangweijie&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20191120105155474.png)</li></ol>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>标准库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aiohttp 模块详解</title>
    <link href="/2019/11/06/aiohttp%20%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3.md/"/>
    <url>/2019/11/06/aiohttp%20%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3.md/</url>
    
    <content type="html"><![CDATA[<h2 id="aiohttp-模块详解"><a href="#aiohttp-模块详解" class="headerlink" title="aiohttp 模块详解"></a>aiohttp 模块详解</h2><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a><strong>0. 前言</strong></h3><p>本文翻译自aiohttp的官方文档，如有纰漏，欢迎指出。</p><p>aiohttp分为服务器端和客户端，本文只介绍客户端。</p><p>另外我已经对 aiohttp 和 asyncio进行了封装，可以参考我的 github 地址：</p><p><a href="https://github.com/web-trump/ahttp">https://github.com/web-trump/ahttp</a></p><p>由于上下文的缘故，请求代码必须在一个异步的函数中进行：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>():<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h3 id="1-aiohttp安装"><a href="#1-aiohttp安装" class="headerlink" title="1. aiohttp安装"></a><strong>1. aiohttp安装</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip3 install aiohttp<br></code></pre></td></tr></table></figure><h4 id="1-1-基本请求用法"><a href="#1-1-基本请求用法" class="headerlink" title="1.1. 基本请求用法"></a><strong>1.1. 基本请求用法</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.get(<span class="hljs-string">&#x27;https://github.com&#x27;</span>) <span class="hljs-keyword">as</span> r:<br>    <span class="hljs-keyword">await</span> r.text()<br></code></pre></td></tr></table></figure><p>其中r.text(), 可以在括号中指定解码方式，编码方式，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">await</span> resp.text(encoding=<span class="hljs-string">&#x27;windows-1251&#x27;</span>)<br></code></pre></td></tr></table></figure><p>或者也可以选择不编码，适合读取图像等，是无法编码的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">await</span> resp.read()<br></code></pre></td></tr></table></figure><h3 id="2-发起一个session请求"><a href="#2-发起一个session请求" class="headerlink" title="2.发起一个session请求"></a><strong>2.发起一个session请求</strong></h3><p>首先是导入aiohttp模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiohttp<br></code></pre></td></tr></table></figure><p>然后我们试着获取一个web源码，这里以GitHub的公共Time-line页面为例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>        <span class="hljs-built_in">print</span>(resp.status)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure><p>上面的代码中，我们创建了一个 ClientSession 对象命名为session，然后通过session的get方法得到一个 ClientResponse 对象，命名为resp，get方法中传入了一个必须的参数url，就是要获得源码的http url。至此便通过协程完成了一个异步IO的get请求。</p><p>有get请求当然有post请求，并且post请求也是一个协程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=<span class="hljs-string">b&#x27;data&#x27;</span>)<br></code></pre></td></tr></table></figure><p>用法和get是一样的，区别是post需要一个额外的参数data，即是需要post的数据。</p><p>除了get和post请求外，其他http的操作方法也是一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">session.put(<span class="hljs-string">&#x27;http://httpbin.org/put&#x27;</span>, data=<span class="hljs-string">b&#x27;data&#x27;</span>)<br><br>session.delete(<span class="hljs-string">&#x27;http://httpbin.org/delete&#x27;</span>)<br><br>session.head(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>)<br><br>session.options(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>)<br><br>session.patch(<span class="hljs-string">&#x27;http://httpbin.org/patch&#x27;</span>, data=<span class="hljs-string">b&#x27;data&#x27;</span>)<br></code></pre></td></tr></table></figure><p>小记：</p><p>不要为每次的连接都创建一次session,一般情况下只需要创建一个session，然后使用这个session执行所有的请求。</p><p>每个session对象，内部包含了一个连接池，并且将会保持连接和连接复用（默认开启）可以加快整体的性能。</p><h3 id="3-在URL中传递参数"><a href="#3-在URL中传递参数" class="headerlink" title="3.在URL中传递参数"></a><strong>3.在URL中传递参数</strong></h3><p>我们经常需要通过 get 在url中传递一些参数，参数将会作为url问号后面的一部分发给服务器。在aiohttp的请求中，允许以dict的形式来表示问号后的参数。举个例子，如果你想传递 key1&#x3D;value1  key2&#x3D;value2 到 httpbin.org&#x2F;get 你可以使用下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">params = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>, params=params) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-keyword">assert</span> resp.url == <span class="hljs-string">&#x27;http://httpbin.org/get?key2=value2&amp;key1=value1&#x27;</span><br></code></pre></td></tr></table></figure><p>可以看到，代码正确的执行了，说明参数被正确的传递了进去。不管是一个参数两个参数，还是更多的参数，都可以通过这种方式来传递。除了这种方式之外，还有另外一个，使用一个 list 来传递（这种方式可以传递一些特殊的参数，例如下面两个key是相等的也可以正确传递）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">params = [(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>), (<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>)]<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>, params=params) <span class="hljs-keyword">as</span> r:<br>    <span class="hljs-keyword">assert</span> r.url == <span class="hljs-string">&#x27;http://httpbin.org/get?key=value2&amp;key=value1&#x27;</span><br></code></pre></td></tr></table></figure><p>除了上面两种，我们也可以直接通过传递字符串作为参数来传递，但是需要注意，通过字符串传递的特殊字符不会被编码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>, params=<span class="hljs-string">&#x27;key=value+1&#x27;</span>) <span class="hljs-keyword">as</span> r:<br>    <span class="hljs-keyword">assert</span> r.url == <span class="hljs-string">&#x27;http://httpbin.org/get?key=value+1&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="4-响应的内容"><a href="#4-响应的内容" class="headerlink" title="4.响应的内容"></a>4.响应的内容</h3><p>还是以GitHub的公共Time-line页面为例，我们可以获得页面响应的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure><p>运行之后，会打印出类似于如下的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;[&#123;&quot;created_at&quot;:&quot;2015-06-12T14:06:22Z&quot;,&quot;public&quot;:true,&quot;actor&quot;:&#123;...</span><br></code></pre></td></tr></table></figure><p>resp的text方法，会自动将服务器端返回的内容进行解码–decode，当然我们也可以自定义编码方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">await</span> resp.text(encoding=<span class="hljs-string">&#x27;gb2312&#x27;</span>)<br></code></pre></td></tr></table></figure><p>除了text方法可以返回解码后的内容外，我们也可以得到类型是字节的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.read())<br></code></pre></td></tr></table></figure><p>运行的结果是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">b&#x27;[&#123;&quot;created_at&quot;:&quot;2015-06-12T14:06:22Z&quot;,&quot;public&quot;:true,&quot;actor&quot;:&#123;...</span><br></code></pre></td></tr></table></figure><p>gzip和deflate转换编码已经为你自动解码。</p><p>小记：</p><p>text(),read()方法是把整个响应体读入内存，如果你是获取大量的数据，请考虑使用”字节流“（streaming response）</p><h3 id="5-特殊响应内容：json"><a href="#5-特殊响应内容：json" class="headerlink" title="5.特殊响应内容：json"></a><strong>5.特殊响应内容：json</strong></h3><p>如果我们获取的页面的响应内容是json，aiohttp内置了更好的方法来处理json:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.json())<br></code></pre></td></tr></table></figure><p>如果因为某种原因而导致resp.json()解析json失败，例如返回不是json字符串等等，那么resp.json()将抛出一个错误，也可以给json()方法指定一个解码方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.json(encoding=<span class="hljs-string">&#x27;gb2312&#x27;</span>))<br></code></pre></td></tr></table></figure><p>或者传递一个函数进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.json(<span class="hljs-keyword">lambda</span>(x:x.replace(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>))))<br></code></pre></td></tr></table></figure><h3 id="6-以字节流的方式读取响应内容"><a href="#6-以字节流的方式读取响应内容" class="headerlink" title="6.以字节流的方式读取响应内容"></a>6.以字节流的方式读取响应内容</h3><p>虽然json(),text(),read()很方便的能把响应的数据读入到内存，但是我们仍然应该谨慎的使用它们，因为它们是把整个的响应体全部读入了内存。即使你只是想下载几个字节大小的文件，但这些方法却将在内存中加载所有的数据。所以我们可以通过控制字节数来控制读入内存的响应内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-keyword">await</span> resp.content.read(<span class="hljs-number">10</span>) <span class="hljs-comment">#读取前10个字节</span><br></code></pre></td></tr></table></figure><p>一般地，我们应该使用以下的模式来把读取的字节流保存到文件中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fd:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        chunk = <span class="hljs-keyword">await</span> resp.content.read(chunk_size)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> chunk:<br>            <span class="hljs-keyword">break</span><br>        fd.write(chunk)<br></code></pre></td></tr></table></figure><h3 id="7-自定义请求头"><a href="#7-自定义请求头" class="headerlink" title="7.自定义请求头"></a><strong>7.自定义请求头</strong></h3><p>如果你想添加请求头，可以像get添加参数那样以dict的形式，作为get或者post的参数进行请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>url = <span class="hljs-string">&#x27;https://api.github.com/some/endpoint&#x27;</span><br>payload = &#123;<span class="hljs-string">&#x27;some&#x27;</span>: <span class="hljs-string">&#x27;data&#x27;</span>&#125;<br>headers = &#123;<span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;<br><span class="hljs-keyword">await</span> session.post(url, data=json.dumps(payload), headers=headers)<br></code></pre></td></tr></table></figure><h3 id="8-自定义Cookie"><a href="#8-自定义Cookie" class="headerlink" title="8.自定义Cookie"></a>8.自定义Cookie</h3><p>给服务器发送cookie，可以通过给 ClientSession 传递一个cookie参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://httpbin.org/cookies&#x27;</span><br>cookies = &#123;<span class="hljs-string">&#x27;cookies_are&#x27;</span>: <span class="hljs-string">&#x27;working&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> ClientSession(cookies=cookies) <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> resp:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">await</span> resp.json() == &#123;<span class="hljs-string">&quot;cookies&quot;</span>: &#123;<span class="hljs-string">&quot;cookies_are&quot;</span>: <span class="hljs-string">&quot;working&quot;</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p>可直接访问链接 “httpbin.org&#x2F;cookies”查看当前cookie，访问session中的cookie请见第10节。</p><h3 id="9-post数据的几种方式"><a href="#9-post数据的几种方式" class="headerlink" title="9.post数据的几种方式"></a><strong>9.post数据的几种方式</strong></h3><h4 id="（1）模拟表单post数据"><a href="#（1）模拟表单post数据" class="headerlink" title="（1）模拟表单post数据"></a>（1）模拟表单post数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=payload) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure><p>注意：data&#x3D;dict的方式post的数据将被转码，和form提交数据是一样的作用，如果你不想被转码，可以直接以字符串的形式 <strong>data&#x3D;str</strong> 提交，这样就不会被转码。</p><h4 id="（2）post-json"><a href="#（2）post-json" class="headerlink" title="（2）post json"></a>（2）post json</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>url = <span class="hljs-string">&#x27;https://api.github.com/some/endpoint&#x27;</span><br>payload = &#123;<span class="hljs-string">&#x27;some&#x27;</span>: <span class="hljs-string">&#x27;data&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(url, data=json.dumps(payload)) <span class="hljs-keyword">as</span> resp:<br>    ...<br></code></pre></td></tr></table></figure><p>其实json.dumps(payload)返回的也是一个字符串，只不过这个字符串可以被识别为json格式</p><h4 id="（3）post-小文件"><a href="#（3）post-小文件" class="headerlink" title="（3）post 小文件"></a>（3）post 小文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span><br>files = &#123;<span class="hljs-string">&#x27;file&#x27;</span>: <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;report.xls&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)&#125;<br><span class="hljs-keyword">await</span> session.post(url, data=files)<br></code></pre></td></tr></table></figure><p>可以设置好文件名和content-type:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span><br>data = FormData()<br>data.add_field(<span class="hljs-string">&#x27;file&#x27;</span>, <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;report.xls&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>), filename=<span class="hljs-string">&#x27;report.xls&#x27;</span>,<br>                content_type=<span class="hljs-string">&#x27;application/vnd.ms-excel&#x27;</span>)<br><span class="hljs-keyword">await</span> session.post(url, data=data)<br></code></pre></td></tr></table></figure><p>如果将文件对象设置为数据参数，aiohttp将自动以字节流的形式发送给服务器。</p><h4 id="（4）post-大文件"><a href="#（4）post-大文件" class="headerlink" title="（4）post 大文件"></a>（4）post 大文件</h4><p>aiohttp支持多种类型的文件以流媒体的形式上传，所以我们可以在文件未读入内存的情况下发送大文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@aiohttp.streamer</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">file_sender</span>(<span class="hljs-params">writer, file_name=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        chunk = f.read(<span class="hljs-number">2</span>**<span class="hljs-number">16</span>)<br>        <span class="hljs-keyword">while</span> chunk:<br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> writer.write(chunk)<br>            chunk = f.read(<span class="hljs-number">2</span>**<span class="hljs-number">16</span>)<br><span class="hljs-comment"># Then you can use `file_sender` as a data provider:</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=file_sender(file_name=<span class="hljs-string">&#x27;huge_file&#x27;</span>)) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure><p>同时我们可以从一个url获取文件后，直接post给另一个url，并计算hash值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">feed_stream</span>(<span class="hljs-params">resp, stream</span>):<br>    h = hashlib.sha256()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        chunk = <span class="hljs-keyword">await</span> resp.content.readany()<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> chunk:<br>            <span class="hljs-keyword">break</span><br>        h.update(chunk)<br>        stream.feed_data(chunk)<br>    <span class="hljs-keyword">return</span> h.hexdigest()<br>resp = session.get(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>)<br>stream = StreamReader()<br>loop.create_task(session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=stream))<br>file_hash = <span class="hljs-keyword">await</span> feed_stream(resp, stream)<br></code></pre></td></tr></table></figure><p>因为响应内容类型是StreamReader，所以可以把get和post连接起来，同时进行post和get：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">r = <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;http://python.org&#x27;</span>)<br><br><span class="hljs-keyword">await</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=r.content)<br></code></pre></td></tr></table></figure><h4 id="（5）post预压缩数据"><a href="#（5）post预压缩数据" class="headerlink" title="（5）post预压缩数据"></a>（5）post预压缩数据</h4><p>在通过aiohttp发送前就已经压缩的数据, 调用压缩函数的函数名（通常是deflate 或 zlib）作为content-encoding的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_coroutine</span>(<span class="hljs-params">session, headers, my_data</span>):<br>    data = zlib.compress(my_data)<br>    headers = &#123;<span class="hljs-string">&#x27;Content-Encoding&#x27;</span>: <span class="hljs-string">&#x27;deflate&#x27;</span>&#125;<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=data, headers=headers)<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>10.keep-alive, 连接池，共享cookie</p><p>ClientSession 用于在多个连接之间共享cookie：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/cookies/set?my_cookie=my_value&#x27;</span>)<br>    filtered = session.cookie_jar.filter_cookies(<span class="hljs-string">&#x27;http://httpbin.org&#x27;</span>)<br>    <span class="hljs-keyword">assert</span> filtered[<span class="hljs-string">&#x27;my_cookie&#x27;</span>].value == <span class="hljs-string">&#x27;my_value&#x27;</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/cookies&#x27;</span>) <span class="hljs-keyword">as</span> r:<br>        json_body = <span class="hljs-keyword">await</span> r.json()<br>        <span class="hljs-keyword">assert</span> json_body[<span class="hljs-string">&#x27;cookies&#x27;</span>][<span class="hljs-string">&#x27;my_cookie&#x27;</span>] == <span class="hljs-string">&#x27;my_value&#x27;</span><br></code></pre></td></tr></table></figure><p>也可以为所有的连接设置共同的请求头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession(<br>    headers=&#123;<span class="hljs-string">&quot;Authorization&quot;</span>: <span class="hljs-string">&quot;Basic bG9naW46cGFzcw==&quot;</span>&#125;) <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&quot;http://httpbin.org/headers&quot;</span>) <span class="hljs-keyword">as</span> r:<br>        json_body = <span class="hljs-keyword">await</span> r.json()<br>        <span class="hljs-keyword">assert</span> json_body[<span class="hljs-string">&#x27;headers&#x27;</span>][<span class="hljs-string">&#x27;Authorization&#x27;</span>] == <span class="hljs-string">&#x27;Basic bG9naW46cGFzcw==&#x27;</span><br></code></pre></td></tr></table></figure><p>ClientSession 还支持 keep-alive连接和连接池(connection pooling)</p><h3 id="11-cookie安全性"><a href="#11-cookie安全性" class="headerlink" title="11.cookie安全性"></a><strong>11.cookie安全性</strong></h3><p>默认ClientSession使用的是严格模式的 aiohttp.CookieJar. RFC 2109，明确的禁止接受url和ip地址产生的cookie，只能接受 DNS 解析IP产生的cookie。可以通过设置aiohttp.CookieJar 的 unsafe&#x3D;True 来配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">jar = aiohttp.CookieJar(unsafe=<span class="hljs-literal">True</span>)<br>session = aiohttp.ClientSession(cookie_jar=jar)<br></code></pre></td></tr></table></figure><h3 id="12-控制同时连接的数量（连接池）"><a href="#12-控制同时连接的数量（连接池）" class="headerlink" title="12.控制同时连接的数量（连接池）"></a>12.控制同时连接的数量（连接池）</h3><p>也可以理解为同时请求的数量，为了限制同时打开的连接数量，我们可以将限制参数传递给连接器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conn = aiohttp.TCPConnector(limit=<span class="hljs-number">30</span>) <span class="hljs-comment"># 同时最大进行连接的连接数为30，默认是100，limit=0的时候是无限制</span><br></code></pre></td></tr></table></figure><p>限制同时打开限制同时打开连接到同一端点的数量（(host, port, is_ssl) 三的倍数），可以通过设置 limit_per_host 参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conn = aiohttp.TCPConnector(limit_per_host=<span class="hljs-number">30</span>) <span class="hljs-comment"># 默认是0</span><br></code></pre></td></tr></table></figure><h3 id="13-自定义域名解析"><a href="#13-自定义域名解析" class="headerlink" title="13.自定义域名解析"></a>13.自定义域名解析</h3><p>我们可以指定域名服务器的 IP 对我们提供的get或post的url进行解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> aiohttp.resolver <span class="hljs-keyword">import</span> AsyncResolver<br>resolver = AsyncResolver(nameservers=[<span class="hljs-string">&quot;8.8.8.8&quot;</span>, <span class="hljs-string">&quot;8.8.4.4&quot;</span>])<br>conn = aiohttp.TCPConnector(resolver=resolver)<br></code></pre></td></tr></table></figure><h3 id="14-设置代理"><a href="#14-设置代理" class="headerlink" title="14.设置代理"></a><strong>14.设置代理</strong></h3><p>aiohttp支持使用代理来访问网页：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&quot;http://python.org&quot;</span>, proxy=<span class="hljs-string">&quot;http://some.proxy.com&quot;</span>) <span class="hljs-keyword">as</span> resp:<br>        <span class="hljs-built_in">print</span>(resp.status)<br></code></pre></td></tr></table></figure><p>当然也支持需要授权的页面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    proxy_auth = aiohttp.BasicAuth(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;pass&#x27;</span>)<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&quot;http://python.org&quot;</span>, proxy=<span class="hljs-string">&quot;http://some.proxy.com&quot;</span>, proxy_auth=proxy_auth) <span class="hljs-keyword">as</span> resp:<br>        <span class="hljs-built_in">print</span>(resp.status)<br></code></pre></td></tr></table></figure><p>或者通过这种方式来验证授权：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">session.get(<span class="hljs-string">&quot;http://python.org&quot;</span>, proxy=<span class="hljs-string">&quot;http://user:pass@some.proxy.com&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="15-响应状态码-response-status-code"><a href="#15-响应状态码-response-status-code" class="headerlink" title="15.响应状态码 response status code"></a>15.响应状态码 response status code</h3><p>可以通过 resp.status来检查状态码是不是200：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-keyword">assert</span> resp.status == <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h3 id="16-响应头"><a href="#16-响应头" class="headerlink" title="16.响应头"></a>16.响应头</h3><p>我们可以直接使用　resp.headers 来查看响应头，得到的值类型是一个dict：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>resp.headers<br>&#123;<span class="hljs-string">&#x27;ACCESS-CONTROL-ALLOW-ORIGIN&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br> <span class="hljs-string">&#x27;CONTENT-TYPE&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br> <span class="hljs-string">&#x27;DATE&#x27;</span>: <span class="hljs-string">&#x27;Tue, 15 Jul 2014 16:49:51 GMT&#x27;</span>,<br> <span class="hljs-string">&#x27;SERVER&#x27;</span>: <span class="hljs-string">&#x27;gunicorn/18.0&#x27;</span>,<br> <span class="hljs-string">&#x27;CONTENT-LENGTH&#x27;</span>: <span class="hljs-string">&#x27;331&#x27;</span>,<br> <span class="hljs-string">&#x27;CONNECTION&#x27;</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>或者我们可以查看原生的响应头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>resp.raw_headers<br>((<span class="hljs-string">b&#x27;SERVER&#x27;</span>, <span class="hljs-string">b&#x27;nginx&#x27;</span>),<br> (<span class="hljs-string">b&#x27;DATE&#x27;</span>, <span class="hljs-string">b&#x27;Sat, 09 Jan 2016 20:28:40 GMT&#x27;</span>),<br> (<span class="hljs-string">b&#x27;CONTENT-TYPE&#x27;</span>, <span class="hljs-string">b&#x27;text/html; charset=utf-8&#x27;</span>),<br> (<span class="hljs-string">b&#x27;CONTENT-LENGTH&#x27;</span>, <span class="hljs-string">b&#x27;12150&#x27;</span>),<br> (<span class="hljs-string">b&#x27;CONNECTION&#x27;</span>, <span class="hljs-string">b&#x27;keep-alive&#x27;</span>))<br></code></pre></td></tr></table></figure><h3 id="17-查看cookie"><a href="#17-查看cookie" class="headerlink" title="17.查看cookie"></a>17.查看cookie</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://example.com/some/cookie/setting/url&#x27;</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(resp.cookies)<br></code></pre></td></tr></table></figure><h3 id="18-重定向的响应头"><a href="#18-重定向的响应头" class="headerlink" title="18.重定向的响应头"></a><strong>18.重定向的响应头</strong></h3><p>如果一个请求被重定向了，我们依然可以查看被重定向之前的响应头信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>resp = <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;http://example.com/some/redirect/&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>resp<br>&lt;ClientResponse(http://example.com/some/other/url/) [<span class="hljs-number">200</span>]&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>resp.history<br>(&lt;ClientResponse(http://example.com/some/redirect/) [<span class="hljs-number">301</span>]&gt;,)<br></code></pre></td></tr></table></figure><h3 id="19-超时处理"><a href="#19-超时处理" class="headerlink" title="19.超时处理"></a>19.超时处理</h3><p>默认的IO操作都有<strong>5分钟的响应时间</strong> 我们可以通过 timeout 进行重写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://github.com&#x27;</span>, timeout=<span class="hljs-number">60</span>) <span class="hljs-keyword">as</span> r:<br>    ...<br></code></pre></td></tr></table></figure><p>如果 timeout&#x3D;None 或者 timeout&#x3D;0 将不进行超时检查，也就是不限时长</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aiohttp</tag>
      
      <tag>标准库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda 安装</title>
    <link href="/2019/07/31/Anaconda/"/>
    <url>/2019/07/31/Anaconda/</url>
    
    <content type="html"><![CDATA[<h3 id="Anaconda-安装"><a href="#Anaconda-安装" class="headerlink" title="Anaconda 安装"></a>Anaconda 安装</h3><ul><li>下载安装包: 官网, 清华源等</li><li>推荐下载python3 (Anaconda3) 版本</li><li>按照安装程序提示一步步安装就好了, 安装完成之后会多几个应用<ul><li><p><strong>Anaconda Navigtor</strong> ：用于管理工具包和环境的图形用户界面，后续涉及的众多管理命令也可以在 Navigator 中手工实现。</p></li><li><p><strong>Jupyter notebook</strong> ：基于web的交互式计算环境，可以编辑易于人们阅读的文档，用于展示数据分析的过程。</p></li><li><p><strong>qtconsole</strong> ：一个可执行 IPython 的仿终端图形界面程序，相比 Python Shell 界面，qtconsole 可以直接显示代码生成的图形，实现多行代码输入执行，以及内置许多有用的功能和函数。</p></li><li><p><strong>spyder</strong> ：(可选) 一个使用Python语言、跨平台的、科学运算集成开发环境。</p></li></ul></li></ul><h3 id="更改conda默认的下载源"><a href="#更改conda默认的下载源" class="headerlink" title="更改conda默认的下载源"></a>更改conda默认的下载源</h3><ul><li>更改为清华源 <figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/<br>conda config --<span class="hljs-built_in">set</span> show_channel_urls <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><h5 id="Conda-三方源"><a href="#Conda-三方源" class="headerlink" title="Conda 三方源"></a>Conda 三方源</h5></li><li>Conda Forge<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/<br></code></pre></td></tr></table></figure></li><li>msys2<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/<br></code></pre></td></tr></table></figure></li><li>bioconda<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/<br></code></pre></td></tr></table></figure></li><li>menpo<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/<br></code></pre></td></tr></table></figure></li><li>pytorch <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/<br><br><span class="hljs-comment"># for legacy win-64</span><br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/peterjc123/<br></code></pre></td></tr></table></figure></li></ul><h3 id="管理虚拟环境"><a href="#管理虚拟环境" class="headerlink" title="管理虚拟环境"></a>管理虚拟环境</h3><p>   接下来我们就可以用anaconda来创建我们一个个独立的python环境了.接下来的例子都是在命令行操作的,请打开你的命令行吧.</p><ul><li><p><strong>activate</strong></p><ul><li>activate 能将我们引入anaconda设定的虚拟环境中, 如果你后面什么参数都不加那么会进入anaconda自带的base环境</li><li>你可以输入python试试, 这样会进入base环境的python解释器, 如果你把原来环境中的python环境去除掉会更能体会到, 这个时候在命令行中使用的已经不是你原来的python而是base环境下的python.而命令行前面也会多一个(base) 说明当前我们处于的是base环境下.</li></ul></li><li><p><strong>创建自己的虚拟环境</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda create -n virtual_name python=3<br></code></pre></td></tr></table></figure></li><li><p><strong>查看所有的虚拟环境</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> list<br></code></pre></td></tr></table></figure></li><li><p><strong>激活虚拟环境</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda activate virtual_name<br></code></pre></td></tr></table></figure></li><li><p><strong>切回默认环境 &#x2F; 反激活虚拟环境</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda deactivate<br></code></pre></td></tr></table></figure></li><li><p><strong>查看当前环境模块&#x2F;包</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda list<br></code></pre></td></tr></table></figure></li><li><p><strong>安装一个模块&#x2F;包</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda instal numpy<br></code></pre></td></tr></table></figure></li><li><p><strong>卸载一个模块&#x2F;包</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda remove numpy<br></code></pre></td></tr></table></figure></li><li><p><strong>更新一个模块&#x2F;包</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda update numpy<br></code></pre></td></tr></table></figure></li><li><p><strong>删除一个环境及其下所有包</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda remove -n virtual_name --all<br></code></pre></td></tr></table></figure></li><li><p><strong>导出当前环境的包信息</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> <span class="hljs-built_in">export</span> &gt; environment.yaml<br></code></pre></td></tr></table></figure></li><li><p><strong>用配置文件创建新的虚拟环境</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> create -f environment.yaml<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
      <category>Anaconda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Anaconda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac 安装 ruby</title>
    <link href="/2019/06/25/Mac%20osx%20%E5%AE%89%E8%A3%85%20ruby/"/>
    <url>/2019/06/25/Mac%20osx%20%E5%AE%89%E8%A3%85%20ruby/</url>
    
    <content type="html"><![CDATA[<h3 id="安装CocoaPods第一步"><a href="#安装CocoaPods第一步" class="headerlink" title="安装CocoaPods第一步"></a>安装CocoaPods第一步</h3><p><strong>起因:重装系统后需要重新安装CocoaPods网上搜了下发现很多都过时了，已经不能用了。而且taobao Gems源已经停止服务，现在有ruby-china提供服务PS：”$”开头表示需要在终端下执行</strong></p><h3 id="1-安装RVM"><a href="#1-安装RVM" class="headerlink" title="1.安装RVM"></a>1.安装RVM</h3><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">curl -L https://get.rvm.io | bash -s stable</span><br></code></pre></td></tr></table></figure><p><strong>期间可能需要输入密码(我安装时没有提示，密码就是开机密码输入时密码不会显示直接输入完成就可以)，等待一段时间将安装好(大概五六分钟)。</strong><br><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081128066.png" alt="安装RVM"></p><h3 id="2-载入RVM环境"><a href="#2-载入RVM环境" class="headerlink" title="2.载入RVM环境"></a>2.载入RVM环境</h3><p><strong>若打开新终端窗口则不用执行</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ <span class="hljs-keyword">source</span> ~<span class="hljs-regexp">/.rvm/</span>scripts/rvm<br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081128763.png" alt="载入RVM环境"></p><h3 id="3-检查RVM是否安装好"><a href="#3-检查RVM是否安装好" class="headerlink" title="3.检查RVM是否安装好"></a>3.检查RVM是否安装好</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm -v</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081128518.png" alt="img"></p><h3 id="4-安装Ruby"><a href="#4-安装Ruby" class="headerlink" title="4.安装Ruby"></a>4.安装Ruby</h3><p>##### 1&gt;列出已知的ruby版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm list known</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081128428.png" alt="列出已知的ruby版本"></p><h5 id="2-gt-选择2-0-0版本进行安装-其他版本也可以"><a href="#2-gt-选择2-0-0版本进行安装-其他版本也可以" class="headerlink" title="2&gt;选择2.0.0版本进行安装(其他版本也可以)"></a>2&gt;选择2.0.0版本进行安装(其他版本也可以)</h5><p><strong>等待下载(途中需要按回车确定安装路径、还要输入密码)、编译。完成之后Ruby、Ruby Gems就安装好了</strong><br><code>$ rvm install 2.6</code><br><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081128625.png" alt="选择2.0.0版本进行安装"></p><h5 id="3-gt-查询已安装的ruby"><a href="#3-gt-查询已安装的ruby" class="headerlink" title="3&gt;查询已安装的ruby"></a>3&gt;查询已安装的ruby</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm list</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129344.png" alt="查询已安装的ruby"></p><h5 id="4-gt-卸载已安装的版本-若已经安装过ruby）"><a href="#4-gt-卸载已安装的版本-若已经安装过ruby）" class="headerlink" title="4&gt;卸载已安装的版本(若已经安装过ruby）"></a>4&gt;卸载已安装的版本(若已经安装过ruby）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm remove [版本号]</span><br></code></pre></td></tr></table></figure><h3 id="4-设置Ruby版本"><a href="#4-设置Ruby版本" class="headerlink" title="4.设置Ruby版本"></a>4.设置Ruby版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm 2.6 —default</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129237.png" alt="设置Ruby版本"><br><strong>检查是否安装好了</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm -v</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129101.png" alt="检查"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">gem -v</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129235.png" alt="检查"></p><h3 id="5-更换Ruby源"><a href="#5-更换Ruby源" class="headerlink" title="5.更换Ruby源"></a>5.更换Ruby源</h3><p><strong>我们需要来修改更换Ruby源，国内镜像源 taobao 源 已经停止维护了（由于国内被墙）所以要把源切换至ruby-china</strong></p><h5 id="1-gt-检测Ruby源"><a href="#1-gt-检测Ruby源" class="headerlink" title="1&gt;检测Ruby源"></a>1&gt;检测Ruby源</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">gem sources -l</span><br></code></pre></td></tr></table></figure><p><strong>检查结果：（ 如果电脑没安装过 CocoaPods，此时应该是默认 ruby 源 ）</strong><br><code>huanghaipoMacBook-Pro:~ jijiucheng$ gem sources -l *** CURRENT SOURCES *** https://rubygems.org/</code></p><h4 id="2-gt-移除-ruby-源"><a href="#2-gt-移除-ruby-源" class="headerlink" title="2&gt;移除 ruby 源"></a>2&gt;移除 ruby 源</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">gem sources --remove https://rubygems.org/</span><br></code></pre></td></tr></table></figure><h4 id="3-gt-移除结果："><a href="#3-gt-移除结果：" class="headerlink" title="3&gt;移除结果："></a>3&gt;移除结果：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">huanghaipoMacBook-Pro:local jijiucheng$ gem sources --remove https://rubygems.org/<br>https://rubygems.org/ removed from sources<br></code></pre></td></tr></table></figure><p><strong>替换添加国内镜像源 ruby-china 源，因为上面已经提到国内镜像源 taobao 源 已经停止维护了，所以此处替换的是 ruby-china 源，且尽量确保只有一个 ruby-china 源</strong><br><code>$ gem sources --add https://gems.ruby-china.org</code></p><h4 id="4-gt-替换结果："><a href="#4-gt-替换结果：" class="headerlink" title="4&gt;替换结果："></a>4&gt;替换结果：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">huanghaipoMacBook-Pro:local jijiucheng$ gem sources --add https://gems.ruby-china.com<br>https://gems.ruby-china.org added to sources<br></code></pre></td></tr></table></figure><h4 id="5-gt-再次检查此时的-ruby-源：（-已经变成了-ruby-china-源-）"><a href="#5-gt-再次检查此时的-ruby-源：（-已经变成了-ruby-china-源-）" class="headerlink" title="5&gt;再次检查此时的 ruby 源：（ 已经变成了 ruby-china 源 ）"></a>5&gt;再次检查此时的 ruby 源：（ 已经变成了 ruby-china 源 ）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">huanghaipoMacBook-Pro:local jijiucheng$ gem sources -l<br>*** CURRENT SOURCES ***<br>https://gems.ruby-china.com<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>ruby</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ruby</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web 指纹识别杂论</title>
    <link href="/2019/06/24/web%20%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E6%9D%82%E8%AE%BA/"/>
    <url>/2019/06/24/web%20%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E6%9D%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>##前言</p><p>在 web 渗透过程中，对目标网站的指纹识别非常关键，通过工具或者手工识别 CMS系统是自建的还是二次开发，还是直接使用公开的CMS 程序至关重要。通过获取的这些信息来决定后续渗透的思路和策略。CMS 指纹识别是渗透测试环节的一个非常重要的阶段，是信息收集的中的一个关键环节。</p><h2 id="1-指纹识别技术简介及思路"><a href="#1-指纹识别技术简介及思路" class="headerlink" title="1. 指纹识别技术简介及思路"></a>1. 指纹识别技术简介及思路</h2><h3 id="1-1-指纹识别技术"><a href="#1-1-指纹识别技术" class="headerlink" title="1.1 指纹识别技术"></a>1.1 指纹识别技术</h3><p>组件是网络空间最小的单元，Web应用程序、数据库、中间件等都属于组件。指纹是组件上能标识对象类型的一段特征信息，用来在渗透测试信息收集环节中快熟识别目标服务。互联网随时代的发展逐渐成熟，大批应用组件存在足以说明当前服务名称和版本的特征，识别这些特征获取当前服务信息，也表明该系统采用那个公司的产品，例如论坛常用 Discuz!来搭建，通过其 robots.txt 等可以识别网站程序是采用 Discuz！</p><h3 id="1-2-指纹识别思路"><a href="#1-2-指纹识别思路" class="headerlink" title="1.2 指纹识别思路"></a>1.2 指纹识别思路</h3><p>指纹识别可以铜鼓哦一些开源程序和小工具来进行扫描，也有可以结合文件头和反馈信息进行手工判断，指纹识别主要思路：</p><p>（1）使用工具自动判断</p><p>（2）手工对网站的关键字、版权信息、后台登录、程序版本、robots.txt 等常见固有文件进行识别、查找和比对，相同文件具有相同的 MD5 值和相同的属性。</p><h2 id="2-指纹识别方式"><a href="#2-指纹识别方式" class="headerlink" title="2.  指纹识别方式"></a>2.  指纹识别方式</h2><p>基于对指纹识别方式的各种套路和分析，可以分为以下几个类别：</p><h3 id="2-1-基于特殊文件的-MD5-值匹配"><a href="#2-1-基于特殊文件的-MD5-值匹配" class="headerlink" title="2.1 基于特殊文件的 MD5 值匹配"></a>2.1 基于特殊文件的 MD5 值匹配</h3><p>基于web网站独有的favicon.ico、css、logo.ico、js等文件的md5 比对网站类型，通过收集CMS公开代码中的独有文件，这些文件一般轻易不会更改，通过爬虫对这些文件进行抓取并比对md5值，如果一样，则认为该系统匹配。这种识别速度最快，但可能不准确，因为这些独有文件可能在部署到真实系统中会进行更改，那么就会造成很大的误差。</p><p>（1）robots.txt文件识别</p><p>相关厂商下的cms（内容管理系统）程序文件包含说明当前cms名称及版本的特征码，其中一些独有的文件夹以及名称都是识别cms的好方法，如Discuz官网下robots.txt文件。dedecms官网<a href="http://www.dedecms.com/robots.txt%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%EF%BC%9A">http://www.dedecms.com/robots.txt文件内容：</a></p><p>Disallow: &#x2F;plus&#x2F;feedback_js.php</p><p>Disallow: &#x2F;plus&#x2F;mytag_js.php</p><p>Disallow: &#x2F;plus&#x2F;rss.php</p><p>Disallow: &#x2F;plus&#x2F;search.php</p><p>Disallow: &#x2F;plus&#x2F;recommend.php</p><p>Disallow: &#x2F;plus&#x2F;stow.php</p><p>Disallow: &#x2F;plus&#x2F;count.php</p><p>看到这个基本可以判断为dedecms。</p><p>2）计算机md5值</p><p>计算网站所使中间件或cms目录下静态文件的md5值，md5码可以唯一地代表原信息的特征。静态文件包括html、js、css、image等，建立在站点静态文件存在的情况下访问，如 Dedecms 官网下网站根目录<a href="http://www.dedecms.com/img/buttom_logo.gif%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%9C%89%E4%B8%80%E4%BA%9B%E5%85%AC%E5%BC%80%E7%A8%8B%E5%BA%8F%EF%BC%8C%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AEcms.txt%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%BA%94%E5%80%BC%E8%BF%9B%E8%A1%8C%E8%AF%86%E5%88%AB%EF%BC%8C%E5%A6%82%E5%9B%BE1%E6%89%80%E7%A4%BA%E3%80%82">http://www.dedecms.com/img/buttom_logo.gif图片文件，目前有一些公开程序，通过配置cms.txt文件中的相应值进行识别，如图1所示。</a></p><h3 id="2-2-请求相应主体内容或头信息的关键字匹配"><a href="#2-2-请求相应主体内容或头信息的关键字匹配" class="headerlink" title="2.2 请求相应主体内容或头信息的关键字匹配"></a>2.2 请求相应主体内容或头信息的关键字匹配</h3><p>请求响应主体内容或头信息的关键字匹配方法可以寻找网站的css 、js代码的命名规则，也可以找关键字，以及head cookie等等，但是弊端是收集这些规则会耗费很久的时间。</p><h3 id="2-3-基于-URL-关键字识别"><a href="#2-3-基于-URL-关键字识别" class="headerlink" title="2.3 基于 URL 关键字识别"></a>2.3 基于 URL 关键字识别</h3><p>基于爬虫爬出来的网站目录比对web信息，准确性比较高，但是如果改了目录结构就会造成问题，而且一部分网站有反爬虫机制，会造成一些困扰</p><h3 id="2-4-基于-TCP-x2F-IP-请求协议识别服务指纹"><a href="#2-4-基于-TCP-x2F-IP-请求协议识别服务指纹" class="headerlink" title="2.4 基于 TCP&#x2F;IP 请求协议识别服务指纹"></a>2.4 基于 TCP&#x2F;IP 请求协议识别服务指纹</h3><p> 一些应用程序、组建和数据库服务会有一些特殊的指纹，一般情况下不会进行更改。网络上的通信交互均通过TCP&#x2F;TP协议簇进行，操作系统也必须实现该协议。操作系统根据不同数据包做出不同反应。如Nmap检测操作系统工具通过向目标主机发送协议数据包并分析其响应信息进行操作系统指纹识别工作，其扫描命令为“nmap –O 192.168.1.1”。</p><h3 id="2-5-在owasp中识别Web应用框架测试方法"><a href="#2-5-在owasp中识别Web应用框架测试方法" class="headerlink" title="2.5 在owasp中识别Web应用框架测试方法"></a>2.5 在owasp中识别Web应用框架测试方法</h3><p>（1）http头。查看http响应报头的X-Powered-By字段来识别，可以通过netcat来识别，使用netcat 127.0.0.1 80对127.0.0.1主机的80端口web服务器框架进行识别。</p><p>（2）Cookies。一些框架有固定的Cookies名称，这些名称一般情况都不会更改，例如zope3、cakephp、kohanasesson、laravel_session。</p><p>（3）Html源代码。html源代码中包含注释、js、css等信息，通过访问这些信息来判断和确认cms系统框架。在源代码中常常会包含powered by、bulit upon、running等特征。</p><p>（4）特殊文件和文件夹</p>]]></content>
    
    
    <categories>
      
      <category>安全研究</category>
      
      <category>指纹识别</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指纹识别</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

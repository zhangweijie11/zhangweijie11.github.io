<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用 Ettercap嗅探工具进行 DNS 欺骗实验</title>
    <link href="/2022/03/01/%E4%BD%BF%E7%94%A8%20Ettercap%E5%97%85%E6%8E%A2%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%20DNS%20%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C/"/>
    <url>/2022/03/01/%E4%BD%BF%E7%94%A8%20Ettercap%E5%97%85%E6%8E%A2%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%20DNS%20%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="使用-Ettercap嗅探工具进行-DNS-欺骗实验"><a href="#使用-Ettercap嗅探工具进行-DNS-欺骗实验" class="headerlink" title="使用 Ettercap嗅探工具进行 DNS 欺骗实验"></a>使用 Ettercap嗅探工具进行 DNS 欺骗实验</h1><blockquote><p>前提条件：需要安装<code>kali 虚拟机</code>，或者自己安装<code>ettercap 工具</code></p><p>涉及服务器：本地服务器（172.30.0.56）、kali 虚拟机（172.30.0.133）、网关（172.30.0.1，172.30.0.254）</p></blockquote><h2 id="一、实验名称"><a href="#一、实验名称" class="headerlink" title="一、实验名称"></a>一、实验名称</h2><p><strong>DNS欺骗</strong></p><h2 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a>二、实验原理</h2><p>冒充域名服务器，将查询的 IP 地址设置为攻击者的 IP 地址，这样用户上网就只能看到攻击者主主页，而不是用户访问的真实的页面。</p><p><strong>正常情况</strong></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281509294.png" alt="image-20220228141758055"></p><p><strong>异常情况</strong></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281509975.png" alt="image-20220228141830850"></p><h2 id="三、实验步骤"><a href="#三、实验步骤" class="headerlink" title="三、实验步骤"></a>三、实验步骤</h2><h3 id="1、清除攻击机和靶机的-DNS-缓存数据"><a href="#1、清除攻击机和靶机的-DNS-缓存数据" class="headerlink" title="1、清除攻击机和靶机的 DNS 缓存数据"></a>1、清除攻击机和靶机的 DNS 缓存数据</h3><ul><li><p>MAC系统</p><figure class="highlight ebnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo killall -HUP mDNSResponder</span><br><span class="hljs-attribute">sudo dscacheutil -flushcache</span><br></code></pre></td></tr></table></figure></li><li><p>Windows 系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看 DNS 缓存内容</span><br>ipconfig/displaydns<br><span class="hljs-comment"># 清除 DNS 缓存内容</span><br>ifconfig /flushdns<br></code></pre></td></tr></table></figure></li><li><p>Linux 系统</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># Step 1. 查看 DNS 缓存状况</span><br>sudo systemd-<span class="hljs-built_in">resolve</span> <span class="hljs-comment">--statistics</span><br><br><span class="hljs-comment"># Step 2. 清除 DNS 缓存，systemd-resolve daemon 默认在所有的 Ubuntu 系统上运行</span><br>sudo systemd-<span class="hljs-built_in">resolve</span> <span class="hljs-comment">--flush-caches</span><br><br><span class="hljs-comment"># Step 3. 正在查看验证结果（SYSIN）</span><br>sudo systemd-<span class="hljs-built_in">resolve</span> <span class="hljs-comment">--statistics</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2、修改相关-DNS-文件（攻击机）"><a href="#2、修改相关-DNS-文件（攻击机）" class="headerlink" title="2、修改相关 DNS 文件（攻击机）"></a>2、修改相关 DNS 文件（攻击机）</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 输入命令</span><br><span class="hljs-attribute">vim</span> /etc/ettercap/etter.dns<br><span class="hljs-comment"># 添加内容</span><br>*  A   <span class="hljs-number">172.30.0.133</span><br>*  PTR <span class="hljs-number">172.30.0.133</span><br></code></pre></td></tr></table></figure><h3 id="3、开启自带的-Apache-服务"><a href="#3、开启自带的-Apache-服务" class="headerlink" title="3、开启自带的 Apache 服务"></a>3、开启自带的 Apache 服务</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 开启服务</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">service </span>apache2 start<br><br><span class="hljs-comment"># 查询状态</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">service </span>apache2 status<br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281455623.png" alt="image-20220228145536734"></p><h3 id="4、开启-ettercap-图形界面"><a href="#4、开启-ettercap-图形界面" class="headerlink" title="4、开启 ettercap 图形界面"></a>4、开启 ettercap 图形界面</h3><ul><li><p>方式一</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ettercap -G</span><br></code></pre></td></tr></table></figure></li><li><p>方式二</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281432316.png" alt="image-20220228143217106"></p></li></ul><h3 id="5、选择网卡"><a href="#5、选择网卡" class="headerlink" title="5、选择网卡"></a>5、选择网卡</h3><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281433117.png" alt="image-20220228143315708"></p><h3 id="6、扫描网关下的所有存活主机"><a href="#6、扫描网关下的所有存活主机" class="headerlink" title="6、扫描网关下的所有存活主机"></a>6、扫描网关下的所有存活主机</h3><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281435479.png" alt="image-20220228143537655"></p><p><strong>扫描结果</strong></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281436063.png" alt="image-20220228143633113"></p><h3 id="7、选择攻击目标"><a href="#7、选择攻击目标" class="headerlink" title="7、选择攻击目标"></a>7、选择攻击目标</h3><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281438910.png" alt="image-20220228143810935"></p><h3 id="8、开启-ARP-投毒"><a href="#8、开启-ARP-投毒" class="headerlink" title="8、开启 ARP 投毒"></a>8、开启 ARP 投毒</h3><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281439827.png" alt="image-20220228143935749"></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281440789.png" alt="image-20220228143959644"></p><h3 id="9、使用插件开启-DNS-欺骗"><a href="#9、使用插件开启-DNS-欺骗" class="headerlink" title="9、使用插件开启 DNS 欺骗"></a>9、使用插件开启 DNS 欺骗</h3><p>Plugins –&gt; manage plugins –&gt; dns spoof</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281440797.png" alt="image-20220228144057221"></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281442111.png" alt="image-20220228144218575"></p><h3 id="10、验证结果"><a href="#10、验证结果" class="headerlink" title="10、验证结果"></a>10、验证结果</h3><p><strong>当发生 DNS 欺骗后，靶机请求的数据都会在 ettercap 工具中展示出来！</strong></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281451243.png" alt="image-20220228145135214"></p><p><strong>此时靶机再去请求数据时，页面就会显示我们预想的 Apache 的默认页面！</strong></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281456734.png" alt="image-20220228145652393"></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281457571.png" alt="image-20220228145726419"></p>]]></content>
    
    
    <categories>
      
      <category>安全研究</category>
      
      <category>域名知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS 欺骗</tag>
      
      <tag>安全工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 常见错误及解决办法</title>
    <link href="/2022/01/19/Git%20%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2022/01/19/Git%20%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-常见错误及解决办法"><a href="#Git-常见错误及解决办法" class="headerlink" title="Git 常见错误及解决办法"></a>Git 常见错误及解决办法</h1><blockquote><p>收录使用 Git 过程中遇到的问题</p></blockquote><p>[TOC]</p><h2 id="1、fatal-refusing-to-merge-unrelated-histories"><a href="#1、fatal-refusing-to-merge-unrelated-histories" class="headerlink" title="1、fatal: refusing to merge unrelated histories"></a>1、<code>fatal: refusing to merge unrelated histories</code></h2><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>这种错误在两个分支合并或者<code>git pull</code>以及<code>git push </code>都会出现，这个是因为两个分支没有去的关系，或者远程分支没有和本地分支关联</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>在操作命令后添加<code>--allow-unrelated-history</code></p><h2 id="2、Could-not-read-from-remote-repository"><a href="#2、Could-not-read-from-remote-repository" class="headerlink" title="2、Could not read from remote repository."></a>2、<code>Could not read from remote repository.</code></h2><h3 id="问题描述：-1"><a href="#问题描述：-1" class="headerlink" title="问题描述："></a>问题描述：</h3><p><code>git push</code>过程中出现错误，是因为<code> ssh-key</code> 的问题，本地没有正确配置 <code>ssh-key</code></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs livecodeserver">git@github.com: Permission denied (publickey).<br>fatal: Could <span class="hljs-keyword">not</span> <span class="hljs-built_in">read</span> <span class="hljs-built_in">from</span> remote repository.<br><br>Please make sure you have <span class="hljs-keyword">the</span> correct access rights<br><span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> repository exists.<br></code></pre></td></tr></table></figure><h3 id="解决办法：-1"><a href="#解决办法：-1" class="headerlink" title="解决办法："></a>解决办法：</h3><p>首先查看是否有 ssh 数据   <code>ssh-add -l</code></p><p>如果不存在的话会出现 <code>The agent has no identities.</code></p><p>需要添加<code>ssh-key</code>:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ssh-add ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_github<br>ssh-add ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_github<br></code></pre></td></tr></table></figure><p>添加完毕以后再次验证 <code>ssh-add -l</code></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2048 </span>SHA256:izQU3fcuygtE2jr8KLFhujoS6c/bB46k09uyu/VCRzk xxx@email (RSA)<br><span class="hljs-symbol">2048 </span>SHA256:jH+IeruPI+si++vSWPrr/e14ZDT+flI4xGioGQXF+gc xxx@email (RSA)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git本地仓库关联远程仓库</title>
    <link href="/2022/01/19/Git%20%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <url>/2022/01/19/Git%20%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-本地仓库关联远程仓库"><a href="#Git-本地仓库关联远程仓库" class="headerlink" title="Git 本地仓库关联远程仓库"></a>Git 本地仓库关联远程仓库</h1><h2 id="1、建立远程仓库"><a href="#1、建立远程仓库" class="headerlink" title="1、建立远程仓库"></a>1、建立远程仓库</h2><h2 id="2、初始化本地仓库"><a href="#2、初始化本地仓库" class="headerlink" title="2、初始化本地仓库"></a>2、初始化本地仓库</h2><figure class="highlight csharp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><h2 id="3、修改git-config"><a href="#3、修改git-config" class="headerlink" title="3、修改git config"></a>3、修改git config</h2><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">git config <span class="hljs-literal">user</span>.<span class="hljs-keyword">name</span> <span class="hljs-string">&quot;zhangweijie&quot;</span><br>git config <span class="hljs-literal">user</span>.email <span class="hljs-string">&quot;15538088057@163.com&quot;</span><br></code></pre></td></tr></table></figure><h2 id="4、添加基础文件"><a href="#4、添加基础文件" class="headerlink" title="4、添加基础文件"></a>4、添加基础文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# bubble&quot;</span> &gt;&gt; README.md<br></code></pre></td></tr></table></figure><h2 id="5、提交代码并推送"><a href="#5、提交代码并推送" class="headerlink" title="5、提交代码并推送"></a>5、提交代码并推送</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> README.md<br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>git branch -M main<br>git remote <span class="hljs-built_in">add</span> origin git@github.com:zhangweijie11/bubble.git<br>git push -u origin main<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 代码编译问题</title>
    <link href="/2022/01/19/Golang%20%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/19/Golang%20%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-代码编译问题"><a href="#Golang-代码编译问题" class="headerlink" title="Golang 代码编译问题"></a>Golang 代码编译问题</h1><ul><li>Windows</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 编译代码</span><br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">CGO_ENABLED</span>=0<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">GOOS</span>=darwin<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">GOARCH</span>=amd64<br>go build main.go<br><br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">CGO_ENABLED</span>=0<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">GOOS</span>=linux<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">GOARCH</span>=amd64<br>go build main.go<br></code></pre></td></tr></table></figure><ul><li>Linux</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 编译代码</span><br><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=darwin <span class="hljs-attribute">GOARCH</span>=amd64 go build main.go<br><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=windows <span class="hljs-attribute">GOARCH</span>=amd64 go build main.go<br></code></pre></td></tr></table></figure><ul><li>MAC</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 编译代码</span><br><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=linux <span class="hljs-attribute">GOARCH</span>=amd64 go build main.go  # linux<br><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=windows <span class="hljs-attribute">GOARCH</span>=amd64 go build main.go  # windows<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 配置文件相关操作</title>
    <link href="/2021/01/21/Golang%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/01/21/Golang%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-配置文件相关操作"><a href="#Golang-配置文件相关操作" class="headerlink" title="Golang 配置文件相关操作"></a>Golang 配置文件相关操作</h1><blockquote><p>本文以读取数据库配置文件为例</p></blockquote><h2 id="1、JSON-文件"><a href="#1、JSON-文件" class="headerlink" title="1、JSON 文件"></a>1、JSON 文件</h2><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 解析 json 格式的配置文件</span><br><span class="hljs-comment">文件内容如下：</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  &quot;type&quot;: &quot;json&quot;,</span><br><span class="hljs-comment">  &quot;postgres&quot;: &#123;</span><br><span class="hljs-comment">    &quot;host&quot;: &quot;localhost&quot;,</span><br><span class="hljs-comment">    &quot;port&quot;: 5432,</span><br><span class="hljs-comment">    &quot;username&quot;: &quot;postgres&quot;,</span><br><span class="hljs-comment">    &quot;password&quot;: &quot;postgres&quot;,</span><br><span class="hljs-comment">    &quot;dbname&quot;: &quot;bubble&quot;</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">// 定义第一级配置文件的结构体</span><br><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>Type     <span class="hljs-type">string</span><br>Postgres DbConf <span class="hljs-comment">// 数据类型为第二级配置文件的结构体名称</span><br>&#125;<br><br><span class="hljs-comment">// 定义第二级配置文件的结构体   注意数据类型</span><br><span class="hljs-keyword">type</span> DbConf <span class="hljs-keyword">struct</span> &#123;<br>Host     <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;host&quot;`</span><br>Port     <span class="hljs-type">uint</span>   <span class="hljs-string">`json:&quot;port&quot;`</span><br>Username <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;username&quot;`</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;password&quot;`</span><br>DbName   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;dbname&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// 定义配置文件结构体</span><br><span class="hljs-keyword">type</span> JsonStruct <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// 创建配置文件的构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewJsonStruct</span><span class="hljs-params">()</span></span> *JsonStruct &#123;<br><span class="hljs-keyword">return</span> &amp;JsonStruct&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 加载配置文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(jt *JsonStruct)</span></span> Load(filename <span class="hljs-type">string</span>, v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-comment">// 读取配置文件</span><br>data, err := ioutil.ReadFile(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 解析配置文件</span><br>err = json.Unmarshal(data, v)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>JsonParse := NewJsonStruct()<br>v := Config&#123;&#125;<br><span class="hljs-comment">// 获取配置文件路径</span><br>osGwd, _ := os.Getwd()<br>confPath := osGwd + <span class="hljs-string">&quot;/conf_json.json&quot;</span><br><span class="hljs-comment">// 加载配置文件</span><br>JsonParse.Load(confPath, &amp;v)<br>fmt.Printf(<span class="hljs-string">&quot;配置文件的类型为 %s \n&quot;</span>, v.Type)<br>fmt.Printf(<span class="hljs-string">&quot;PG 数据库的配置为 %s \n&quot;</span>, v.Postgres)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2、YAML-文件-推荐"><a href="#2、YAML-文件-推荐" class="headerlink" title="2、YAML 文件(推荐)"></a>2、YAML 文件(<strong>推荐</strong>)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">解析 yaml 格式的配置文件</span><br><span class="hljs-comment">文件内容如下：</span><br><span class="hljs-comment">database:</span><br><span class="hljs-comment">  postgres:</span><br><span class="hljs-comment">    host: localhost</span><br><span class="hljs-comment">    port: 5432</span><br><span class="hljs-comment">    username: postgres</span><br><span class="hljs-comment">    password: postgres</span><br><span class="hljs-comment">    dbname: bubble</span><br><span class="hljs-comment">&#125; */</span><br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;gopkg.in/yaml.v2&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> YamlStruct <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewYamlStruct</span><span class="hljs-params">()</span></span> *YamlStruct &#123;<br><span class="hljs-keyword">return</span> &amp;YamlStruct&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> YamlConfig <span class="hljs-keyword">struct</span> &#123;<br>DataBase DataBase <span class="hljs-string">`yaml:&quot;database&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> DataBase <span class="hljs-keyword">struct</span> &#123;<br>PgConf PgConf <span class="hljs-string">`yaml:&quot;postgres&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> PgConf <span class="hljs-keyword">struct</span> &#123;<br>Host     <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;host&quot;`</span><br>Port     <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;port&quot;`</span><br>Username <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;username&quot;`</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;password&quot;`</span><br>DbName   <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;dbname&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(yam *YamlStruct)</span></span> Load(filename <span class="hljs-type">string</span>, v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>data, err := ioutil.ReadFile(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err.Error())<br>&#125;<br>err = yaml.Unmarshal(data, v)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err.Error())<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>YamlStruct := NewYamlStruct()<br>v := YamlConfig&#123;&#125;<br>osGwd, _ := os.Getwd()<br>confPath := osGwd + <span class="hljs-string">&quot;/conf_yaml.yaml&quot;</span><br>YamlStruct.Load(confPath, &amp;v)<br>fmt.Printf(<span class="hljs-string">&quot;配置文件的数据为 %s \n&quot;</span>, v.DataBase)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3、INI-文件"><a href="#3、INI-文件" class="headerlink" title="3、INI 文件"></a>3、INI 文件</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 解析 ini 格式的配置文件</span><br><span class="hljs-comment">文件内容如下：</span><br><span class="hljs-comment">mode=debug</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">[postgres]</span><br><span class="hljs-comment">host=localhost</span><br><span class="hljs-comment">port=5432</span><br><span class="hljs-comment">username=postgres</span><br><span class="hljs-comment">password=postgres</span><br><span class="hljs-comment">dbname=bubble</span><br><span class="hljs-comment"> */</span><br><br>import (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/go-ini/ini&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">//type Postgres struct &#123;</span><br><span class="hljs-comment">//Host     string</span><br><span class="hljs-comment">//Port     uint</span><br><span class="hljs-comment">//Username string</span><br><span class="hljs-comment">//Password string</span><br><span class="hljs-comment">//DbName   string</span><br><span class="hljs-comment">//&#125;</span><br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br>osGwd, _ := os<span class="hljs-selector-class">.Getwd</span>()<br>confPath := osGwd + <span class="hljs-string">&quot;/conf_ini.ini&quot;</span><br>config, err := ini<span class="hljs-selector-class">.Load</span>(confPath)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-built_in">panic</span>(err<span class="hljs-selector-class">.Error</span>())<br>&#125;<br><span class="hljs-comment">// 可以直接读取配置，并设置默认值</span><br>mode := config<span class="hljs-selector-class">.Section</span>(<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-selector-class">.Key</span>(<span class="hljs-string">&quot;mode&quot;</span>)<span class="hljs-selector-class">.MustString</span>(<span class="hljs-string">&quot;debug&quot;</span>)<br>fmt<span class="hljs-selector-class">.Println</span>(mode)<br>postgres, err := config<span class="hljs-selector-class">.GetSection</span>(<span class="hljs-string">&quot;postgres&quot;</span>)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-built_in">panic</span>(err<span class="hljs-selector-class">.Error</span>())<br>&#125;<br><span class="hljs-comment">// 可通过 Key 去取值</span><br>fmt<span class="hljs-selector-class">.Println</span>(postgres<span class="hljs-selector-class">.Key</span>(<span class="hljs-string">&quot;host&quot;</span>))  <span class="hljs-comment">// localhost</span><br>fmt<span class="hljs-selector-class">.Println</span>(postgres<span class="hljs-selector-class">.Keys</span>())       <span class="hljs-comment">//  [localhost 5432 postgres postgres bubble]</span><br>fmt<span class="hljs-selector-class">.Println</span>(postgres<span class="hljs-selector-class">.KeyStrings</span>()) <span class="hljs-comment">// [host port username password dbname]</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作文件基础</title>
    <link href="/2020/11/06/%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/11/06/%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>其实我们可以随便排列存储文件，而且我们也可以自己定义文件格式，但是按照标准格式的话会更加方便，不管是存储还是查询。</p><p>文件其实是一长串二进制数据，我们通过 ASCII 码去解读文件。</p><p>文件有很多种类，大致分为五类：</p><ol><li>文字文件</li><li>图片文件</li><li>视频文件</li><li>音乐文件</li><li>其他文件</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置 GitHub 以及 GitLab 账户</title>
    <link href="/2020/03/17/%E9%85%8D%E7%BD%AE%20GitHub%20%E4%BB%A5%E5%8F%8A%20Gitlab%20%E8%B4%A6%E6%88%B7/"/>
    <url>/2020/03/17/%E9%85%8D%E7%BD%AE%20GitHub%20%E4%BB%A5%E5%8F%8A%20Gitlab%20%E8%B4%A6%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="配置-GitHub-以及-Gitlab-账户"><a href="#配置-GitHub-以及-Gitlab-账户" class="headerlink" title="配置 GitHub 以及 Gitlab 账户"></a>配置 GitHub 以及 Gitlab 账户</h2><h3 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h3><p>全局配置 Git 账户</p><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-comment">// 配置全局用户名，如Github上注册的用户名</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;yyy@mail.com&quot;</span> <span class="hljs-comment">// 配置全局邮箱，如Github上配置的邮箱</span><br></code></pre></td></tr></table></figure><p>这个<code>--global</code>选项，是指这里配置的<code>user.name</code>和<code>user.email</code>是相对于全局进行配置的，即不同的Git仓库默认的用户名和邮箱都是这个值。由于需要管理多个账户，所以仅仅使用这个全局值是不够的，<strong>需要在每个仓库中单独配置</strong>。对此，有两种处理方法：</p><p>如果之前已经使用该命令进行配置，则先使用如下命令清除</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> user<span class="hljs-selector-class">.name</span><br>git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> user.email<br></code></pre></td></tr></table></figure><p>如果不确定是否已经配置过，可以使用下面的命令查看</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.name</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.email</span><br></code></pre></td></tr></table></figure><h3 id="2、开始配置"><a href="#2、开始配置" class="headerlink" title="2、开始配置"></a>2、开始配置</h3><h4 id="2-1-针对不同的账户生成不同的密匙"><a href="#2-1-针对不同的账户生成不同的密匙" class="headerlink" title="2.1 针对不同的账户生成不同的密匙"></a>2.1 针对不同的账户生成不同的密匙</h4><p>进入保存密匙的目录</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/.ssh</span> <span class="hljs-string">//</span> 进入目录，该目录下保存生成的秘钥<br></code></pre></td></tr></table></figure><p>然后，根据账户邮箱生成秘钥。例如我在GitHub上的邮箱是<a href="mailto:&#120;&#120;&#x78;&#x40;&#121;&#x79;&#x79;&#x2e;&#99;&#x6f;&#x6d;">&#120;&#120;&#x78;&#x40;&#121;&#x79;&#x79;&#x2e;&#99;&#x6f;&#x6d;</a>，则命令为：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;xxx@yyy.com&quot;</span><br></code></pre></td></tr></table></figure><p>输入完成后，会有如下提示：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Generating <span class="hljs-keyword">public</span>/<span class="hljs-keyword">private</span> rsa key pair.<br>Enter <span class="hljs-keyword">file</span> in which to save the key (<span class="hljs-regexp">/Users/</span>zhangweijie<span class="hljs-regexp">/.ssh/i</span>d_rsa):<span class="hljs-regexp">/Users/</span>zhangweijie<span class="hljs-regexp">/.ssh/i</span>d_rsa_github<br></code></pre></td></tr></table></figure><p>这里要求对秘钥进行命名，默认的文件名是<code>id_rsa</code>。为了方便区分，我这里命名为<code>id_rsa_github</code>。接下来的提示都直接进行回车，直到秘钥生成。通过<code>ls</code>命令，可以看到刚刚生成的密钥对<code>id_rsa_github</code>和<code>id_rsa_github.pub</code>。其中<code>id_rsa_github.pub</code>是公钥。</p><p>同样，对于GitLab上的账户，我是用另一个邮箱注册的，按照同样的步骤生成<code>id_rsa_gitlab</code>的秘钥对。接下来的步骤，除额外说明外，两个账户的操作完全相同。</p><h4 id="2-2-私匙添加到本地"><a href="#2-2-私匙添加到本地" class="headerlink" title="2.2 私匙添加到本地"></a>2.2 私匙添加到本地</h4><p>SSH协议的原理，就是在托管网站上使用公钥，在本地使用私钥，这样本地仓库就可以和远程仓库进行通信。在上一步已经生成了秘钥文件，接下来需要使用秘钥文件，首先是在本地使用秘钥文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">ssh-add ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_github <span class="hljs-regexp">//</span> 将GitHub私钥添加到本地<br>ssh-add ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_gitlab <span class="hljs-regexp">//</span> 将GitLab私钥添加到本地<br></code></pre></td></tr></table></figure><p>为了检验本地是否添加成功，可以使用<code>ssh-add -l</code>命令进行查看</p><h4 id="2-3-对本地秘钥进行配置"><a href="#2-3-对本地秘钥进行配置" class="headerlink" title="2.3  对本地秘钥进行配置"></a>2.3  对本地秘钥进行配置</h4><p>由于添加了多个密钥文件，所以需要对这多个密钥进行管理。在<code>.ssh</code>目录下新建一个config文件：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">touch config<br></code></pre></td></tr></table></figure><p>文件中的内容如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">Host github <span class="hljs-regexp">//</span> 网站的别名，随意取<br>HostName github.com <span class="hljs-regexp">//</span> 托管网站的域名<br>User liugui <span class="hljs-regexp">//</span> 托管网站上的用户名<br>IdentityFile ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_github <span class="hljs-regexp">//</span> 使用的密钥文件<br><br><span class="hljs-regexp">//</span> GitLab的配置相同<br>Host gitlab<br>HostName gitlab.com<br>User liugui<br>IdentityFile ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_gitlab<br></code></pre></td></tr></table></figure><h4 id="2-4-公匙添加到托管网站"><a href="#2-4-公匙添加到托管网站" class="headerlink" title="2.4 公匙添加到托管网站"></a>2.4 公匙添加到托管网站</h4><p>以GitHub为例，先在本地复制公钥。进入<code>.ssh</code>目录，使用<code>vim id_rsa_github.pub</code>查看生成的GitHub公钥，全选进行复制。</p><p>登录GitHub，点击右上角头像选择<code>settings</code>，在打开的页面中选择SSH and GPG keys，</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081111553.png" alt="图片描述"></p><p>在打开的页面的Key输入框中粘贴刚刚复制的公钥，title的名字自己随便去，然后点击下方的<code>Add SSH key</code>按钮：<br><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081111010.png" alt="图片描述"></p><p>至此，托管网站的公钥添加完成。总结来说，就是针对每个托管网站分别生成一对密钥，然后分别添加到本地和托管网站。</p><p>这时候，可以测试一下配置是否成功，测试命令使用别名。例如，对于GitHub，本来应该使用的测试命令是：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><p>在config文件中，给GitHub网站配置的别名就是github，所以直接使用别名，就是</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span><br></code></pre></td></tr></table></figure><h3 id="3、如何使用"><a href="#3、如何使用" class="headerlink" title="3、如何使用"></a>3、如何使用</h3><p>使用有两种情况，一种情况是从远端拉取代码到本地，一种是本地已有仓库需要与远程仓库关联。</p><h4 id="3-1-从远端拉取代码"><a href="#3-1-从远端拉取代码" class="headerlink" title="3.1 从远端拉取代码"></a>3.1 从远端拉取代码</h4><p>选择SSH协议的复制命令，如对于GitLab上代码库test，其复制命令为</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@gitlab.com:liugui/test.git<br></code></pre></td></tr></table></figure><p>由于使用了别名gitlab，所以实际使用的复制命令应当为：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">git clone git<span class="hljs-variable">@gitlab</span><span class="hljs-symbol">:liugui/test</span>.git<br></code></pre></td></tr></table></figure><p>也可以不进行修改，git 会自己找到对应的域名</p><h4 id="3-2-本地已有的仓库"><a href="#3-2-本地已有的仓库" class="headerlink" title="3.2 本地已有的仓库"></a>3.2 本地已有的仓库</h4><p>这种情况适用于本地新建的仓库需要与远端进行关联，或者之前已经使用sourceTree等图形界面软件拷贝的仓库。进入本地仓库文件夹，需要单独配置该仓库的用户名和邮箱</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">git config <span class="hljs-literal">user</span>.<span class="hljs-keyword">name</span> <span class="hljs-string">&quot;xxx&quot;</span><br>git config <span class="hljs-literal">user</span>.email <span class="hljs-string">&quot;xxx@yyy.com&quot;</span><br></code></pre></td></tr></table></figure><p>然后，进入本地仓库的git目录，打开config文件</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">.git</span> <span class="hljs-string">//</span> 该目录是隐藏的，<span class="hljs-keyword">ls</span>命令不可见，但是可以直接进入，如果是新建的文件夹需要先执行git init<br>vim config<br></code></pre></td></tr></table></figure><p>在config文件中，修改（config文件中已有remote “origin”信息）或者添加（config文件中不包含remote “origin”信息）分支信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[remote <span class="hljs-string">&quot;origin&quot;</span>]<br>        url = git<span class="hljs-variable">@gitlab</span><span class="hljs-symbol">:xxx/test</span>.git<br>        fetch = +refs/heads/*<span class="hljs-symbol">:refs/remotes/origin/*</span><br></code></pre></td></tr></table></figure><p>主要是URL部分，原生的信息一般是<code>git@gitlab.com:xxx/test.git</code>，需要将gitlab.com使用别名gitlab代替。</p><p>可以看到，仓库中的关键是要配置好用户名和邮箱，以及使用别名。使用别名的目的是为了通过别名，将本地仓库与密钥目录<code>.ssh</code>文件夹下的密钥进行管理，这样就完成了本地仓库使用的私钥与托管网站使用的公钥的配对，而用户名和邮箱是该仓库使用SSH协议时需要用到的信息</p>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>GitLab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kONG 网关简介及简单使用</title>
    <link href="/2020/02/07/Kong%20%E7%BD%91%E5%85%B3%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/02/07/Kong%20%E7%BD%91%E5%85%B3%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Kong-网关简介及简单使用"><a href="#Kong-网关简介及简单使用" class="headerlink" title="Kong 网关简介及简单使用"></a>Kong 网关简介及简单使用</h2><h3 id="1、kong-网关简介"><a href="#1、kong-网关简介" class="headerlink" title="1、kong 网关简介"></a>1、kong 网关简介</h3><p>Kong是在客户端和微服务端转发 API 通信的 API 网关，可以通过插件扩展功能。Kong 主要有两个重要的的组件：</p><ul><li>Kong Server：基于 nginx 的服务器，用来接收 API 请求</li><li>Apache Cassandra：用于存储操作数据</li></ul><p>我们可以通过增加更多的 Kong Server服务器对 Kong 服务进行水平扩展，通过前置的负载均衡器向这些机器发送分发请求。根据文档描述，两个 Cassandra 节点就足以支撑绝大多数情况，但如果网络非常拥挤，可以适当考虑增加更多的节点。</p><p>对于我们来说，Kong 中最为重要的一个特性就是可以通过插件扩展已有功能，这些插件在 API 请求响应循环的生命周期内被执行。插件使用 Lua 编写，而且 Kong 还有如下几个基础功能：</p><p>HTTP 基本认证，密匙认证，CORS（Cross-origin Resource Sharing，跨域资源共享），TCP，UDP，文件日志，API请求限流，请求转发及 Nginx 监控等等</p><h3 id="2、docker-部署-kong"><a href="#2、docker-部署-kong" class="headerlink" title="2、docker 部署 kong"></a>2、docker 部署 kong</h3><p>官方文档：<a href="https://hub.docker.com/_/kong/">https://hub.docker.com/_/kong/</a></p><p>设置网络</p><figure class="highlight dos"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs dos">docker network create kong-<span class="hljs-built_in">net</span><br></code></pre></td></tr></table></figure><p>安装数据库， PostgreSQL and Cassandra，推荐使用 postgres（版本号可自由选择）</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">docker run -d --name kong-database \<br>              --network=kong-net \<br>              -p <span class="hljs-number">5432</span>:<span class="hljs-number">5432</span> \<br>              -e <span class="hljs-string">&quot;POSTGRES_USER=kong&quot;</span> \<br>              -e <span class="hljs-string">&quot;POSTGRES_DB=kong&quot;</span> \<br>              postgres:<span class="hljs-number">11</span>.<span class="hljs-number">1</span>-alpine<br></code></pre></td></tr></table></figure><p>准备 kong 数据</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run --rm <span class="hljs-string">\</span><br>    --network=kong-net <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_DATABASE=postgres&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_PG_HOST=kong-database&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot;</span> <span class="hljs-string">\</span><br>    kong:latest kong migrations bootstrap<br></code></pre></td></tr></table></figure><p>启动kong，设置postgres 数据库</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run -d --name kong <span class="hljs-string">\</span><br>    --network=kong-net <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_DATABASE=postgres&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_PG_HOST=kong-database&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_PROXY_ACCESS_LOG=/dev/stdout&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_ADMIN_ACCESS_LOG=/dev/stdout&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_PROXY_ERROR_LOG=/dev/stderr&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_ADMIN_ERROR_LOG=/dev/stderr&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot;</span> <span class="hljs-string">\</span><br>    -p <span class="hljs-number">8000</span>:<span class="hljs-number">8000</span> <span class="hljs-string">\</span><br>    -p <span class="hljs-number">8443</span>:<span class="hljs-number">8443</span> <span class="hljs-string">\</span><br>    -p <span class="hljs-number">8001</span>:<span class="hljs-number">8001</span> <span class="hljs-string">\</span><br>    -p <span class="hljs-number">8444</span>:<span class="hljs-number">8444</span> <span class="hljs-string">\</span><br>    kong:latest<br></code></pre></td></tr></table></figure><p>：8000 Kong 在该端口上侦听来自客户端的传入 HTTP 流量，并将其转发到上游服务</p><p>：8443 Kong 在其上侦听传入的 HTTPS 流量。此端口具有与端口 8000 类似的行为，不过他仅支持 HTTPS通信，可以通过配置文件禁用此端口</p><p>：8001 用于配置 Kong 侦听的 admin api</p><p>：8444 admin api 在其上侦听 HTTPS 流量</p><p>检查 kong 是否正常运行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -i http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8001</span>/<br></code></pre></td></tr></table></figure><p>安装图形化界面</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -d <span class="hljs-comment">--name kong-dashboard \</span><br>    <span class="hljs-comment">--network=kong-net \</span><br>    <span class="hljs-comment">--link kong:kong \</span><br>    -p <span class="hljs-number">8081</span>:<span class="hljs-number">8080</span> \<br>    pgbi/kong-dashboard:v2 migrations up<br></code></pre></td></tr></table></figure><h3 id="3、配置服务"><a href="#3、配置服务" class="headerlink" title="3、配置服务"></a>3、配置服务</h3><p>向 kong添加 API，我们需要先添加一个 service，即使用 kong 用来指代其管理的上游 API 和微服务的名称</p><p>我们将创建一个指向<a href="https://mockbin.com/">Mockbin API的服务</a>。Mockbin是一个“回声”类型的公共网站，它将返回的请求返回给请求者，作为响应。这有助于了解Kong如何代理您的API请求。</p><p>在开始对服务提出请求之前，需要为其添加一条<em>路由</em>。路线指定到达香港后如何（以及<em>是否</em>）将请求发送到其服务。单个服务可以具有多个路由。</p><p>配置服务和路线后，您将可以使用它们通过Kong发出请求。</p><p>Kong 在port上公开了<a href="https://docs.konghq.com/2.0.x/admin-api">RESTful Admin API</a><code>:8001</code>。Kong的配置（包括添加服务和路由）是通过该API上的请求进行的。</p><h4 id="1）使用-admin-api添加服务"><a href="#1）使用-admin-api添加服务" class="headerlink" title="1）使用 admin api添加服务"></a>1）使用 admin api添加服务</h4><p>发出以下cURL请求以将您的第一个服务（指向<a href="https://mockbin.com/">Mockbin API</a>）添加到Kong：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">curl -<span class="hljs-selector-tag">i</span> -X POST \<br>  <span class="hljs-attr">--url</span> http:<span class="hljs-comment">//localhost:8001/services/ \</span><br>  <span class="hljs-attr">--data</span> <span class="hljs-string">&#x27;name=example-service&#x27;</span> \<br>  <span class="hljs-attr">--data</span> <span class="hljs-string">&#x27;url=http://mockbin.org&#x27;</span><br></code></pre></td></tr></table></figure><p>内容回复：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">201</span> Created<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 07 Feb 2020 09:04:51 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json; charset=utf-8<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>kong/2.0.1<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>296<br><span class="hljs-attribute">X-Kong-Admin-Latency</span><span class="hljs-punctuation">: </span>210<br><br><span class="language-1c">&#123;<span class="hljs-string">&quot;host&quot;</span>:<span class="hljs-string">&quot;mockbin.org&quot;</span>,<span class="hljs-string">&quot;created_at&quot;</span>:<span class="hljs-number">1581066291</span>,<span class="hljs-string">&quot;connect_timeout&quot;</span>:<span class="hljs-number">60000</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;1148d98c-2eeb-4988-af84-d3173080bdd9&quot;</span>,<span class="hljs-string">&quot;protocol&quot;</span>:<span class="hljs-string">&quot;http&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;example-service&quot;</span>,<span class="hljs-string">&quot;read_timeout&quot;</span>:<span class="hljs-number">60000</span>,<span class="hljs-string">&quot;port&quot;</span>:<span class="hljs-number">80</span>,<span class="hljs-string">&quot;path&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;updated_at&quot;</span>:<span class="hljs-number">1581066291</span>,<span class="hljs-string">&quot;retries&quot;</span>:<span class="hljs-number">5</span>,<span class="hljs-string">&quot;write_timeout&quot;</span>:<span class="hljs-number">60000</span>,<span class="hljs-string">&quot;tags&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;client_certificate&quot;</span>:<span class="hljs-literal">null</span>&#125;%</span><br></code></pre></td></tr></table></figure><h4 id="SERVICES-API详解"><a href="#SERVICES-API详解" class="headerlink" title="SERVICES API详解"></a>SERVICES API详解</h4><h4 id="1、添加-services"><a href="#1、添加-services" class="headerlink" title="1、添加 services"></a>1、添加 services</h4><p>请求地址：&#x2F;service&#x2F;</p><p>请求方法：POST</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">name（可选）</td><td align="left">服务名称.</td></tr><tr><td align="left">protocol</td><td align="left">该协议用于与upstream通信。它可以是http（默认）或https。</td></tr><tr><td align="left">host</td><td align="left">upstream服务器的主机。</td></tr><tr><td align="left">port</td><td align="left">upstream服务器端口。默认为80</td></tr><tr><td align="left">path（可选）</td><td align="left">在向upstream服务器请求中使用的路径。默认为空。</td></tr><tr><td align="left">retries（可选）</td><td align="left">在代理失败的情况下执行的重试次数。默认值是5。</td></tr><tr><td align="left">connect_timeout（可选）</td><td align="left">建立到upstream服务器的连接的超时时间。默认为60000。</td></tr><tr><td align="left">write_timeout（可选）</td><td align="left">将请求发送到upstream服务器的两个连续写操作之间的超时时间。默认为60000。</td></tr><tr><td align="left">read_timeout（可选）</td><td align="left">将请求发送到upstream服务器的两个连续读取操作之间的超时时间。默认为60000。</td></tr><tr><td align="left">url（简写属性）</td><td align="left">将协议、主机、端口和路径立即设置成简短的属性。这个属性是只写的（管理API从来不“返回”url）。</td></tr></tbody></table><h4 id="2、查找-service"><a href="#2、查找-service" class="headerlink" title="2、查找 service"></a>2、查找 service</h4><p>请求地址：&#x2F;services&#x2F;{name or id}</p><p>请求方法：GET</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">name or id（必填）</td><td align="left">检索的唯一标识符或服务名称。</td></tr></tbody></table><p>请求地址：&#x2F;routes&#x2F;{route id}&#x2F;service</p><p>请求方法：GET</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">route id（必填）</td><td align="left">属于要检索的服务的路由的唯一标识符。</td></tr></tbody></table><h4 id="3、查找-service-列表"><a href="#3、查找-service-列表" class="headerlink" title="3、查找 service 列表"></a>3、查找 service 列表</h4><p>请求地址：&#x2F;services&#x2F;</p><p>请求方法：GET</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">offset（可选）</td><td align="left">用于分页的游标。偏移量是定义列表中的位置的对象标识符。</td></tr><tr><td align="left">size（可选，默认是100 max是1000）</td><td align="left">每个页面返回的对象数量的限制。</td></tr></tbody></table><h4 id="4、更新-service"><a href="#4、更新-service" class="headerlink" title="4、更新 service"></a>4、更新 service</h4><p>请求地址：&#x2F;service&#x2F;{name or id}</p><p>请求方法：PATCH</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">name or id（必填）</td><td align="left">要更新的服务的id或name属性。</td></tr></tbody></table><p>请求地址：&#x2F;routes&#x2F;{route id}&#x2F;service</p><p>请求方法：PATCH</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">route id（必填）</td><td align="left">要更新服务的路由的id属性。</td></tr></tbody></table><h4 id="5、删除-service"><a href="#5、删除-service" class="headerlink" title="5、删除 service"></a>5、删除 service</h4><p>请求地址：&#x2F;services&#x2F;{name or id}</p><p>请求方法：DELETE</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">name or id（必填）</td><td align="left">要删除的服务的id或name属性。</td></tr></tbody></table><h4 id="2）添加服务路线"><a href="#2）添加服务路线" class="headerlink" title="2）添加服务路线"></a>2）添加服务路线</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -i -X POST \<br>  --url http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8001</span><span class="hljs-regexp">/services/</span>example-service/routes \<br>  --data <span class="hljs-string">&#x27;hosts[]=example.com&#x27;</span><br></code></pre></td></tr></table></figure><p>内容回复：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">201</span> Created<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 07 Feb 2020 09:05:40 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json; charset=utf-8<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>kong/2.0.1<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>429<br><span class="hljs-attribute">X-Kong-Admin-Latency</span><span class="hljs-punctuation">: </span>26<br><br><span class="language-elixir">&#123;<span class="hljs-string">&quot;id&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;535592c2-c8b5-4f40-9a37-22f1dae115b8&quot;</span></span>,<span class="hljs-string">&quot;path_handling&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;v0&quot;</span></span>,<span class="hljs-string">&quot;paths&quot;</span><span class="hljs-symbol">:null</span>,<span class="hljs-string">&quot;destinations&quot;</span><span class="hljs-symbol">:null</span>,<span class="hljs-string">&quot;headers&quot;</span><span class="hljs-symbol">:null</span>,<span class="hljs-string">&quot;protocols&quot;</span><span class="hljs-symbol">:</span>[<span class="hljs-string">&quot;http&quot;</span>,<span class="hljs-string">&quot;https&quot;</span>],<span class="hljs-string">&quot;methods&quot;</span><span class="hljs-symbol">:null</span>,<span class="hljs-string">&quot;snis&quot;</span><span class="hljs-symbol">:null</span>,<span class="hljs-string">&quot;service&quot;</span><span class="hljs-symbol">:</span>&#123;<span class="hljs-string">&quot;id&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;1148d98c-2eeb-4988-af84-d3173080bdd9&quot;</span></span>&#125;,<span class="hljs-string">&quot;name&quot;</span><span class="hljs-symbol">:null</span>,<span class="hljs-string">&quot;strip_path&quot;</span><span class="hljs-symbol">:true</span>,<span class="hljs-string">&quot;preserve_host&quot;</span><span class="hljs-symbol">:false</span>,<span class="hljs-string">&quot;regex_priority&quot;</span><span class="hljs-symbol">:</span><span class="hljs-number">0</span>,<span class="hljs-string">&quot;updated_at&quot;</span><span class="hljs-symbol">:</span><span class="hljs-number">1581066340</span>,<span class="hljs-string">&quot;sources&quot;</span><span class="hljs-symbol">:null</span>,<span class="hljs-string">&quot;hosts&quot;</span><span class="hljs-symbol">:</span>[<span class="hljs-string">&quot;example.com&quot;</span>],<span class="hljs-string">&quot;https_redirect_status_code&quot;</span><span class="hljs-symbol">:</span><span class="hljs-number">426</span>,<span class="hljs-string">&quot;tags&quot;</span><span class="hljs-symbol">:null</span>,<span class="hljs-string">&quot;created_at&quot;</span><span class="hljs-symbol">:</span><span class="hljs-number">1581066340</span>&#125;%</span><br></code></pre></td></tr></table></figure><p>kong 现在知道服务名称，并准备代理请求</p><h4 id="ROUTE-API详解"><a href="#ROUTE-API详解" class="headerlink" title="ROUTE API详解"></a>ROUTE API详解</h4><h4 id="1、添加-route"><a href="#1、添加-route" class="headerlink" title="1、添加 route"></a>1、添加 route</h4><p>请求地址：&#x2F;routes&#x2F;</p><p>请求方法：POST</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">protocols</td><td align="left">这条路线应该允许的协议列表。默认情况下，它是“http”、“https”，这意味着路由接受这两种方式。当设置为“HTTPS”时，HTTP请求会被请求升级到HTTPS。通过表单编码，符号是协议&#x3D;http&amp;协议&#x3D;https。使用JSON，使用数组。</td></tr><tr><td align="left">methods(半可选)</td><td align="left">与此路由相匹配的HTTP方法列表。例如: [“GET”, “POST”].至少有一个主机、路径或方法必须被设置。用表单编码参数是methods[]&#x3D;GET&amp;methods[]&#x3D;OPTIONS。使用JSON，使用数组。</td></tr><tr><td align="left">hosts(半可选)</td><td align="left">与此路径匹配的域名列表。例如:example.com. 至少有一个主机、路径或方法必须被设置。用表单编码参数是 hosts[]&#x3D;foo.com&amp;hosts[]&#x3D;bar.com。使用JSON，使用数组。</td></tr><tr><td align="left">paths(半可选)</td><td align="left">与此路径相匹配的路径列表。例如: &#x2F;my-path.至少有一个主机、路径或方法必须被设置。用表单编码参数是 paths[]&#x3D;&#x2F;foo&amp;paths[]&#x3D;&#x2F;bar. 使用JSON，使用数组。</td></tr><tr><td align="left">strip_path(可选)</td><td align="left">当通过一条路径匹配一条路径时，从upstream请求URL中剥离匹配的前缀。默认值为true。</td></tr><tr><td align="left">preserve_host(可选)</td><td align="left">当通过一个主机域名匹配一条路由时，在upstream请求头中使用请求主机头。默认设置为false，upstream主机头将是服务主机的主机头。</td></tr><tr><td align="left">service</td><td align="left">这条路线的服务是相关的。这是路由代理通信的地方。用表单编码参数是service.id&#x3D;<service_id>。如果是JSON，则使用”service”:{“id”:”<service_id>“}</td></tr></tbody></table><h4 id="2、查找-route"><a href="#2、查找-route" class="headerlink" title="2、查找 route"></a>2、查找 route</h4><p>请求地址：&#x2F;routes&#x2F;{id}</p><p>请求方法：GET</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">id（必填）</td><td align="left">检索路由的id属性。</td></tr></tbody></table><h4 id="3、查找-route-列表"><a href="#3、查找-route-列表" class="headerlink" title="3、查找 route 列表"></a>3、查找 route 列表</h4><p>请求地址：&#x2F;routes&#x2F;</p><p>请求方法：GET</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">offset（可选）</td><td align="left">用于分页的游标。偏移量是定义列表中的位置的对象标识符。</td></tr><tr><td align="left">size（可选，默认是100 max是1000）</td><td align="left">每个页面返回的对象数量的限制。</td></tr></tbody></table><h4 id="4、更新-route"><a href="#4、更新-route" class="headerlink" title="4、更新 route"></a>4、更新 route</h4><p>请求地址：&#x2F;routes&#x2F;{id}</p><p>请求方法：PATCH</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">id（必填）</td><td align="left">更新路由的id属性。</td></tr></tbody></table><h4 id="5、删除-route"><a href="#5、删除-route" class="headerlink" title="5、删除 route"></a>5、删除 route</h4><p>请求地址：&#x2F;route&#x2F;{ id}</p><p>请求方法：DELETE</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">id（必填）</td><td align="left">删除路由的id属性。</td></tr></tbody></table><h4 id="6、列出与-service-相关的-route"><a href="#6、列出与-service-相关的-route" class="headerlink" title="6、列出与 service 相关的 route"></a>6、列出与 service 相关的 route</h4><p>请求地址：&#x2F;services&#x2F;{service name or id}&#x2F;routes</p><p>请求方法：GET</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">service name or id（必填）</td><td align="left">要检索路由的服务的id或name属性。当使用这个API时，只有属于指定服务的路由才会被列出。</td></tr></tbody></table><h4 id="3）通过-kong-转发请求"><a href="#3）通过-kong-转发请求" class="headerlink" title="3）通过 kong 转发请求"></a>3）通过 kong 转发请求</h4><p>发出以下cURL请求，以验证Kong是否正确地将请求转发到您的服务。请注意，<a href="https://docs.konghq.com/2.0.x/configuration/#nginx-section">默认情况下，</a> Kong在port上处理代理请求<code>:8000</code>：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">curl -<span class="hljs-selector-tag">i</span> -X GET \<br>  <span class="hljs-attr">--url</span> http:<span class="hljs-comment">//localhost:8000/ \</span><br>  <span class="hljs-attr">--header</span> <span class="hljs-string">&#x27;Host: example.com&#x27;</span><br></code></pre></td></tr></table></figure><p>如果成功响应，表示 kong 已经成功转发我们的请求，转发 url 地址为步骤 1 中的地址</p><h3 id="4、启用插件"><a href="#4、启用插件" class="headerlink" title="4、启用插件"></a>4、启用插件</h3><p>Kong的核心原则之一是其通过<a href="https://docs.konghq.com/plugins">插件的</a>可扩展性。插件使我们可以轻松地向服务中添加新功能或使其更易于管理。</p><p>在下面的步骤中，将配置<a href="https://docs.konghq.com/plugins/key-authentication">key-auth</a>插件以向服务添加身份验证。在添加此插件之前， 对服务的<strong>所有</strong>请求都将在上游被代理。添加并配置此插件后，<strong>只会</strong>代理具有正确密钥的请求-Kong将拒绝所有其他请求，从而保护上游服务免遭未经授权的使用。</p><h4 id="1）配置密匙身份验证插件"><a href="#1）配置密匙身份验证插件" class="headerlink" title="1）配置密匙身份验证插件"></a>1）配置密匙身份验证插件</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -i -X POST \<br>  --url http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8001</span><span class="hljs-regexp">/services/</span>example-service<span class="hljs-regexp">/plugins/</span> \<br>  --data <span class="hljs-string">&#x27;name=key-auth&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>此插件还接受一个<code>config.key_names</code>参数，默认为<code>[&#39;apikey&#39;]</code>。它是应该在请求期间包含apikey的标头和参数名称（均受支持）的列表。</p><p>内容回复：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">201</span> Created<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 07 Feb 2020 09:15:07 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json; charset=utf-8<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>kong/2.0.1<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>363<br><span class="hljs-attribute">X-Kong-Admin-Latency</span><span class="hljs-punctuation">: </span>52<br><br><span class="language-actionscript">&#123;<span class="hljs-string">&quot;created_at&quot;</span>:<span class="hljs-number">1581066907</span>,<span class="hljs-string">&quot;config&quot;</span>:&#123;<span class="hljs-string">&quot;key_names&quot;</span>:[<span class="hljs-string">&quot;apikey&quot;</span>],<span class="hljs-string">&quot;run_on_preflight&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;anonymous&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;hide_credentials&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;key_in_body&quot;</span>:<span class="hljs-literal">false</span>&#125;,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;c032c177-dac4-435b-a3b6-b39edd9c11fe&quot;</span>,<span class="hljs-string">&quot;service&quot;</span>:&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;1148d98c-2eeb-4988-af84-d3173080bdd9&quot;</span>&#125;,<span class="hljs-string">&quot;enabled&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;protocols&quot;</span>:[<span class="hljs-string">&quot;grpc&quot;</span>,<span class="hljs-string">&quot;grpcs&quot;</span>,<span class="hljs-string">&quot;http&quot;</span>,<span class="hljs-string">&quot;https&quot;</span>],<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;key-auth&quot;</span>,<span class="hljs-string">&quot;consumer&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;route&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;tags&quot;</span>:<span class="hljs-literal">null</span>&#125;%</span><br></code></pre></td></tr></table></figure><h4 id="2）确认插件配置正确"><a href="#2）确认插件配置正确" class="headerlink" title="2）确认插件配置正确"></a>2）确认插件配置正确</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">curl -<span class="hljs-selector-tag">i</span> -X GET \<br>  <span class="hljs-attr">--url</span> http:<span class="hljs-comment">//localhost:8000/ \</span><br>  <span class="hljs-attr">--header</span> <span class="hljs-string">&#x27;Host: example.com&#x27;</span><br></code></pre></td></tr></table></figure><p>由于未指定所需的apikey 标题或者参数，因此响应应为 401authorized</p><p>内容回复：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">401</span> Unauthorized<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 07 Feb 2020 09:15:28 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json; charset=utf-8<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">WWW-Authenticate</span><span class="hljs-punctuation">: </span>Key realm=&quot;kong&quot;<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>41<br><span class="hljs-attribute">X-Kong-Response-Latency</span><span class="hljs-punctuation">: </span>14<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>kong/2.0.1<br><br><span class="language-erlang-repl">&#123;<span class="hljs-string">&quot;message&quot;</span>:<span class="hljs-string">&quot;No API key found in request&quot;</span>&#125;<span class="hljs-comment">%</span></span><br></code></pre></td></tr></table></figure><h3 id="5、添加消费者"><a href="#5、添加消费者" class="headerlink" title="5、添加消费者"></a>5、添加消费者</h3><h4 id="通过-restful-api-创建消费者"><a href="#通过-restful-api-创建消费者" class="headerlink" title="通过 restful api 创建消费者"></a>通过 restful api 创建消费者</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -i -X POST \<br>  --url http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8001</span><span class="hljs-regexp">/consumers/</span> \<br>  --data <span class="hljs-string">&quot;username=Jason&quot;</span><br></code></pre></td></tr></table></figure><p>内容回复：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">201</span> Created<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 07 Feb 2020 09:22:44 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json; charset=utf-8<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>kong/2.0.1<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>117<br><span class="hljs-attribute">X-Kong-Admin-Latency</span><span class="hljs-punctuation">: </span>46<br><br><span class="language-1c">&#123;<span class="hljs-string">&quot;custom_id&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;created_at&quot;</span>:<span class="hljs-number">1581067364</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;947b5a94-f0d1-4955-9903-d5d489be4015&quot;</span>,<span class="hljs-string">&quot;tags&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;username&quot;</span>:<span class="hljs-string">&quot;Jason&quot;</span>&#125;%</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong><code>custom_id</code>在<a href="https://docs.konghq.com/2.0.x/admin-api#create-consumer">创建使用者</a>以将使用者与现有用户数据库相关联时，Kong还接受参数。</p><p>CONSUMER API 详解：</p><h4 id="1、创建Consumer"><a href="#1、创建Consumer" class="headerlink" title="1、创建Consumer"></a>1、创建Consumer</h4><p>请求地址：*&#x2F;consumers&#x2F;*<br>请求方法：<em>POST</em><br>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">username（半可选）</td><td align="left">用户的唯一用户名。<code>username</code>或<code>custom_id</code>二选一。</td></tr><tr><td align="left">custom_id（半可选）</td><td align="left">消费者存储唯一ID - 用于现有数据库中的用户进行映射。<code>username</code>或<code>custom_id</code>二选一。</td></tr></tbody></table><h4 id="2、检索Consumer"><a href="#2、检索Consumer" class="headerlink" title="2、检索Consumer"></a>2、检索Consumer</h4><p>请求地址：*&#x2F;consumers&#x2F;{username or id}*<br>请求方法：<em>GET</em><br>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">username or id（必选）</td><td align="left">要检索的消费者的唯一标识符或用户名。</td></tr></tbody></table><h4 id="3、Consumer列表"><a href="#3、Consumer列表" class="headerlink" title="3、Consumer列表"></a>3、Consumer列表</h4><p>请求地址：*&#x2F;consumers&#x2F;*<br>请求方法：<em>GET</em><br>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">id（可选）</td><td align="left">基于消费者<code>id</code>字段的过滤器。</td></tr><tr><td align="left">custom_id（可选）</td><td align="left">基于消费者<code>custom_id</code>字段的过滤器。</td></tr><tr><td align="left">username（可选）</td><td align="left">基于消费者<code>username</code>字段的过滤器。</td></tr><tr><td align="left">offset（可选）</td><td align="left">用于分页的游标。偏移量是定义列表中的位置的对象标识符。</td></tr><tr><td align="left">size（可选，默认是100）</td><td align="left">每个页面返回的对象数量的限制。</td></tr></tbody></table><h4 id="4、更新Consumer"><a href="#4、更新Consumer" class="headerlink" title="4、更新Consumer"></a>4、更新Consumer</h4><p>请求地址：*&#x2F;consumers&#x2F;{username or id}*<br>请求方法：<em>PATCH</em><br>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">username or id（必选）</td><td align="left">更新的唯一标识符或用户名。</td></tr></tbody></table><p>请求主体：同1、添加Consumer</p><h4 id="5、更新或创建Consumer"><a href="#5、更新或创建Consumer" class="headerlink" title="5、更新或创建Consumer"></a>5、更新或创建Consumer</h4><p>请求地址：*&#x2F;consumers&#x2F;*<br>请求方法：<em>PUT</em><br>请求主体：同1、添加Consumer</p><h4 id="6、删除Consumer"><a href="#6、删除Consumer" class="headerlink" title="6、删除Consumer"></a>6、删除Consumer</h4><p>请求地址：*&#x2F;consumers&#x2F;{username or id}*<br>请求方法：<em>DELETE</em><br>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">username or id（必选）</td><td align="left">更新的唯一标识符或用户名。</td></tr></tbody></table><h4 id="2）为消费者提供关键凭证"><a href="#2）为消费者提供关键凭证" class="headerlink" title="2）为消费者提供关键凭证"></a>2）为消费者提供关键凭证</h4><p>现在，我们可以<code>Jason</code>通过发出以下请求为我们最近创建的使用者创建密钥：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -i -X POST \<br>  --url http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8001</span><span class="hljs-regexp">/consumers/</span>Jason<span class="hljs-regexp">/key-auth/</span> \<br>  --data <span class="hljs-string">&#x27;key=ENTER_KEY_HERE&#x27;</span><br></code></pre></td></tr></table></figure><p>内容回复：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">201</span> Created<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 07 Feb 2020 09:27:40 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json; charset=utf-8<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>kong/2.0.1<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>172<br><span class="hljs-attribute">X-Kong-Admin-Latency</span><span class="hljs-punctuation">: </span>56<br><br><span class="language-1c">&#123;<span class="hljs-string">&quot;created_at&quot;</span>:<span class="hljs-number">1581067660</span>,<span class="hljs-string">&quot;consumer&quot;</span>:&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;947b5a94-f0d1-4955-9903-d5d489be4015&quot;</span>&#125;,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;6b59a5e1-fa04-4d4b-b3b1-2e044b9c0605&quot;</span>,<span class="hljs-string">&quot;tags&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;ttl&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;key&quot;</span>:<span class="hljs-string">&quot;ENTER_KEY_HERE&quot;</span>&#125;%</span><br></code></pre></td></tr></table></figure><h4 id="3）验证消费者凭证有效"><a href="#3）验证消费者凭证有效" class="headerlink" title="3）验证消费者凭证有效"></a>3）验证消费者凭证有效</h4><p>现在，我们可以发出以下请求来验证我们的<code>Jason</code>消费者凭证是否有效：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">curl -<span class="hljs-selector-tag">i</span> -X GET \<br>  <span class="hljs-attr">--url</span> http:<span class="hljs-comment">//localhost:8001 \</span><br>  <span class="hljs-attr">--header</span> <span class="hljs-string">&quot;Host: example.com&quot;</span> \<br>  <span class="hljs-attr">--header</span> <span class="hljs-string">&quot;apikey: ENTER_KEY_HERE&quot;</span><br></code></pre></td></tr></table></figure><p>内容回复：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>10695<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Cowboy<br><span class="hljs-attribute">Etag</span><span class="hljs-punctuation">: </span>W/&quot;29c7-XG+PICJmz/J+UYWt5gkKqqAUXjc&quot;<br><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Encoding<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 07 Feb 2020 09:28:04 GMT<br><span class="hljs-attribute">Via</span><span class="hljs-punctuation">: </span>kong/2.0.1<br><span class="hljs-attribute">X-Kong-Upstream-Status</span><span class="hljs-punctuation">: </span>200<br><span class="hljs-attribute">X-Kong-Upstream-Latency</span><span class="hljs-punctuation">: </span>746<br><span class="hljs-attribute">X-Kong-Proxy-Latency</span><span class="hljs-punctuation">: </span>1523<br><span class="hljs-attribute">Kong-Cloud-Request-ID</span><span class="hljs-punctuation">: </span>3a1112d6c34f47aeb5df4ba2435b0f70<br></code></pre></td></tr></table></figure><p>如果正常响应表示该消费者请求被kong成功转发并返回数据</p>]]></content>
    
    
    <categories>
      
      <category>认证授权</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kong</tag>
      
      <tag>网关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kibana简介</title>
    <link href="/2020/02/06/kibana%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/02/06/kibana%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Kibana简介"><a href="#Kibana简介" class="headerlink" title="Kibana简介"></a>Kibana简介</h2><h3 id="1、kibana-下载"><a href="#1、kibana-下载" class="headerlink" title="1、kibana 下载"></a>1、kibana 下载</h3><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.elastic.co<span class="hljs-regexp">/cn/</span>downloads/kibana<br></code></pre></td></tr></table></figure><h3 id="2、kibana-启动"><a href="#2、kibana-启动" class="headerlink" title="2、kibana 启动"></a>2、kibana 启动</h3><p>解压后进入该目录，首先启动kibana</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kibana <span class="hljs-comment"># 启动命令</span><br>网址为：localhost:5601 <span class="hljs-comment"># 查看是否启动成功</span><br></code></pre></td></tr></table></figure><h3 id="3、插件管理"><a href="#3、插件管理" class="headerlink" title="3、插件管理"></a>3、插件管理</h3><p>查看插件信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kiban-plugin list<br></code></pre></td></tr></table></figure><p>下载插件</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bin/kiban-plugin </span><span class="hljs-keyword">install </span>plugin_location <br></code></pre></td></tr></table></figure><h3 id="4、DSL-基本命令"><a href="#4、DSL-基本命令" class="headerlink" title="4、DSL 基本命令"></a>4、DSL 基本命令</h3>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>ELK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ELK</tag>
      
      <tag>Kibana</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>logstash 简介</title>
    <link href="/2020/02/05/logstash%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/02/05/logstash%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="logstash-简介"><a href="#logstash-简介" class="headerlink" title="logstash 简介"></a>logstash 简介</h2><h3 id="1、下载及启动"><a href="#1、下载及启动" class="headerlink" title="1、下载及启动"></a>1、下载及启动</h3><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.elastic.co<span class="hljs-regexp">/cn/</span>downloads/logstash  <span class="hljs-comment"># 下载地址</span><br></code></pre></td></tr></table></figure><p>解压后进入该目录，将写好的配置文件放进 bin 文件夹</p><p>文件如下</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs puppet"><span class="hljs-keyword">input</span> &#123;<br>  file &#123;<br>    <span class="hljs-attr">path</span> =&gt; <span class="hljs-string">&quot;/Users/zhangweijie/ELK/logstash-7.5.2/bin/movies.csv&quot;</span><br>    <span class="hljs-attr">start_position</span> =&gt; <span class="hljs-string">&quot;beginning&quot;</span><br>    <span class="hljs-attr">sincedb_path</span> =&gt; <span class="hljs-string">&quot;/dev/null&quot;</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">filter</span> &#123;<br>  csv &#123;<br>    <span class="hljs-attr">separator</span> =&gt; <span class="hljs-string">&quot;,&quot;</span><br>    <span class="hljs-attr">columns</span> =&gt; [<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>,<span class="hljs-string">&quot;genre&quot;</span>]<br>  &#125;<br><br>  <span class="hljs-keyword">mutate</span> &#123;<br>    <span class="hljs-attr">split</span> =&gt; &#123; <span class="hljs-string">&quot;genre&quot;</span> =&gt; <span class="hljs-string">&quot;|&quot;</span> &#125;<br>    <span class="hljs-keyword">remove_field</span> =&gt; [<span class="hljs-string">&quot;path&quot;</span>, <span class="hljs-string">&quot;host&quot;</span>,<span class="hljs-string">&quot;@timestamp&quot;</span>,<span class="hljs-string">&quot;message&quot;</span>]<br>  &#125;<br><br>  <span class="hljs-keyword">mutate</span> &#123;<br><br>    <span class="hljs-attr">split</span> =&gt; [<span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-string">&quot;(&quot;</span>]<br>    <span class="hljs-attr">add_field</span> =&gt; &#123; <span class="hljs-string">&quot;title&quot;</span> =&gt; <span class="hljs-string">&quot;%&#123;[content][0]&#125;&quot;</span>&#125;<br>    <span class="hljs-keyword">add_field</span> =&gt; &#123; <span class="hljs-string">&quot;year&quot;</span> =&gt; <span class="hljs-string">&quot;%&#123;[content][1]&#125;&quot;</span>&#125;<br>  &#125;<br><br>  <span class="hljs-keyword">mutate</span> &#123;<br>    <span class="hljs-attr">convert</span> =&gt; &#123;<br>      <span class="hljs-string">&quot;year&quot;</span> =&gt; <span class="hljs-string">&quot;integer&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">strip</span> =&gt; [<span class="hljs-string">&quot;title&quot;</span>]<br>    remove_field =&gt; [<span class="hljs-string">&quot;path&quot;</span>, <span class="hljs-string">&quot;host&quot;</span>,<span class="hljs-string">&quot;@timestamp&quot;</span>,<span class="hljs-string">&quot;message&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>]<br>  &#125;<br><br>&#125;<br><span class="hljs-keyword">output</span> &#123;<br>   elasticsearch &#123;<br>     <span class="hljs-attr">hosts</span> =&gt; <span class="hljs-string">&quot;http://localhost:9200&quot;</span><br>     <span class="hljs-attr">index</span> =&gt; <span class="hljs-string">&quot;movies&quot;</span><br>     <span class="hljs-attr">document_id</span> =&gt; <span class="hljs-string">&quot;%&#123;id&#125;&quot;</span><br>   &#125;<br>  <span class="hljs-keyword">stdout</span> &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ./logstash -f logstash.conf<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>ELK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ELK</tag>
      
      <tag>logstash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch 简介</title>
    <link href="/2020/02/05/Elasticsearch%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/02/05/Elasticsearch%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch简介"><a href="#Elasticsearch简介" class="headerlink" title="Elasticsearch简介"></a>Elasticsearch简介</h2><h3 id="1、Elasticsearch-下载及启动"><a href="#1、Elasticsearch-下载及启动" class="headerlink" title="1、Elasticsearch 下载及启动"></a>1、Elasticsearch 下载及启动</h3><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.elastic.co<span class="hljs-regexp">/cn/</span>downloads/elasticsearch   <span class="hljs-comment"># 下载地址</span><br></code></pre></td></tr></table></figure><p>下载完成后解压进入该文件目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/elasticsearch  <span class="hljs-comment"># 启动 elasticsearch</span><br>网址输入为：localhost:9200  <span class="hljs-comment"># 查看是否启动成功</span><br></code></pre></td></tr></table></figure><h3 id="2、插件管理"><a href="#2、插件管理" class="headerlink" title="2、插件管理"></a>2、插件管理</h3><p>查看插件目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/elasticsearch-plugins list<br></code></pre></td></tr></table></figure><p>安装插件</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bin/elasticsearch-plugins </span><span class="hljs-keyword">install </span>analysis-icu<br></code></pre></td></tr></table></figure><p>如何查看插件是否安装成功</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">bin/elasticsearch <span class="hljs-comment"># 启动 elasticsearch</span><br>网址输入为：localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_cat/</span>plugins   <span class="hljs-comment"># _cat 为一个查询API</span><br></code></pre></td></tr></table></figure><h3 id="3、node-管理"><a href="#3、node-管理" class="headerlink" title="3、node 管理"></a>3、node 管理</h3><p>启动多个elasticsearch 实例</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># node.name为节点名称或实例名称   cluster.name为集群名称  path.data为存放数据路径</span><br>bin/elasticsearch -E node.<span class="hljs-attribute">name</span>=node0 -E cluster.<span class="hljs-attribute">name</span>=geektime -E path.<span class="hljs-attribute">data</span>=node0_data -d<br>bin/elasticsearch -E node.<span class="hljs-attribute">name</span>=node1 -E cluster.<span class="hljs-attribute">name</span>=geektime -E path.<span class="hljs-attribute">data</span>=node1_data -d<br></code></pre></td></tr></table></figure><p>查看 node</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">网址为：localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_cat/</span>nodes<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>ELK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ELK</tag>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>inint与 new 方法</title>
    <link href="/2019/11/20/init%20%E4%B8%8E%20new%20%E6%96%B9%E6%B3%95/"/>
    <url>/2019/11/20/init%20%E4%B8%8E%20new%20%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="init-与-new-方法"><a href="#init-与-new-方法" class="headerlink" title="__init__与 __new__ 方法"></a><code>__init__</code>与 <code>__new__</code> 方法</h2><h3 id="new-和-init-参数的不同"><a href="#new-和-init-参数的不同" class="headerlink" title="__new__和__init__参数的不同"></a><code>__new__</code>和<code>__init__</code>参数的不同</h3><p><code>__new__</code>所接收的第一个参数是<code>cls</code>，而<code>__init__</code>所接收的第一个参数是<code>self</code>。这是因为当我们调用<code>__new__</code>的时候，该类的实例还并不存在（也就是<code>self</code>所引用的对象还不存在），所以需要接收一个类作为参数，从而产生一个实例。而当我们调用<code>__init__</code>的时候，实例已经存在，因此<code>__init__</code>接受<code>self</code>作为第一个参数并对该实例进行必要的初始化操作。这也意味着<code>__init__</code>是在<code>__new__</code>之后被调用的。</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">newStyleClass</span>(<span class="hljs-title class_ inherited__">object</span>): <br>    <span class="hljs-comment"># In Python2, we need to specify the object as the base.</span><br>    <span class="hljs-comment"># In Python3 it&#x27;s default.</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;__new__ is called&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(newStyleClass, cls).__new__(cls)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;__init__ is called&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;self is: &quot;</span>, self)<br><br>n=newStyleClass()<br><span class="hljs-built_in">print</span>(n)<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">__new__ <span class="hljs-keyword">is</span> called<br>__init__ <span class="hljs-keyword">is</span> called<br>self <span class="hljs-keyword">is</span>: &lt;__main__.newStyleClass <span class="hljs-keyword">at</span> <span class="hljs-number">0</span>x109290890&gt;<br>&lt;__main__.newStyleClass <span class="hljs-keyword">at</span> <span class="hljs-number">0</span>x109290890&gt;<br></code></pre></td></tr></table></figure><p>创建类实例并初始化的过程中<code>__new__</code>和<code>__init__</code>被调用的顺序也能从上面代码的输出结果中看出：<code>__new__</code>函数首先被调用，构造了一个<code>newStyleClass</code>的实例，接着<code>__init__</code>函数在<code>__new__</code>函数返回一个实例的时候被调用，并且这个实例作为<code>self</code>参数被传入了<code>__init__</code>函数。****</p><p>这里需要注意的是，如果<code>__new__</code>函数返回一个已经存在的实例（不论是哪个类的），<code>__init__</code>不会被调用。如下面代码所示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">obj = <span class="hljs-number">12</span> <br># obj can be an <span class="hljs-keyword">object</span> from any <span class="hljs-keyword">class</span>, even <span class="hljs-keyword">object</span>.<span class="hljs-constructor">__new__(<span class="hljs-params">object</span>)</span><br><br><span class="hljs-keyword">class</span> return<span class="hljs-constructor">ExistedObj(<span class="hljs-params">object</span>)</span>:<br>    def <span class="hljs-constructor">__new__(<span class="hljs-params">cls</span>)</span>:<br>        print(<span class="hljs-string">&quot;__new__ is called&quot;</span>)<br>        return obj<br><br>    def <span class="hljs-constructor">__init(<span class="hljs-params">self</span>)</span>:<br>        print(<span class="hljs-string">&quot;__init__ is called&quot;</span>)<br><br>r=return<span class="hljs-constructor">ExistedObj()</span><br>print(r)<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">__new__ <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span><br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>同时另一个需要注意的点是：</p><p>如果我们在<code>__new__</code>函数中不返回任何对象，则<code>__init__</code>函数也不会被调用。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">notReturnObj</span>(<span class="hljs-symbol">object</span>):<br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">__new__</span>(<span class="hljs-symbol">cls</span>):<br>        <span class="hljs-symbol">print</span>(&quot;<span class="hljs-symbol">__new__</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">called</span>&quot;)<br><br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">__init__</span>(<span class="hljs-symbol">self</span>):<br>        <span class="hljs-symbol">print</span>(&quot;<span class="hljs-symbol">__init__</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">called</span>&quot;)<br><br><span class="hljs-symbol">print</span>(<span class="hljs-symbol">notReturnObj</span>())<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">__new__ <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span><br><span class="hljs-keyword">None</span><br></code></pre></td></tr></table></figure><p>可见如果<code>__new__</code>函数不返回对象的话，不会有任何对象被创建，<code>__init__</code>函数也不会被调用来初始化对象，<code>__new__</code>返回 None</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>__init__</code>不能有返回值</li><li><code>__new__</code>函数直接上可以返回别的类的实例。如上面例子中的<code>returnExistedObj</code>类的<code>__new__</code>函数返回了一个<code>int</code>值。</li><li>只有在<code>__new__</code>返回一个新创建属于该类的实例时当前类的<code>__init__</code>才会被调用.</li><li>![image-20191120105155474](&#x2F;Users&#x2F;zhangweijie&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20191120105155474.png)</li></ol>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>标准库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JWT 简介</title>
    <link href="/2019/11/09/JWT%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2019/11/09/JWT%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JWT（JSON-Web-Token）入门教程"><a href="#JWT（JSON-Web-Token）入门教程" class="headerlink" title="JWT（JSON Web Token）入门教程"></a>JWT（JSON Web Token）入门教程</h1><h2 id="1、跨域认证问题"><a href="#1、跨域认证问题" class="headerlink" title="1、跨域认证问题"></a>1、跨域认证问题</h2><p>互联网服务离不开用户认证。一般流程是下面这样。</p><blockquote><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p><p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p></blockquote><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><h3 id="1-1-传统的session-问题"><a href="#1-1-传统的session-问题" class="headerlink" title="1.1 传统的session 问题"></a>1.1 传统的session 问题</h3><p> 我们知道，http 协议本身是一种无状态协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次发起请求的时候用户还是需要再次进行用户认证才可以，因为根据 http 协议我们并不知道是哪个用户发出的请求，所以为了让我们的应用能够识别是哪个用户发起的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应的时候传递给浏览器，告诉其保存为 cookies，以便下次请求时发送给我们的应用。这样我们的应用就可以识别请求来自哪个用户，这就是传统的基于 session 的认证。</p><p>但是这种基于 session 的认证是应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这个时候基于 session 认证应用的问题就会暴露出来。</p><h3 id="1-2-基于-session-认证所显露的问题"><a href="#1-2-基于-session-认证所显露的问题" class="headerlink" title="1.2 基于 session 认证所显露的问题"></a>1.2 基于 session 认证所显露的问题</h3><ul><li><p>session：每个用户经过我们的应用认证之后，都需要在服务端进行记录，以方便用户下次请求的鉴别。通常而言session 都是保存在内存总的，而随着认证用户的增多，服务端的开销会明显增大。</p></li><li><p>扩展性：用户认证以后，服务端做认证记录，如果认证记录被保存在内存中，这意味着用户下次请求还必须要在这台服务器上，这样才能拿到授权的资源。而这样的方式在分布式应用上就会相应的限制了负载均衡的能力，也就意味着限制了应用的扩展能力。</p></li><li><p>CSRF：因为是基于cookies 进行用户识别的，cookies 如果被截获了，用户很容易受到跨站请求伪造的攻击。</p></li></ul><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h2 id="2、JWT-原理"><a href="#2、JWT-原理" class="headerlink" title="2、JWT 原理"></a>2、JWT 原理</h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-string">&quot;姓名&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-string">&quot;角色&quot;</span>: <span class="hljs-string">&quot;管理员&quot;</span>,<br>  <span class="hljs-string">&quot;到期时间&quot;</span>: <span class="hljs-string">&quot;2018年7月1日0点0分&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h2 id="3、JWT-数据结构"><a href="#3、JWT-数据结构" class="headerlink" title="3、JWT 数据结构"></a>3、JWT 数据结构</h2><p>实际的 JWT 的数据结构</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072304.jpg" alt="bg2018072304"></p><p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分：</p><blockquote><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072303.jpg" alt="bg2018072303"></p><h3 id="3-1-Header"><a href="#3-1-Header" class="headerlink" title="3.1 Header"></a>3.1 Header</h3><p>Header部分是一个 JSON对象，描述 JWT 元数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><h3 id="3-2-Payload"><a href="#3-2-Payload" class="headerlink" title="3.2 Payload"></a>3.2 Payload</h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><blockquote><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></blockquote><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-string">&quot;sub&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span>,<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>  <span class="hljs-string">&quot;admin&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h3 id="3-3-Signature"><a href="#3-3-Signature" class="headerlink" title="3.3 Signature"></a>3.3 Signature</h3><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">HMACSHA256</span>(<br>  <span class="hljs-title function_">base64UrlEncode</span>(header) + <span class="hljs-string">&quot;.&quot;</span> +<br>  <span class="hljs-title function_">base64UrlEncode</span>(payload),<br>  secret)<br></code></pre></td></tr></table></figure></blockquote><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p><h3 id="3-4-Base64URL"><a href="#3-4-Base64URL" class="headerlink" title="3.4 Base64URL"></a>3.4 Base64URL</h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com&#x2F;?token&#x3D;xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h3 id="3-5-生成过程"><a href="#3-5-生成过程" class="headerlink" title="3.5 生成过程"></a>3.5 生成过程</h3><p>头信息指定了该JWT使用的签名算法:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">header</span> = &#x27;&#123;<span class="hljs-string">&quot;alg&quot;</span>:<span class="hljs-string">&quot;HS256&quot;</span>,<span class="hljs-string">&quot;typ&quot;</span>:<span class="hljs-string">&quot;JWT&quot;</span>&#125;&#x27;<br></code></pre></td></tr></table></figure><p><code>HS256</code> 表示使用了 HMAC-SHA256 来生成签名。</p><p>消息体包含了JWT的意图：</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scilab">payload = <span class="hljs-string">&#x27;&#123;&quot;</span>loggedInAs<span class="hljs-string">&quot;:&quot;</span>admin<span class="hljs-string">&quot;,&quot;</span>iat<span class="hljs-string">&quot;:1422779638&#125;&#x27;</span><span class="hljs-comment">//iat表示令牌生成的时间</span><br></code></pre></td></tr></table></figure><p>未签名的令牌由<code>base64url</code>编码的头信息和消息体拼接而成（使用”.”分隔），签名则通过私有的key计算而成：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">key</span> = <span class="hljs-string">&#x27;secretkey&#x27;</span>  <br><span class="hljs-attr">unsignedToken</span> = encodeBase64(header) + <span class="hljs-string">&#x27;.&#x27;</span> + encodeBase64(payload)  <br><span class="hljs-attr">signature</span> = HMAC-SHA256(key, unsignedToken)<br></code></pre></td></tr></table></figure><p>最后在未签名的令牌尾部拼接上<code>base64url</code>编码的签名（同样使用”.”分隔）就是JWT了：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">token = encode<span class="hljs-constructor">Base64(<span class="hljs-params">header</span>)</span> + <span class="hljs-character">&#x27;.&#x27;</span> + encode<span class="hljs-constructor">Base64(<span class="hljs-params">payload</span>)</span> + <span class="hljs-character">&#x27;.&#x27;</span> + encode<span class="hljs-constructor">Base64(<span class="hljs-params">signature</span>)</span> <br><br># token看起来像这样: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsb2dnZWRJbkFzIjoiYWRtaW4iLCJpYXQiOjE0MjI3Nzk2Mzh9.gzSraSYS8EXBxLN_oWnFSRgCzcmJmMjLiuyu5CSpyHI<br></code></pre></td></tr></table></figure><p>JWT常常被用作保护服务端的资源（resource），客户端通常将JWT通过HTTP的<code>Authorization</code> header发送给服务端，服务端使用自己保存的key计算、验证签名以判断该JWT是否可信：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">Authorization: Bearer eyJhbGci*<span class="hljs-string">...</span>&lt;snip&gt;<span class="hljs-string">...</span>*yu5CSpyHI<br></code></pre></td></tr></table></figure><h2 id="4、JWT-的使用方式"><a href="#4、JWT-的使用方式" class="headerlink" title="4、JWT 的使用方式"></a>4、JWT 的使用方式</h2><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Authorization</span>: <span class="hljs-title class_">Bearer</span> &lt;token&gt;<br></code></pre></td></tr></table></figure></blockquote><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h2 id="5、JWT的几个特点"><a href="#5、JWT的几个特点" class="headerlink" title="5、JWT的几个特点"></a>5、JWT的几个特点</h2><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>]]></content>
    
    
    <categories>
      
      <category>认证授权</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JWT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aiohttp 模块详解</title>
    <link href="/2019/11/06/aiohttp%20%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3.md/"/>
    <url>/2019/11/06/aiohttp%20%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3.md/</url>
    
    <content type="html"><![CDATA[<h2 id="aiohttp-模块详解"><a href="#aiohttp-模块详解" class="headerlink" title="aiohttp 模块详解"></a>aiohttp 模块详解</h2><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a><strong>0. 前言</strong></h3><p>本文翻译自aiohttp的官方文档，如有纰漏，欢迎指出。</p><p>aiohttp分为服务器端和客户端，本文只介绍客户端。</p><p>另外我已经对 aiohttp 和 asyncio进行了封装，可以参考我的 github 地址：</p><p><a href="https://github.com/web-trump/ahttp">https://github.com/web-trump/ahttp</a></p><p>由于上下文的缘故，请求代码必须在一个异步的函数中进行：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>():<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h3 id="1-aiohttp安装"><a href="#1-aiohttp安装" class="headerlink" title="1. aiohttp安装"></a><strong>1. aiohttp安装</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip3 install aiohttp<br></code></pre></td></tr></table></figure><h4 id="1-1-基本请求用法"><a href="#1-1-基本请求用法" class="headerlink" title="1.1. 基本请求用法"></a><strong>1.1. 基本请求用法</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.get(<span class="hljs-string">&#x27;https://github.com&#x27;</span>) <span class="hljs-keyword">as</span> r:<br>    <span class="hljs-keyword">await</span> r.text()<br></code></pre></td></tr></table></figure><p>其中r.text(), 可以在括号中指定解码方式，编码方式，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">await</span> resp.text(encoding=<span class="hljs-string">&#x27;windows-1251&#x27;</span>)<br></code></pre></td></tr></table></figure><p>或者也可以选择不编码，适合读取图像等，是无法编码的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">await</span> resp.read()<br></code></pre></td></tr></table></figure><h3 id="2-发起一个session请求"><a href="#2-发起一个session请求" class="headerlink" title="2.发起一个session请求"></a><strong>2.发起一个session请求</strong></h3><p>首先是导入aiohttp模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiohttp<br></code></pre></td></tr></table></figure><p>然后我们试着获取一个web源码，这里以GitHub的公共Time-line页面为例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>        <span class="hljs-built_in">print</span>(resp.status)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure><p>上面的代码中，我们创建了一个 ClientSession 对象命名为session，然后通过session的get方法得到一个 ClientResponse 对象，命名为resp，get方法中传入了一个必须的参数url，就是要获得源码的http url。至此便通过协程完成了一个异步IO的get请求。</p><p>有get请求当然有post请求，并且post请求也是一个协程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=<span class="hljs-string">b&#x27;data&#x27;</span>)<br></code></pre></td></tr></table></figure><p>用法和get是一样的，区别是post需要一个额外的参数data，即是需要post的数据。</p><p>除了get和post请求外，其他http的操作方法也是一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">session.put(<span class="hljs-string">&#x27;http://httpbin.org/put&#x27;</span>, data=<span class="hljs-string">b&#x27;data&#x27;</span>)<br><br>session.delete(<span class="hljs-string">&#x27;http://httpbin.org/delete&#x27;</span>)<br><br>session.head(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>)<br><br>session.options(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>)<br><br>session.patch(<span class="hljs-string">&#x27;http://httpbin.org/patch&#x27;</span>, data=<span class="hljs-string">b&#x27;data&#x27;</span>)<br></code></pre></td></tr></table></figure><p>小记：</p><p>不要为每次的连接都创建一次session,一般情况下只需要创建一个session，然后使用这个session执行所有的请求。</p><p>每个session对象，内部包含了一个连接池，并且将会保持连接和连接复用（默认开启）可以加快整体的性能。</p><h3 id="3-在URL中传递参数"><a href="#3-在URL中传递参数" class="headerlink" title="3.在URL中传递参数"></a><strong>3.在URL中传递参数</strong></h3><p>我们经常需要通过 get 在url中传递一些参数，参数将会作为url问号后面的一部分发给服务器。在aiohttp的请求中，允许以dict的形式来表示问号后的参数。举个例子，如果你想传递 key1&#x3D;value1  key2&#x3D;value2 到 httpbin.org&#x2F;get 你可以使用下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">params = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>, params=params) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-keyword">assert</span> resp.url == <span class="hljs-string">&#x27;http://httpbin.org/get?key2=value2&amp;key1=value1&#x27;</span><br></code></pre></td></tr></table></figure><p>可以看到，代码正确的执行了，说明参数被正确的传递了进去。不管是一个参数两个参数，还是更多的参数，都可以通过这种方式来传递。除了这种方式之外，还有另外一个，使用一个 list 来传递（这种方式可以传递一些特殊的参数，例如下面两个key是相等的也可以正确传递）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">params = [(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>), (<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>)]<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>, params=params) <span class="hljs-keyword">as</span> r:<br>    <span class="hljs-keyword">assert</span> r.url == <span class="hljs-string">&#x27;http://httpbin.org/get?key=value2&amp;key=value1&#x27;</span><br></code></pre></td></tr></table></figure><p>除了上面两种，我们也可以直接通过传递字符串作为参数来传递，但是需要注意，通过字符串传递的特殊字符不会被编码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>, params=<span class="hljs-string">&#x27;key=value+1&#x27;</span>) <span class="hljs-keyword">as</span> r:<br>    <span class="hljs-keyword">assert</span> r.url == <span class="hljs-string">&#x27;http://httpbin.org/get?key=value+1&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="4-响应的内容"><a href="#4-响应的内容" class="headerlink" title="4.响应的内容"></a>4.响应的内容</h3><p>还是以GitHub的公共Time-line页面为例，我们可以获得页面响应的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure><p>运行之后，会打印出类似于如下的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;[&#123;&quot;created_at&quot;:&quot;2015-06-12T14:06:22Z&quot;,&quot;public&quot;:true,&quot;actor&quot;:&#123;...</span><br></code></pre></td></tr></table></figure><p>resp的text方法，会自动将服务器端返回的内容进行解码–decode，当然我们也可以自定义编码方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">await</span> resp.text(encoding=<span class="hljs-string">&#x27;gb2312&#x27;</span>)<br></code></pre></td></tr></table></figure><p>除了text方法可以返回解码后的内容外，我们也可以得到类型是字节的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.read())<br></code></pre></td></tr></table></figure><p>运行的结果是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">b&#x27;[&#123;&quot;created_at&quot;:&quot;2015-06-12T14:06:22Z&quot;,&quot;public&quot;:true,&quot;actor&quot;:&#123;...</span><br></code></pre></td></tr></table></figure><p>gzip和deflate转换编码已经为你自动解码。</p><p>小记：</p><p>text(),read()方法是把整个响应体读入内存，如果你是获取大量的数据，请考虑使用”字节流“（streaming response）</p><h3 id="5-特殊响应内容：json"><a href="#5-特殊响应内容：json" class="headerlink" title="5.特殊响应内容：json"></a><strong>5.特殊响应内容：json</strong></h3><p>如果我们获取的页面的响应内容是json，aiohttp内置了更好的方法来处理json:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.json())<br></code></pre></td></tr></table></figure><p>如果因为某种原因而导致resp.json()解析json失败，例如返回不是json字符串等等，那么resp.json()将抛出一个错误，也可以给json()方法指定一个解码方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.json(encoding=<span class="hljs-string">&#x27;gb2312&#x27;</span>))<br></code></pre></td></tr></table></figure><p>或者传递一个函数进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.json(<span class="hljs-keyword">lambda</span>(x:x.replace(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>))))<br></code></pre></td></tr></table></figure><h3 id="6-以字节流的方式读取响应内容"><a href="#6-以字节流的方式读取响应内容" class="headerlink" title="6.以字节流的方式读取响应内容"></a>6.以字节流的方式读取响应内容</h3><p>虽然json(),text(),read()很方便的能把响应的数据读入到内存，但是我们仍然应该谨慎的使用它们，因为它们是把整个的响应体全部读入了内存。即使你只是想下载几个字节大小的文件，但这些方法却将在内存中加载所有的数据。所以我们可以通过控制字节数来控制读入内存的响应内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-keyword">await</span> resp.content.read(<span class="hljs-number">10</span>) <span class="hljs-comment">#读取前10个字节</span><br></code></pre></td></tr></table></figure><p>一般地，我们应该使用以下的模式来把读取的字节流保存到文件中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fd:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        chunk = <span class="hljs-keyword">await</span> resp.content.read(chunk_size)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> chunk:<br>            <span class="hljs-keyword">break</span><br>        fd.write(chunk)<br></code></pre></td></tr></table></figure><h3 id="7-自定义请求头"><a href="#7-自定义请求头" class="headerlink" title="7.自定义请求头"></a><strong>7.自定义请求头</strong></h3><p>如果你想添加请求头，可以像get添加参数那样以dict的形式，作为get或者post的参数进行请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>url = <span class="hljs-string">&#x27;https://api.github.com/some/endpoint&#x27;</span><br>payload = &#123;<span class="hljs-string">&#x27;some&#x27;</span>: <span class="hljs-string">&#x27;data&#x27;</span>&#125;<br>headers = &#123;<span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;<br><span class="hljs-keyword">await</span> session.post(url, data=json.dumps(payload), headers=headers)<br></code></pre></td></tr></table></figure><h3 id="8-自定义Cookie"><a href="#8-自定义Cookie" class="headerlink" title="8.自定义Cookie"></a>8.自定义Cookie</h3><p>给服务器发送cookie，可以通过给 ClientSession 传递一个cookie参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://httpbin.org/cookies&#x27;</span><br>cookies = &#123;<span class="hljs-string">&#x27;cookies_are&#x27;</span>: <span class="hljs-string">&#x27;working&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> ClientSession(cookies=cookies) <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> resp:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">await</span> resp.json() == &#123;<span class="hljs-string">&quot;cookies&quot;</span>: &#123;<span class="hljs-string">&quot;cookies_are&quot;</span>: <span class="hljs-string">&quot;working&quot;</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p>可直接访问链接 “httpbin.org&#x2F;cookies”查看当前cookie，访问session中的cookie请见第10节。</p><h3 id="9-post数据的几种方式"><a href="#9-post数据的几种方式" class="headerlink" title="9.post数据的几种方式"></a><strong>9.post数据的几种方式</strong></h3><h4 id="（1）模拟表单post数据"><a href="#（1）模拟表单post数据" class="headerlink" title="（1）模拟表单post数据"></a>（1）模拟表单post数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=payload) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure><p>注意：data&#x3D;dict的方式post的数据将被转码，和form提交数据是一样的作用，如果你不想被转码，可以直接以字符串的形式 <strong>data&#x3D;str</strong> 提交，这样就不会被转码。</p><h4 id="（2）post-json"><a href="#（2）post-json" class="headerlink" title="（2）post json"></a>（2）post json</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>url = <span class="hljs-string">&#x27;https://api.github.com/some/endpoint&#x27;</span><br>payload = &#123;<span class="hljs-string">&#x27;some&#x27;</span>: <span class="hljs-string">&#x27;data&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(url, data=json.dumps(payload)) <span class="hljs-keyword">as</span> resp:<br>    ...<br></code></pre></td></tr></table></figure><p>其实json.dumps(payload)返回的也是一个字符串，只不过这个字符串可以被识别为json格式</p><h4 id="（3）post-小文件"><a href="#（3）post-小文件" class="headerlink" title="（3）post 小文件"></a>（3）post 小文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span><br>files = &#123;<span class="hljs-string">&#x27;file&#x27;</span>: <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;report.xls&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)&#125;<br><span class="hljs-keyword">await</span> session.post(url, data=files)<br></code></pre></td></tr></table></figure><p>可以设置好文件名和content-type:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span><br>data = FormData()<br>data.add_field(<span class="hljs-string">&#x27;file&#x27;</span>, <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;report.xls&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>), filename=<span class="hljs-string">&#x27;report.xls&#x27;</span>,<br>                content_type=<span class="hljs-string">&#x27;application/vnd.ms-excel&#x27;</span>)<br><span class="hljs-keyword">await</span> session.post(url, data=data)<br></code></pre></td></tr></table></figure><p>如果将文件对象设置为数据参数，aiohttp将自动以字节流的形式发送给服务器。</p><h4 id="（4）post-大文件"><a href="#（4）post-大文件" class="headerlink" title="（4）post 大文件"></a>（4）post 大文件</h4><p>aiohttp支持多种类型的文件以流媒体的形式上传，所以我们可以在文件未读入内存的情况下发送大文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@aiohttp.streamer</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">file_sender</span>(<span class="hljs-params">writer, file_name=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        chunk = f.read(<span class="hljs-number">2</span>**<span class="hljs-number">16</span>)<br>        <span class="hljs-keyword">while</span> chunk:<br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> writer.write(chunk)<br>            chunk = f.read(<span class="hljs-number">2</span>**<span class="hljs-number">16</span>)<br><span class="hljs-comment"># Then you can use `file_sender` as a data provider:</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=file_sender(file_name=<span class="hljs-string">&#x27;huge_file&#x27;</span>)) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure><p>同时我们可以从一个url获取文件后，直接post给另一个url，并计算hash值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">feed_stream</span>(<span class="hljs-params">resp, stream</span>):<br>    h = hashlib.sha256()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        chunk = <span class="hljs-keyword">await</span> resp.content.readany()<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> chunk:<br>            <span class="hljs-keyword">break</span><br>        h.update(chunk)<br>        stream.feed_data(chunk)<br>    <span class="hljs-keyword">return</span> h.hexdigest()<br>resp = session.get(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>)<br>stream = StreamReader()<br>loop.create_task(session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=stream))<br>file_hash = <span class="hljs-keyword">await</span> feed_stream(resp, stream)<br></code></pre></td></tr></table></figure><p>因为响应内容类型是StreamReader，所以可以把get和post连接起来，同时进行post和get：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">r = <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;http://python.org&#x27;</span>)<br><br><span class="hljs-keyword">await</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=r.content)<br></code></pre></td></tr></table></figure><h4 id="（5）post预压缩数据"><a href="#（5）post预压缩数据" class="headerlink" title="（5）post预压缩数据"></a>（5）post预压缩数据</h4><p>在通过aiohttp发送前就已经压缩的数据, 调用压缩函数的函数名（通常是deflate 或 zlib）作为content-encoding的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_coroutine</span>(<span class="hljs-params">session, headers, my_data</span>):<br>    data = zlib.compress(my_data)<br>    headers = &#123;<span class="hljs-string">&#x27;Content-Encoding&#x27;</span>: <span class="hljs-string">&#x27;deflate&#x27;</span>&#125;<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=data, headers=headers)<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>10.keep-alive, 连接池，共享cookie</p><p>ClientSession 用于在多个连接之间共享cookie：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/cookies/set?my_cookie=my_value&#x27;</span>)<br>    filtered = session.cookie_jar.filter_cookies(<span class="hljs-string">&#x27;http://httpbin.org&#x27;</span>)<br>    <span class="hljs-keyword">assert</span> filtered[<span class="hljs-string">&#x27;my_cookie&#x27;</span>].value == <span class="hljs-string">&#x27;my_value&#x27;</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/cookies&#x27;</span>) <span class="hljs-keyword">as</span> r:<br>        json_body = <span class="hljs-keyword">await</span> r.json()<br>        <span class="hljs-keyword">assert</span> json_body[<span class="hljs-string">&#x27;cookies&#x27;</span>][<span class="hljs-string">&#x27;my_cookie&#x27;</span>] == <span class="hljs-string">&#x27;my_value&#x27;</span><br></code></pre></td></tr></table></figure><p>也可以为所有的连接设置共同的请求头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession(<br>    headers=&#123;<span class="hljs-string">&quot;Authorization&quot;</span>: <span class="hljs-string">&quot;Basic bG9naW46cGFzcw==&quot;</span>&#125;) <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&quot;http://httpbin.org/headers&quot;</span>) <span class="hljs-keyword">as</span> r:<br>        json_body = <span class="hljs-keyword">await</span> r.json()<br>        <span class="hljs-keyword">assert</span> json_body[<span class="hljs-string">&#x27;headers&#x27;</span>][<span class="hljs-string">&#x27;Authorization&#x27;</span>] == <span class="hljs-string">&#x27;Basic bG9naW46cGFzcw==&#x27;</span><br></code></pre></td></tr></table></figure><p>ClientSession 还支持 keep-alive连接和连接池(connection pooling)</p><h3 id="11-cookie安全性"><a href="#11-cookie安全性" class="headerlink" title="11.cookie安全性"></a><strong>11.cookie安全性</strong></h3><p>默认ClientSession使用的是严格模式的 aiohttp.CookieJar. RFC 2109，明确的禁止接受url和ip地址产生的cookie，只能接受 DNS 解析IP产生的cookie。可以通过设置aiohttp.CookieJar 的 unsafe&#x3D;True 来配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">jar = aiohttp.CookieJar(unsafe=<span class="hljs-literal">True</span>)<br>session = aiohttp.ClientSession(cookie_jar=jar)<br></code></pre></td></tr></table></figure><h3 id="12-控制同时连接的数量（连接池）"><a href="#12-控制同时连接的数量（连接池）" class="headerlink" title="12.控制同时连接的数量（连接池）"></a>12.控制同时连接的数量（连接池）</h3><p>也可以理解为同时请求的数量，为了限制同时打开的连接数量，我们可以将限制参数传递给连接器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conn = aiohttp.TCPConnector(limit=<span class="hljs-number">30</span>) <span class="hljs-comment"># 同时最大进行连接的连接数为30，默认是100，limit=0的时候是无限制</span><br></code></pre></td></tr></table></figure><p>限制同时打开限制同时打开连接到同一端点的数量（(host, port, is_ssl) 三的倍数），可以通过设置 limit_per_host 参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conn = aiohttp.TCPConnector(limit_per_host=<span class="hljs-number">30</span>) <span class="hljs-comment"># 默认是0</span><br></code></pre></td></tr></table></figure><h3 id="13-自定义域名解析"><a href="#13-自定义域名解析" class="headerlink" title="13.自定义域名解析"></a>13.自定义域名解析</h3><p>我们可以指定域名服务器的 IP 对我们提供的get或post的url进行解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> aiohttp.resolver <span class="hljs-keyword">import</span> AsyncResolver<br>resolver = AsyncResolver(nameservers=[<span class="hljs-string">&quot;8.8.8.8&quot;</span>, <span class="hljs-string">&quot;8.8.4.4&quot;</span>])<br>conn = aiohttp.TCPConnector(resolver=resolver)<br></code></pre></td></tr></table></figure><h3 id="14-设置代理"><a href="#14-设置代理" class="headerlink" title="14.设置代理"></a><strong>14.设置代理</strong></h3><p>aiohttp支持使用代理来访问网页：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&quot;http://python.org&quot;</span>, proxy=<span class="hljs-string">&quot;http://some.proxy.com&quot;</span>) <span class="hljs-keyword">as</span> resp:<br>        <span class="hljs-built_in">print</span>(resp.status)<br></code></pre></td></tr></table></figure><p>当然也支持需要授权的页面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    proxy_auth = aiohttp.BasicAuth(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;pass&#x27;</span>)<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&quot;http://python.org&quot;</span>, proxy=<span class="hljs-string">&quot;http://some.proxy.com&quot;</span>, proxy_auth=proxy_auth) <span class="hljs-keyword">as</span> resp:<br>        <span class="hljs-built_in">print</span>(resp.status)<br></code></pre></td></tr></table></figure><p>或者通过这种方式来验证授权：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">session.get(<span class="hljs-string">&quot;http://python.org&quot;</span>, proxy=<span class="hljs-string">&quot;http://user:pass@some.proxy.com&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="15-响应状态码-response-status-code"><a href="#15-响应状态码-response-status-code" class="headerlink" title="15.响应状态码 response status code"></a>15.响应状态码 response status code</h3><p>可以通过 resp.status来检查状态码是不是200：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-keyword">assert</span> resp.status == <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h3 id="16-响应头"><a href="#16-响应头" class="headerlink" title="16.响应头"></a>16.响应头</h3><p>我们可以直接使用　resp.headers 来查看响应头，得到的值类型是一个dict：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>resp.headers<br>&#123;<span class="hljs-string">&#x27;ACCESS-CONTROL-ALLOW-ORIGIN&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br> <span class="hljs-string">&#x27;CONTENT-TYPE&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br> <span class="hljs-string">&#x27;DATE&#x27;</span>: <span class="hljs-string">&#x27;Tue, 15 Jul 2014 16:49:51 GMT&#x27;</span>,<br> <span class="hljs-string">&#x27;SERVER&#x27;</span>: <span class="hljs-string">&#x27;gunicorn/18.0&#x27;</span>,<br> <span class="hljs-string">&#x27;CONTENT-LENGTH&#x27;</span>: <span class="hljs-string">&#x27;331&#x27;</span>,<br> <span class="hljs-string">&#x27;CONNECTION&#x27;</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>或者我们可以查看原生的响应头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>resp.raw_headers<br>((<span class="hljs-string">b&#x27;SERVER&#x27;</span>, <span class="hljs-string">b&#x27;nginx&#x27;</span>),<br> (<span class="hljs-string">b&#x27;DATE&#x27;</span>, <span class="hljs-string">b&#x27;Sat, 09 Jan 2016 20:28:40 GMT&#x27;</span>),<br> (<span class="hljs-string">b&#x27;CONTENT-TYPE&#x27;</span>, <span class="hljs-string">b&#x27;text/html; charset=utf-8&#x27;</span>),<br> (<span class="hljs-string">b&#x27;CONTENT-LENGTH&#x27;</span>, <span class="hljs-string">b&#x27;12150&#x27;</span>),<br> (<span class="hljs-string">b&#x27;CONNECTION&#x27;</span>, <span class="hljs-string">b&#x27;keep-alive&#x27;</span>))<br></code></pre></td></tr></table></figure><h3 id="17-查看cookie"><a href="#17-查看cookie" class="headerlink" title="17.查看cookie"></a>17.查看cookie</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://example.com/some/cookie/setting/url&#x27;</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(resp.cookies)<br></code></pre></td></tr></table></figure><h3 id="18-重定向的响应头"><a href="#18-重定向的响应头" class="headerlink" title="18.重定向的响应头"></a><strong>18.重定向的响应头</strong></h3><p>如果一个请求被重定向了，我们依然可以查看被重定向之前的响应头信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>resp = <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;http://example.com/some/redirect/&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>resp<br>&lt;ClientResponse(http://example.com/some/other/url/) [<span class="hljs-number">200</span>]&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>resp.history<br>(&lt;ClientResponse(http://example.com/some/redirect/) [<span class="hljs-number">301</span>]&gt;,)<br></code></pre></td></tr></table></figure><h3 id="19-超时处理"><a href="#19-超时处理" class="headerlink" title="19.超时处理"></a>19.超时处理</h3><p>默认的IO操作都有<strong>5分钟的响应时间</strong> 我们可以通过 timeout 进行重写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://github.com&#x27;</span>, timeout=<span class="hljs-number">60</span>) <span class="hljs-keyword">as</span> r:<br>    ...<br></code></pre></td></tr></table></figure><p>如果 timeout&#x3D;None 或者 timeout&#x3D;0 将不进行超时检查，也就是不限时长</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aiohttp</tag>
      
      <tag>标准库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OAuth 简介</title>
    <link href="/2019/11/05/OAuth%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2019/11/05/OAuth%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="OAuth-简介"><a href="#OAuth-简介" class="headerlink" title="OAuth 简介"></a>OAuth 简介</h2><h3 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h3><p>​        OAuth2 是一个授权框架或者说是授权标准，它可以使第三方应用程序或者客户端获得对 HTTP服务上（例如 Google，GitHub 等）用户账户信息的有限访问权限。OAuth2 通过将用户身份验证委派给托管用户账户的服务以及授权客户端访问用户账户进行工作。综上，OAuth2 可以为 web 应用和桌面应用以及移动应用提供授权流程。</p><h3 id="2、角色"><a href="#2、角色" class="headerlink" title="2、角色"></a>2、角色</h3><p>​        首先介绍 OAuth2 协议中的角色，整个授权协议的流程都是围绕着这些角色：</p><ul><li><p>resource owner：资源所有者，能够允许访问瘦保护资源的实体，如果是个人则被称为 end-user</p></li><li><p>resource server：资源服务器，托管受保护资源的服务器</p></li><li><p>client：客户端，使用资源所有者的授权代表资源所有者发起对受保护资源的请求的应用程序。例如 web 应用及移动程序等</p></li><li><p>authorization server：授权服务器，能够向客户端颁发令牌</p></li><li><p>user-agent：用户代理，帮助资源所有者与客户端沟通的工具，一般为 web 浏览器、移动 APP 等</p></li></ul><p>举例说明：</p><p>我想在 CSDN网站看到一篇文章想进行评论和留言，但是评论的时候发现必须要登录以后才能留言。此时有两个选项，第一是在 CSDN注册一个新的账号然后登录去留言，第二是使用 GitHub 的账号登录然后评论留言。如果我们现在选择使用 GitHub 登录那么 OAuth2 的认证流程就开始了。此时 CSDN 相对于 GitHub 就是一个客户端，而我们使用的浏览器就是一个用户代理。当从 GitHub 授权服务器获得 token 后，CSDN 需要请求 GitHub 的张哈票信息，请求的地址就是 GitHub 的资源服务器</p><h3 id="3、授权流程"><a href="#3、授权流程" class="headerlink" title="3、授权流程"></a>3、授权流程</h3><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081120366.png" alt="img"></p><ol><li>Authrization Request<br>客户端向用户请求对资源服务器的<code>authorization grant</code>。</li><li>Authorization Grant（Get）<br>如果用户授权该次请求，客户端将收到一个<code>authorization grant</code>。</li><li>Authorization Grant（Post）<br>客户端向授权服务器发送它自己的客户端身份标识和上一步中的<code>authorization grant</code>，请求访问令牌。</li><li>Access Token（Get）<br>如果客户端身份被认证，并且<code>authorization grant</code>也被验证通过，授权服务器将为客户端派发<code>access token</code>。授权阶段至此全部结束。</li><li>Access Token（Post &amp;&amp; Validate）<br>客户端向资源服务器发送<code>access token</code>用于验证并请求资源信息。</li><li>Protected Resource（Get）<br>如果<code>access token</code>验证通过，资源服务器将向客户端返回资源信息。</li></ol><h3 id="4、客户端应用注册"><a href="#4、客户端应用注册" class="headerlink" title="4、客户端应用注册"></a>4、客户端应用注册</h3><p>在应用 OAuth 2 之前，你必须在授权方服务中注册你的应用。如 <a href="https://developers.google.com/identity/">Google Identity Platform</a> 或者 <a href="https://developer.github.com/apps/building-oauth-apps/creating-an-oauth-app/">Github OAuth Setting</a>，诸如此类 OAuth 实现平台中一般都要求开发者提供如下所示的授权设置项。</p><ul><li>应用名称</li><li>应用网站</li><li>重定向URI或回调URL</li></ul><p>重定向URI是授权方服务在用户授权（或拒绝）应用程序之后重定向供用户访问的地址，因此也是用于处理授权码或访问令牌的应用程序的一部分。</p><h4 id="4-1-Client-ID-和-Client-Secret"><a href="#4-1-Client-ID-和-Client-Secret" class="headerlink" title="4.1 Client ID 和 Client Secret"></a>4.1 Client ID 和 Client Secret</h4><p>一旦你的应用注册成功，授权方服务将以<code>client id</code>和<code>client secret</code>的形式为应用发布<code>client credentials</code>（客户端凭证）。<code>client id</code>是公开透明的字符串，授权方服务使用该字符串来标识应用程序，并且还用于构建呈现给用户的授权 url 。当应用请求访问用户的帐户时，<code>client secret</code>用于验证应用身份，并且必须在客户端和服务之间保持私有性。</p><h3 id="5、授权许可（Authorization-Grant）"><a href="#5、授权许可（Authorization-Grant）" class="headerlink" title="5、授权许可（Authorization Grant）"></a>5、授权许可（Authorization Grant）</h3><p>如上文的抽象授权流程图所示，前四个阶段包含了获取<code>authorization grant</code>和<code>access token</code>的动作。授权许可类型取决于应用请求授权的方式和授权方服务支持的 Grant Type。OAuth 2 定义了四种 Grant Type，每一种都有适用的应用场景。</p><ul><li>Authorization Code<br>结合普通服务器端应用使用。</li><li>Implicit<br>结合移动应用或 Web App 使用。</li><li>Resource Owner Password Credentials<br>适用于受信任客户端应用，例如同个组织的内部或外部应用。</li><li>Client Credentials<br>适用于客户端调用主服务API型应用（比如百度API Store）</li></ul><p>以下将分别介绍这四种许可类型的相关授权流程。</p><h4 id="5-1-授权码模式（Authorization-Code-Flow）"><a href="#5-1-授权码模式（Authorization-Code-Flow）" class="headerlink" title="5.1 授权码模式（Authorization Code Flow）"></a>5.1 授权码模式（Authorization Code Flow）</h4><p><code>Authorization Code</code> 是最常使用的一种授权许可类型，它适用于第三方应用类型为<code>server-side</code>型应用的场景。<code>Authorization Code</code>授权流程基于重定向跳转，客户端必须能够与<code>User-agent</code>（即用户的 Web 浏览器）交互并接收通过<code>User-agent</code>路由发送的实际<code>authorization code</code>值。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081121073.png" alt="img"></p><h4 id="1-User-Authorization-Request"><a href="#1-User-Authorization-Request" class="headerlink" title="1. User Authorization Request"></a>1. User Authorization Request</h4><p>首先，客户端构造了一个用于请求<code>authorization code</code>的URL并引导<code>User-agent</code>跳转访问。</p><figure class="highlight dts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//authorization-server.com/auth</span><br> ?response_<span class="hljs-attr">type</span><span class="hljs-operator">=</span>code<br> <span class="hljs-variable">&amp;client_id</span>=<span class="hljs-number">29352915982374239857</span><br> <span class="hljs-variable">&amp;redirect_uri</span>=https%<span class="hljs-number">3</span>A%<span class="hljs-number">2F</span>%<span class="hljs-number">2F</span>example-client.com%<span class="hljs-number">2F</span>callback<br> <span class="hljs-variable">&amp;scope</span>=create+delete<br> <span class="hljs-variable">&amp;state</span>=xcoiv98y2kd22vusuye3kch<br></code></pre></td></tr></table></figure><ul><li>response_type&#x3D;code<br>此参数和参数值用于提示授权服务器当前客户端正在进行<code>Authorization Code</code>授权流程。</li><li>client_id<br>客户端身份标识。</li><li>redirect_uri<br>标识授权服务器接收客户端请求后返回给<code>User-agent</code>的跳转访问地址。</li><li>scope<br>指定客户端请求的访问级别。</li><li>state<br>由客户端生成的随机字符串，步骤2中用户进行授权客户端的请求时也会携带此字符串用于比较，这是为了防止<code>CSRF</code>攻击。</li></ul><h4 id="2-User-Authorizes-Applcation"><a href="#2-User-Authorizes-Applcation" class="headerlink" title="2. User Authorizes Applcation"></a>2. User Authorizes Applcation</h4><p>当用户点击上文中的示例链接时，用户必须已经在授权服务中进行登录（否则将会跳转到登录界面，<strong>不过 OAuth 2 并不关心认证过程</strong>），然后授权服务会提示用户授权或拒绝应用程序访问其帐户。以下是授权应用程序的示例：</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081121100.png" alt="img"></p><h4 id="3-Authorization-Code-Grant"><a href="#3-Authorization-Code-Grant" class="headerlink" title="3. Authorization Code Grant"></a>3. Authorization Code Grant</h4><p>如果用户确认授权，授权服务器将重定向<code>User-agent</code>至之前客户端提供的指向客户端的<code>redirect_uri</code>地址，并附带<code>code</code>和<code>state</code>参数（由之前客户端提供），于是客户端便能直接读取到<code>authorization code</code>值。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">https://example-client.com/redirect<br> ?code=g0ZGZmNjVmOWIjNTk2NTk4ZTYyZGI3<br> &amp;<span class="hljs-keyword">state</span>=xcoiv98y2kd22vusuye3kch<br></code></pre></td></tr></table></figure><p><code>state</code>值将与客户端在请求中最初设置的值相同。客户端将检查重定向中的状态值是否与最初设置的状态值相匹配。这可以防止CSRF和其他相关攻击。</p><p><code>code</code>是授权服务器生成的<code>authorization code</code>值。<code>code</code>相对较短，通常持续1到10分钟，具体取决于授权服务器设置。</p><h4 id="4-Access-Token-Request"><a href="#4-Access-Token-Request" class="headerlink" title="4. Access Token Request"></a>4. Access Token Request</h4><p>现在客户端已经拥有了服务器派发的<code>authorization code</code>，接下来便可以使用<code>authorization code</code>和其他参数向服务器请求<code>access token</code>（POST方式）。其他相关参数如下：</p><ul><li>grant_type&#x3D;authorization_code - 这告诉服务器当前客户端正在使用<code>Authorization Code</code>授权流程。</li><li>code - 应用程序包含它在重定向中给出的授权码。</li><li>redirect_uri - 与请求<code>authorization code</code>时使用的<code>redirect_uri</code>相同。某些资源（API）不需要此参数。</li><li>client_id - 客户端标识。</li><li>client_secret - 应用程序的客户端密钥。这确保了获取<code>access token</code>的请求只能从客户端发出，而不能从可能截获<code>authorization code</code>的攻击者发出。</li></ul><h4 id="5-Access-Token-Grant"><a href="#5-Access-Token-Grant" class="headerlink" title="5. Access Token Grant"></a>5. Access Token Grant</h4><p>服务器将会验证第4步中的请求参数，当验证通过后（校验<code>authorization code</code>是否过期，<code>client id</code>和<code>client secret</code>是否匹配等），服务器将向客户端返回<code>access token</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;MTQ0NjJkZmQ5OTM2NDE1ZTZjNGZmZjI3&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bearer&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">3600</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;IwOGYzYTlmM2YxOTQ5MGE3YmNmMDFkNTVk&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;create delete&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>至此，授权流程全部结束。直到<code>access token</code> 过期或失效之前，客户端可以通过资源服务器API访问用户的帐户，并具备<code>scope</code>中给定的操作权限。</p><h4 id="5-2-Implicit-Flow"><a href="#5-2-Implicit-Flow" class="headerlink" title="5.2 Implicit Flow"></a>5.2 Implicit Flow</h4><p><code>Implicit</code>授权流程和<code>Authorization Code</code>基于重定向跳转的授权流程十分相似，但它适用于移动应用和 Web App，这些应用与普通服务器端应用相比有个特点，即<code>client secret</code>不能有效保存和信任。</p><p>相比<code>Authorization Code</code>授权流程，<code>Implicit</code>去除了请求和获得<code>authorization code</code>的过程，而用户点击授权后，授权服务器也会直接把<code>access token</code>放在<code>redirect_uri</code>中发送给<code>User-agent</code>（浏览器）。 同时第1步构造请求用户授权 url 中的<code>response_type</code>参数值也由 <em>code</em> 更改为 <em>token</em> 或 <em>id_token</em> 。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081122114.png" alt="img"></p><h4 id="1-User-Authorization-Request-1"><a href="#1-User-Authorization-Request-1" class="headerlink" title="1. User Authorization Request"></a>1. User Authorization Request</h4><p>客户端构造的URL如下所示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://&#123;yourOktaDomain&#125;.com/oauth2/default/v1/authorize?client_id=<span class="hljs-number">0</span>oabv6kx4qq6<br><span class="hljs-attribute">h1U5l0h7</span>&amp;response_type=token&amp;redirect_uri=http%<span class="hljs-number">3</span>A%<span class="hljs-number">2</span>F%<span class="hljs-number">2</span>Flocalhost%<span class="hljs-number">3</span><br><span class="hljs-attribute">A8080</span>&amp;state=state-<span class="hljs-number">296</span>bc9a0-a2a2-<span class="hljs-number">4</span>a57-be1a-d0e2fd9bb601&amp;nonce=foo&#x27;<br></code></pre></td></tr></table></figure><p><em>response_type</em>的<code>response_type</code>参数值为 <em>token</em> 或 <em>id_token</em> 。其他请求参数与<code>Authorization Code</code>授权流程相比没有并什么变化。</p><h4 id="2-User-Authorizes-Application（略）"><a href="#2-User-Authorizes-Application（略）" class="headerlink" title="2. User Authorizes Application（略）"></a>2. User Authorizes Application（略）</h4><h4 id="3-Redirect-URI-With-Access-Token-In-Fragment"><a href="#3-Redirect-URI-With-Access-Token-In-Fragment" class="headerlink" title="3. Redirect URI With Access Token In Fragment"></a>3. Redirect URI With Access Token In Fragment</h4><p>假设用户授予访问权限，授权服务器将<code>User-agent</code>（浏览器） 重定向回客户端使用之前提供的<code>redirect_uri</code>。并在 uri 的 #fragment 部分添加<code>access_token</code>键值对。如下所示：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://localhost:8080/#access_token=eyJhb</span>[<span class="hljs-string">...</span>]<span class="hljs-link">erw&amp;token_type=Bearer&amp;expires_in=3600&amp;scope=openid&amp;state=state-296bc9a0-a2a2-4a57-be1a-d0e2fd9bb601</span><br></code></pre></td></tr></table></figure><ul><li>token_type - 当且仅当<code>response_type</code>设置为 <em>token</em> 时返回，值恒为 <em>Bearer</em>。</li></ul><blockquote><p>注意在<code>Implicit</code>流程中，<code>access_token</code>值放在了 URI 的 #fragment 部分，而不是作为 ?query 参数。</p></blockquote><h4 id="4-User-agent-Follows-the-Redirect-URI"><a href="#4-User-agent-Follows-the-Redirect-URI" class="headerlink" title="4. User-agent Follows the Redirect URI"></a>4. User-agent Follows the Redirect URI</h4><p><code>User-agent</code>（浏览器）遵循重定向指令，请求<code>redirect_uri</code>标识的客户端地址，<strong>并在本地保留 uri 的 #fragment 部分的<code>access_token</code>信息</strong>。</p><h4 id="5-Application-Sends-Access-Token-Extraction-Script"><a href="#5-Application-Sends-Access-Token-Extraction-Script" class="headerlink" title="5. Application Sends Access Token Extraction Script"></a>5. Application Sends Access Token Extraction Script</h4><p>客户端生成一个包含 token 解构脚本的 Html 页面，这个页面被发送给<code>User-agent</code>（浏览器），执行脚本解构完整的<code>redirect_uri</code>并提取其中的<code>access_token</code>（<code>access token</code>信息在第4步中已经被<code>User-agent</code>保存）。</p><h4 id="6-Access-Token-Passed-to-Application"><a href="#6-Access-Token-Passed-to-Application" class="headerlink" title="6. Access Token Passed to Application"></a>6. Access Token Passed to Application</h4><p><code>User-agent</code>（浏览器）向客户端发送解构提取的<code>access token</code>。</p><p>至此，授权流程全部结束。直到<code>access token</code> 过期或失效之前，客户端可以通过资源服务器API访问用户的帐户，并具备<code>scope</code>中给定的操作权限。</p><h4 id="5-3-Resource-Owner-Password-Credentials-Flow"><a href="#5-3-Resource-Owner-Password-Credentials-Flow" class="headerlink" title="5.3 Resource Owner Password Credentials Flow"></a>5.3 Resource Owner Password Credentials Flow</h4><p><code>Resource Owner Password Credentials</code>授权流程适用于用户与客户端具有信任关系的情况，例如设备操作系统或同一组织的内部及外部应用。用户与应用交互表现形式往往体现为客户端能够直接获取用户凭据（用户名和密码，通常使用交互表单）。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081122619.png" alt="img"></p><h4 id="1-Resource-Owner-Password-Credentials-From-User-Input"><a href="#1-Resource-Owner-Password-Credentials-From-User-Input" class="headerlink" title="1. Resource Owner Password Credentials From User Input"></a>1. Resource Owner Password Credentials From User Input</h4><p>用户向客户端提供用户名与密码作为授权凭据。</p><h4 id="2-Resource-Owner-Password-Credentials-From-Client-To-Server"><a href="#2-Resource-Owner-Password-Credentials-From-Client-To-Server" class="headerlink" title="2. Resource Owner Password Credentials From Client To Server"></a>2. Resource Owner Password Credentials From Client To Server</h4><p>客户端向授权服务器发送用户输入的授权凭据以请求 <code>access token</code>。客户端必须已经在服务器端进行注册。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/token</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>server.example.com<br><span class="hljs-attribute">Authorization</span><span class="hljs-punctuation">: </span>Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><br><span class="language-dts">grant_<span class="hljs-attr">type</span><span class="hljs-operator">=</span>password<span class="hljs-variable">&amp;username</span>=johndoe<span class="hljs-variable">&amp;password</span>=A3ddj3w</span><br></code></pre></td></tr></table></figure><ul><li>grant_type - 必选项，值恒为 <em>password</em></li></ul><h4 id="3-Access-Token-Passed-to-Application"><a href="#3-Access-Token-Passed-to-Application" class="headerlink" title="3. Access Token Passed to Application"></a>3. Access Token Passed to Application</h4><p>授权服务器对客户端进行认证并检验用户凭据的合法性，如果检验通过，将向客户端派发 <code>access token</code>&gt;</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2YotnFZFEjr1zCsicMWpAA&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;example&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">3600</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;example_parameter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;example_value&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="5-4-Client-Credentials-Flow"><a href="#5-4-Client-Credentials-Flow" class="headerlink" title="5.4 Client Credentials Flow"></a>5.4 Client Credentials Flow</h4><p><code>Client Credential</code>是最简单的一种授权流程。客户端可以直接使用它的<code>client credentials</code>或其他有效认证信息向授权服务器发起获取<code>access token</code>的请求。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081122939.png" alt="img"></p><p>两步中的请求体和返回体分别如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/token</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>server.example.com<br><span class="hljs-attribute">Authorization</span><span class="hljs-punctuation">: </span>Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><br><span class="language-ini"><span class="hljs-attr">grant_type</span>=client_credentials</span><br></code></pre></td></tr></table></figure><ul><li>grant_type - 必选项，值恒为 <em>client_credentials</em></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>       <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2YotnFZFEjr1zCsicMWpAA&quot;</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;example&quot;</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">3600</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-attr">&quot;example_parameter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;example_value&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>首先我们需要明确的是，即使用户刚登录过 GitHub，CSDN 也不可能向 GitHub 随便发一个请求就能拿到访客信息，这显然是不安全的。就算用户允许你获取他在 GitHub 上的信息，但是 GitHub 为了保护用户的信息安全，也不会让你随意获取。所以在操作之前，CSDN 与 GitHub 之间需要有一个协商。</p><p>####3.1 网站和 GitHub 之间的协商</p><p>GitHub 会对用户的权限进行分类，比如读取仓库信息的权限，写入仓库的权限，读取用户信息的权限，修改用户信息的权限等。如果我想获取用户的信息，GitHub 会要求我现在他的平台上注册一个应用，在申请的时候标明需要获取用户的哪些权限，用多少就申请多少，并且在申请的时候填写你的网站域名，GitHub 只会允许在这个域名中获取用户信息。</p><p>此时 CSDN 已经和 GitHub 之间达成了共识，GitHub 也会发给 CSDN 两张门票，一张是clientID，另一张是clientSecrect</p><h4 id="3-2-用户与-GitHub-之间的协商"><a href="#3-2-用户与-GitHub-之间的协商" class="headerlink" title="3.2 用户与 GitHub 之间的协商"></a>3.2 用户与 GitHub 之间的协商</h4><p>用户进入网站后，点击 GitHub 登录按钮的时候，CSDN 会将第一步拿到的 clientID 交给用户，让他进入到 GitHub 的授权页面，GitHub 看到用户手中的 clientID 会知道CSDN 是被允许获取信息的，于是 GitHub 将 CSDN 想要获取的权限罗列出来，并询问用户是否允许 CSDN 获取这些权限</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 用户登录 github，协商<br>GET https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/login/</span>oauth/authorize<br><br><span class="hljs-regexp">//</span> 协商凭证<br>params = &#123;<br>  client_id: <span class="hljs-string">&quot;xxxx&quot;</span>,<br>  redirect_uri: <span class="hljs-string">&quot;http://my-website.com&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果用户觉得 CSDN 网站想要的权限太多了，或者用户压根就不想让 CSDN 获取信息，选择了拒绝的话，整个 OAuth2的认证就结束了，认证也以失败告终。如果用户觉得 OK 的话，在授权页面点击确认授权后，页面就会跳转到我预先设定的’redirect_url’并附带一个盖了章的门票 code</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 协商成功后带着盖了章的 code<br>Location: http:<span class="hljs-regexp">//my</span>-website.com?code=xxx<br></code></pre></td></tr></table></figure><p>这个时候用户和 GitHub 之间的协商也就完成了，GitHub 会在自己的系统中记录此次协商，标识该用户已经允许在GitHub 进行访问、操作和使用关于用户的部分资源</p><h4 id="3-3-告诉-GitHub，CSDN-要来拜访了"><a href="#3-3-告诉-GitHub，CSDN-要来拜访了" class="headerlink" title="3.3 告诉 GitHub，CSDN 要来拜访了"></a>3.3 告诉 GitHub，CSDN 要来拜访了</h4><p>在第二步中，CSDN 已经拿到了盖过章的门票code，但是这个 code 只能表明，用户允许 CSDN 从 GitHub 上获取用户的数据，如果我直接拿这个 code 去 GitHub 访问数据一定会被拒绝，因为任何人都可以持有 code，GitHub 不知道 code 持有方就是 CSDN</p><p>还记得之前申请应用的时候 GitHub给的两张门票，clientID 已经使用过了，接下来就轮到 clientSecrect</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 网站和 github 之间的协商<br>POST https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/login/</span>oauth/access_token<br><br><span class="hljs-regexp">//</span> 协商凭证包括 github 给用户盖的章和 github 发给我的门票<br>params = &#123;<br>  code: <span class="hljs-string">&quot;xxx&quot;</span>,<br>  client_id: <span class="hljs-string">&quot;xxx&quot;</span>,<br>  client_secret: <span class="hljs-string">&quot;xxx&quot;</span>,<br>  redirect_uri: <span class="hljs-string">&quot;http://my-website.com&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>拿着用户盖过章的 code 和能够标识个人身份的 clientID、clientSecrect 去拜访 GitHub，拿到最后的绿卡 access_token</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// 拿到最后的绿卡</span><br><span class="hljs-attr">response</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  access_token:</span> <span class="hljs-string">&quot;e72e16c7e42f292c6912e7710c838347ae178b4a&quot;</span><br><span class="hljs-symbol">  scope:</span> <span class="hljs-string">&quot;user,gist&quot;</span><br><span class="hljs-symbol">  token_type:</span> <span class="hljs-string">&quot;bearer&quot;</span>,<br><span class="hljs-symbol">  refresh_token:</span> <span class="hljs-string">&quot;xxxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-4-用户使用-GitHub-在-CSDN-留言"><a href="#3-4-用户使用-GitHub-在-CSDN-留言" class="headerlink" title="3.4 用户使用 GitHub 在 CSDN 留言"></a>3.4 用户使用 GitHub 在 CSDN 留言</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 访问用户数据<br>GET https:<span class="hljs-regexp">//</span>api.github.com/user<br>?access_token=e72e16c7e42f292c6912e7710c838347ae178b4a<br></code></pre></td></tr></table></figure><p>上一步 github 已经把最后的绿卡 access_token 给我了，通过 github 提供的 API 加绿卡就能够访问用户的信息了，能获取用户的哪些权限在 response 中也给了明确的说明，scope 为 user 和 gist，也就是只能获取 user 组和 gist 组两个小组的权限，user 组中就包含了用户的名字和邮箱等信息了。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// 告诉我用户的名字和邮箱</span><br><span class="hljs-attr">response</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  username:</span> <span class="hljs-string">&quot;barretlee&quot;</span>,<br><span class="hljs-symbol">  email:</span> <span class="hljs-string">&quot;barret.china@gmail.com&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>值得一看的文章：</p><p><a href="https://learnku.com/articles/20082">https://learnku.com/articles/20082</a></p><p><a href="https://learnku.com/articles/20031">https://learnku.com/articles/20031</a></p>]]></content>
    
    
    <categories>
      
      <category>认证授权</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OAuth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentry 入门</title>
    <link href="/2019/10/18/Sentry%20%E5%85%A5%E9%97%A8/"/>
    <url>/2019/10/18/Sentry%20%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Sentry-入门"><a href="#Sentry-入门" class="headerlink" title="Sentry 入门"></a>Sentry 入门</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        错误日志监控也可称为业务逻辑监控，旨在对业务系统运行过程中产生的错误日志进行收集收纳和监控告警。Sentry 所做的就是收集应用底层代码的崩溃信息，便于我们排除代码异常。</p><h3 id="既有方案"><a href="#既有方案" class="headerlink" title="既有方案"></a>既有方案</h3><ol><li>单台服务器上每个系统服务自己维护自己的日志，方便自己查看</li><li>同台服务器上多个日志集中存放到同个目录，方便集中管理</li><li>使用 ELK 系统，将所有日志输出到 ELK 系统，使用 GUI 进行管理展示</li></ol><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ol><li><p>无法第一时间感知错误</p><p>脚本日志的拉取不是实时的，web端用户的反馈也存在滞后的问题，从出现问题到解决问题周期会很长，容易是工作陷入被动</p></li><li><p>错误信息的获取比较低效</p><p>用户反馈的信息及可能有的邮件报警信息都非常有限且不够准确，最终开发人员还是得在日志文件中大量的翻看上下文查看关联信息。更困难的是错误不能重现的话，还需要不断埋点测试去获取变量数据，十分难以定位问题。</p></li><li><p>日志处理方式不够灵活</p><p>通常来说，除了程序运行出错，我们也比较关心其他异常情况，比如数据污染，非法请求，第三方 API 调用异常等等。如果将辞了等同错误全部记录下来，很容易就会使告警信息泛滥，无法及时获得有效信息。但是如果不处理此类异常，迟早会导致严重问题。所以我们需要对不同的日志内容有不同的处理方式，相同的日志内容也可以根据不同的业务场景进行不同的处理。</p></li><li><p>监控覆盖面有限</p><p>完整的监控应该是包含脚本，前端以及后端的，但是当前后端分离以后，很多前端的问题无法被统一记录下来</p></li></ol><h3 id="Sentry-基本介绍"><a href="#Sentry-基本介绍" class="headerlink" title="Sentry 基本介绍"></a>Sentry 基本介绍</h3><p>Sentry 是一个现代化的错误日志记录以及聚合平台。支持几乎所有的主流开发语言及平台，并提供现代化 UI。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129977.png" alt="image-20191017165847184"></p><ol><li><p>优势</p><p>接入 Sentry 前；</p><ul><li>用户A: 发布功能用不了</li><li>开发者A: 哪个页面? 截个图</li><li>用户A: (发截图)</li><li>开发者A发现bug可以重现, 登录服务器查看错误日志, 确认程序逻辑无问题, 查看数据库数据, 发现有脏数据. 联系开发者B检查负责更新数据的python脚本C.py.</li><li>开发者B登录服务器查看错误日志, 发现一个逻辑错误导致脚本罢工, 已持续了一个小时. 影响了数千条数据</li></ul><p>接入 Sentry 后：</p><ul><li>开发者A,B同时收到邮件告警, 一分钟前脚本C.py异常退出.</li><li>开发者B进入sentry后台查看错误信息, 定位问题并将其修复, 再清理受影响的数十条数据.</li><li>在此过程中没有用户受到影响, 无需开发者A介入</li></ul></li><li><p>概念</p><ul><li><p>event</p><p>可操作数据的基本单位，每一次日志输出就会产生一个 event。event并不一定是错误，如果日志级别设置的很低，那么后台就会产生非常多的 event，所以正确的设置日志的级别 非常的重要。</p></li><li><p>issue</p><p>同意类 event 的聚合，某一个错误可能因为重复执行而被记录多次，在 sentry系统会自动聚合到一起，方便处理，通常我们操作的对象也就是 issue。</p></li><li><p>DNS</p><p>DNS 及时客户端密匙，用来进行客户端和服务端的通信。DNS 是一个 URL，包含一个公匙，一个私匙，项目标记及服务器地址（<a href="https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7%EF%BC%89">https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7）</a></p></li><li><p>raven</p><p>整个错误日志监控系统包含客户端和服务端，Sentry 是服务端的名称，客户端名称为 Raven，需要两者配合才能工作。</p></li></ul></li><li><p>创建项目流程</p><ol><li><p>登录 Sentry 系统</p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129682.png" alt="image-20191024093908660" style="zoom:50%;" /></li><li><p>点击创建项目</p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129297.png" alt="image-20191024094042431" style="zoom:50%;" /></li><li><p>选择框架</p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129370.png" alt="image-20191024094257179" style="zoom:50%;" /></li><li><p>根据指示下载安装包并进行配置</p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129961.png" alt="image-20191024095325581" style="zoom:50%;" /></li></ol><p>在 flask 中的配置有两种方式，可以自由选择</p><p>第一种：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">from raven.contrib.flask import Sentry<br>sentry = <span class="hljs-constructor">Sentry()</span><br>sentry.init<span class="hljs-constructor">_app(<span class="hljs-params">app</span>,<span class="hljs-params">dsn</span>=<span class="hljs-string">&quot;https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7&quot;</span>,<span class="hljs-params">logging</span>=True, <span class="hljs-params">level</span>=<span class="hljs-params">logging</span>.ERROR)</span><br></code></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> sentry_sdk<br><span class="hljs-keyword">from</span> sentry_sdk.<span class="hljs-built_in">int</span>egrations.flask <span class="hljs-keyword">import</span> FlaskIntegration<br>sentry_sdk.init(dsn=<span class="hljs-string">&quot;https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7&quot;</span>,<br><span class="hljs-built_in">int</span>egrations=[FlaskIntegration()])<br></code></pre></td></tr></table></figure><h3 id="gunicorn-与-Sentry-结合配置"><a href="#gunicorn-与-Sentry-结合配置" class="headerlink" title="gunicorn 与 Sentry 结合配置"></a>gunicorn 与 Sentry 结合配置</h3><p>使用 yaml 文件进行 logging 配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Logging configuration</span><br><br><span class="hljs-section">[loggers]</span><br><span class="hljs-attr">keys</span> = root, gunicorn.access, gunicorn.error<br><br><span class="hljs-section">[handlers]</span><br><span class="hljs-attr">keys</span> = access, error, sentry<br><br><span class="hljs-section">[formatters]</span><br><span class="hljs-attr">keys</span> = json, generic<br><br><span class="hljs-comment"># Root logger</span><br><span class="hljs-comment"># The root logger sends messages to the console and to Sentry.</span><br><span class="hljs-section">[logger_root]</span><br><span class="hljs-attr">handlers</span> = error, sentry<br><br><span class="hljs-comment"># Gunicorn loggers</span><br><span class="hljs-comment"># Gunicorn logging is configured with two loggers: &#x27;gunicorn.access&#x27; and &#x27;gunicorn.error&#x27;.</span><br><span class="hljs-comment"># The access log is sent to stdout and the error log is sent to stderr, both without propagation.</span><br><span class="hljs-comment"># Only the critical logger has a handler to send messages to Sentry.</span><br><br><span class="hljs-section">[logger_gunicorn.access]</span><br><span class="hljs-attr">handlers</span> = access<br><span class="hljs-attr">qualname</span> = gunicorn.access<br><span class="hljs-attr">level</span> = INFO<br><span class="hljs-attr">propagate</span> = <span class="hljs-number">0</span><br><br><span class="hljs-section">[logger_gunicorn.error]</span><br><span class="hljs-attr">handlers</span> = error, sentry<br><span class="hljs-attr">qualname</span> = gunicorn.error<br><span class="hljs-attr">level</span> = ERROR<br><span class="hljs-attr">propagate</span> = <span class="hljs-number">0</span><br><br><span class="hljs-section">[handler_access]</span><br><span class="hljs-attr">class</span> = StreamHandler<br><span class="hljs-attr">formatter</span> = json<br><span class="hljs-attr">args</span> = (sys.stdout,)<br><br><span class="hljs-section">[handler_error]</span><br><span class="hljs-attr">class</span> = StreamHandler<br><span class="hljs-attr">formatter</span> = json<br><span class="hljs-attr">args</span> = (sys.stderr,)<br><br><span class="hljs-section">[handler_sentry]</span><br><span class="hljs-attr">class</span> = raven.handlers.logging.SentryHandler<br><span class="hljs-attr">level</span> = CRITICAL<br><span class="hljs-attr">formatter</span> = generic<br><span class="hljs-attr">args</span> = (<span class="hljs-string">&quot;https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7&quot;</span>,)<br><br><span class="hljs-section">[formatter_generic]</span><br><span class="hljs-attr">format</span> = [bs-whatweb][%(levelname)s] [%(name)s]: %(message)s<br><span class="hljs-section">[formatter_json]</span><br><span class="hljs-attr">class</span> = project.api.utils.logger.JSONFormatter<br></code></pre></td></tr></table></figure></li></ol><h3 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h3><p>Sentry 官方还提供了 Docker 镜像以及<a href="https://github.com/docker-library/docs/blob/master/sentry/variant-onbuild.md">部署方案</a>，用起来非常方便。</p><ol><li>首先安装并启动 Docker 服务，然后拉取最新的 Sentry 镜像：<code>docker pull sentry</code>。</li><li>启动一个 redis 服务作为消息 broker：<code>docker run -d --name sentry-redis redis</code></li><li>设置数据库密码作为环境变量，之后的命令都会用到：<code>export DBPW=&#39;&lt;your-postgres-db-password&gt;&#39;</code></li><li>启动一个 Postgres 数据库服务作为存储数据库：<code>docker run -d --name sentry-postgres -e POSTGRES_PASSWORD=&#39;$(DBPW)&#39; -e POSTGRES_USER=sentry postgres</code>，这里推荐使用 Volume 将数据库文件单独挂载出来。</li><li>migrate 数据库结构至最新：<code>docker run -it --rm -e SENTRY_SECRET_KEY=&#39;$(DBPW)&#39; --link sentry-postgres:postgres --link sentry-redis:redis sentry upgrade</code></li><li>启动 Sentry 服务并链接以上服务: <code>docker run -d --name sentry-app -e SENTRY_SECRET_KEY=&#39;$(DBPW)&#39; --link sentry-redis:redis --link sentry-postgres:postgres -p 8080:9000 sentry</code></li><li>运行一个 cron 容器用于定时任务：<code>docker run -d --name sentry-cron -e SENTRY_SECRET_KEY=&#39;$(DBPW)&#39; --link sentry-postgres:postgres --link sentry-redis:redis sentry run cron</code></li><li>运行一个 worker 容器用于后台任务：<code>docker run -d --name sentry-worker-1 -e SENTRY_SECRET_KEY=&#39;$(DBPW)&#39; --link sentry-postgres:postgres --link sentry-redis:redis sentry run worker</code></li></ol><p>如果没有什么错误发生，使用 <code>docker ps</code> 命令将会得到 <code>sentry-app</code>、<code>sentry-posgres</code>、<code>sentry-redis</code>、<code>sentry-cron</code>、<code>sentry-worker-1</code> 5 个正在运行的容器。</p>]]></content>
    
    
    <categories>
      
      <category>监控预警</category>
      
      <category>Sentry</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sentry</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda 安装</title>
    <link href="/2019/07/31/Anaconda/"/>
    <url>/2019/07/31/Anaconda/</url>
    
    <content type="html"><![CDATA[<h3 id="Anaconda-安装"><a href="#Anaconda-安装" class="headerlink" title="Anaconda 安装"></a>Anaconda 安装</h3><ul><li>下载安装包: 官网, 清华源等</li><li>推荐下载python3 (Anaconda3) 版本</li><li>按照安装程序提示一步步安装就好了, 安装完成之后会多几个应用<ul><li><p><strong>Anaconda Navigtor</strong> ：用于管理工具包和环境的图形用户界面，后续涉及的众多管理命令也可以在 Navigator 中手工实现。</p></li><li><p><strong>Jupyter notebook</strong> ：基于web的交互式计算环境，可以编辑易于人们阅读的文档，用于展示数据分析的过程。</p></li><li><p><strong>qtconsole</strong> ：一个可执行 IPython 的仿终端图形界面程序，相比 Python Shell 界面，qtconsole 可以直接显示代码生成的图形，实现多行代码输入执行，以及内置许多有用的功能和函数。</p></li><li><p><strong>spyder</strong> ：(可选) 一个使用Python语言、跨平台的、科学运算集成开发环境。</p></li></ul></li></ul><h3 id="更改conda默认的下载源"><a href="#更改conda默认的下载源" class="headerlink" title="更改conda默认的下载源"></a>更改conda默认的下载源</h3><ul><li>更改为清华源 <figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/<br>conda config --<span class="hljs-built_in">set</span> show_channel_urls <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><h5 id="Conda-三方源"><a href="#Conda-三方源" class="headerlink" title="Conda 三方源"></a>Conda 三方源</h5></li><li>Conda Forge<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/<br></code></pre></td></tr></table></figure></li><li>msys2<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/<br></code></pre></td></tr></table></figure></li><li>bioconda<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/<br></code></pre></td></tr></table></figure></li><li>menpo<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/<br></code></pre></td></tr></table></figure></li><li>pytorch <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/<br><br><span class="hljs-comment"># for legacy win-64</span><br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/peterjc123/<br></code></pre></td></tr></table></figure></li></ul><h3 id="管理虚拟环境"><a href="#管理虚拟环境" class="headerlink" title="管理虚拟环境"></a>管理虚拟环境</h3><p>   接下来我们就可以用anaconda来创建我们一个个独立的python环境了.接下来的例子都是在命令行操作的,请打开你的命令行吧.</p><ul><li><p><strong>activate</strong></p><ul><li>activate 能将我们引入anaconda设定的虚拟环境中, 如果你后面什么参数都不加那么会进入anaconda自带的base环境</li><li>你可以输入python试试, 这样会进入base环境的python解释器, 如果你把原来环境中的python环境去除掉会更能体会到, 这个时候在命令行中使用的已经不是你原来的python而是base环境下的python.而命令行前面也会多一个(base) 说明当前我们处于的是base环境下.</li></ul></li><li><p><strong>创建自己的虚拟环境</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda create -n virtual_name python=3<br></code></pre></td></tr></table></figure></li><li><p><strong>查看所有的虚拟环境</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> list<br></code></pre></td></tr></table></figure></li><li><p><strong>激活虚拟环境</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda activate virtual_name<br></code></pre></td></tr></table></figure></li><li><p><strong>切回默认环境 &#x2F; 反激活虚拟环境</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda deactivate<br></code></pre></td></tr></table></figure></li><li><p><strong>查看当前环境模块&#x2F;包</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda list<br></code></pre></td></tr></table></figure></li><li><p><strong>安装一个模块&#x2F;包</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda instal numpy<br></code></pre></td></tr></table></figure></li><li><p><strong>卸载一个模块&#x2F;包</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda remove numpy<br></code></pre></td></tr></table></figure></li><li><p><strong>更新一个模块&#x2F;包</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda update numpy<br></code></pre></td></tr></table></figure></li><li><p><strong>删除一个环境及其下所有包</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda remove -n virtual_name --all<br></code></pre></td></tr></table></figure></li><li><p><strong>导出当前环境的包信息</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> <span class="hljs-built_in">export</span> &gt; environment.yaml<br></code></pre></td></tr></table></figure></li><li><p><strong>用配置文件创建新的虚拟环境</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> create -f environment.yaml<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
      <category>Anaconda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Anaconda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac 安装 ruby</title>
    <link href="/2019/06/25/Mac%20osx%20%E5%AE%89%E8%A3%85%20ruby/"/>
    <url>/2019/06/25/Mac%20osx%20%E5%AE%89%E8%A3%85%20ruby/</url>
    
    <content type="html"><![CDATA[<h3 id="安装CocoaPods第一步"><a href="#安装CocoaPods第一步" class="headerlink" title="安装CocoaPods第一步"></a>安装CocoaPods第一步</h3><p><strong>起因:重装系统后需要重新安装CocoaPods网上搜了下发现很多都过时了，已经不能用了。而且taobao Gems源已经停止服务，现在有ruby-china提供服务PS：”$”开头表示需要在终端下执行</strong></p><h3 id="1-安装RVM"><a href="#1-安装RVM" class="headerlink" title="1.安装RVM"></a>1.安装RVM</h3><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">curl -L https://get.rvm.io | bash -s stable</span><br></code></pre></td></tr></table></figure><p><strong>期间可能需要输入密码(我安装时没有提示，密码就是开机密码输入时密码不会显示直接输入完成就可以)，等待一段时间将安装好(大概五六分钟)。</strong><br><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081128066.png" alt="安装RVM"></p><h3 id="2-载入RVM环境"><a href="#2-载入RVM环境" class="headerlink" title="2.载入RVM环境"></a>2.载入RVM环境</h3><p><strong>若打开新终端窗口则不用执行</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ <span class="hljs-keyword">source</span> ~<span class="hljs-regexp">/.rvm/</span>scripts/rvm<br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081128763.png" alt="载入RVM环境"></p><h3 id="3-检查RVM是否安装好"><a href="#3-检查RVM是否安装好" class="headerlink" title="3.检查RVM是否安装好"></a>3.检查RVM是否安装好</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm -v</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081128518.png" alt="img"></p><h3 id="4-安装Ruby"><a href="#4-安装Ruby" class="headerlink" title="4.安装Ruby"></a>4.安装Ruby</h3><p>##### 1&gt;列出已知的ruby版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm list known</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081128428.png" alt="列出已知的ruby版本"></p><h5 id="2-gt-选择2-0-0版本进行安装-其他版本也可以"><a href="#2-gt-选择2-0-0版本进行安装-其他版本也可以" class="headerlink" title="2&gt;选择2.0.0版本进行安装(其他版本也可以)"></a>2&gt;选择2.0.0版本进行安装(其他版本也可以)</h5><p><strong>等待下载(途中需要按回车确定安装路径、还要输入密码)、编译。完成之后Ruby、Ruby Gems就安装好了</strong><br><code>$ rvm install 2.6</code><br><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081128625.png" alt="选择2.0.0版本进行安装"></p><h5 id="3-gt-查询已安装的ruby"><a href="#3-gt-查询已安装的ruby" class="headerlink" title="3&gt;查询已安装的ruby"></a>3&gt;查询已安装的ruby</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm list</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129344.png" alt="查询已安装的ruby"></p><h5 id="4-gt-卸载已安装的版本-若已经安装过ruby）"><a href="#4-gt-卸载已安装的版本-若已经安装过ruby）" class="headerlink" title="4&gt;卸载已安装的版本(若已经安装过ruby）"></a>4&gt;卸载已安装的版本(若已经安装过ruby）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm remove [版本号]</span><br></code></pre></td></tr></table></figure><h3 id="4-设置Ruby版本"><a href="#4-设置Ruby版本" class="headerlink" title="4.设置Ruby版本"></a>4.设置Ruby版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm 2.6 —default</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129237.png" alt="设置Ruby版本"><br><strong>检查是否安装好了</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm -v</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129101.png" alt="检查"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">gem -v</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129235.png" alt="检查"></p><h3 id="5-更换Ruby源"><a href="#5-更换Ruby源" class="headerlink" title="5.更换Ruby源"></a>5.更换Ruby源</h3><p><strong>我们需要来修改更换Ruby源，国内镜像源 taobao 源 已经停止维护了（由于国内被墙）所以要把源切换至ruby-china</strong></p><h5 id="1-gt-检测Ruby源"><a href="#1-gt-检测Ruby源" class="headerlink" title="1&gt;检测Ruby源"></a>1&gt;检测Ruby源</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">gem sources -l</span><br></code></pre></td></tr></table></figure><p><strong>检查结果：（ 如果电脑没安装过 CocoaPods，此时应该是默认 ruby 源 ）</strong><br><code>huanghaipoMacBook-Pro:~ jijiucheng$ gem sources -l *** CURRENT SOURCES *** https://rubygems.org/</code></p><h4 id="2-gt-移除-ruby-源"><a href="#2-gt-移除-ruby-源" class="headerlink" title="2&gt;移除 ruby 源"></a>2&gt;移除 ruby 源</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">gem sources --remove https://rubygems.org/</span><br></code></pre></td></tr></table></figure><h4 id="3-gt-移除结果："><a href="#3-gt-移除结果：" class="headerlink" title="3&gt;移除结果："></a>3&gt;移除结果：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">huanghaipoMacBook-Pro:local jijiucheng$ gem sources --remove https://rubygems.org/<br>https://rubygems.org/ removed from sources<br></code></pre></td></tr></table></figure><p><strong>替换添加国内镜像源 ruby-china 源，因为上面已经提到国内镜像源 taobao 源 已经停止维护了，所以此处替换的是 ruby-china 源，且尽量确保只有一个 ruby-china 源</strong><br><code>$ gem sources --add https://gems.ruby-china.org</code></p><h4 id="4-gt-替换结果："><a href="#4-gt-替换结果：" class="headerlink" title="4&gt;替换结果："></a>4&gt;替换结果：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">huanghaipoMacBook-Pro:local jijiucheng$ gem sources --add https://gems.ruby-china.com<br>https://gems.ruby-china.org added to sources<br></code></pre></td></tr></table></figure><h4 id="5-gt-再次检查此时的-ruby-源：（-已经变成了-ruby-china-源-）"><a href="#5-gt-再次检查此时的-ruby-源：（-已经变成了-ruby-china-源-）" class="headerlink" title="5&gt;再次检查此时的 ruby 源：（ 已经变成了 ruby-china 源 ）"></a>5&gt;再次检查此时的 ruby 源：（ 已经变成了 ruby-china 源 ）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">huanghaipoMacBook-Pro:local jijiucheng$ gem sources -l<br>*** CURRENT SOURCES ***<br>https://gems.ruby-china.com<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>ruby</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ruby</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web 指纹识别杂论</title>
    <link href="/2019/06/24/web%20%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E6%9D%82%E8%AE%BA/"/>
    <url>/2019/06/24/web%20%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E6%9D%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>##前言</p><p>在 web 渗透过程中，对目标网站的指纹识别非常关键，通过工具或者手工识别 CMS系统是自建的还是二次开发，还是直接使用公开的CMS 程序至关重要。通过获取的这些信息来决定后续渗透的思路和策略。CMS 指纹识别是渗透测试环节的一个非常重要的阶段，是信息收集的中的一个关键环节。</p><h2 id="1-指纹识别技术简介及思路"><a href="#1-指纹识别技术简介及思路" class="headerlink" title="1. 指纹识别技术简介及思路"></a>1. 指纹识别技术简介及思路</h2><h3 id="1-1-指纹识别技术"><a href="#1-1-指纹识别技术" class="headerlink" title="1.1 指纹识别技术"></a>1.1 指纹识别技术</h3><p>组件是网络空间最小的单元，Web应用程序、数据库、中间件等都属于组件。指纹是组件上能标识对象类型的一段特征信息，用来在渗透测试信息收集环节中快熟识别目标服务。互联网随时代的发展逐渐成熟，大批应用组件存在足以说明当前服务名称和版本的特征，识别这些特征获取当前服务信息，也表明该系统采用那个公司的产品，例如论坛常用 Discuz!来搭建，通过其 robots.txt 等可以识别网站程序是采用 Discuz！</p><h3 id="1-2-指纹识别思路"><a href="#1-2-指纹识别思路" class="headerlink" title="1.2 指纹识别思路"></a>1.2 指纹识别思路</h3><p>指纹识别可以铜鼓哦一些开源程序和小工具来进行扫描，也有可以结合文件头和反馈信息进行手工判断，指纹识别主要思路：</p><p>（1）使用工具自动判断</p><p>（2）手工对网站的关键字、版权信息、后台登录、程序版本、robots.txt 等常见固有文件进行识别、查找和比对，相同文件具有相同的 MD5 值和相同的属性。</p><h2 id="2-指纹识别方式"><a href="#2-指纹识别方式" class="headerlink" title="2.  指纹识别方式"></a>2.  指纹识别方式</h2><p>基于对指纹识别方式的各种套路和分析，可以分为以下几个类别：</p><h3 id="2-1-基于特殊文件的-MD5-值匹配"><a href="#2-1-基于特殊文件的-MD5-值匹配" class="headerlink" title="2.1 基于特殊文件的 MD5 值匹配"></a>2.1 基于特殊文件的 MD5 值匹配</h3><p>基于web网站独有的favicon.ico、css、logo.ico、js等文件的md5 比对网站类型，通过收集CMS公开代码中的独有文件，这些文件一般轻易不会更改，通过爬虫对这些文件进行抓取并比对md5值，如果一样，则认为该系统匹配。这种识别速度最快，但可能不准确，因为这些独有文件可能在部署到真实系统中会进行更改，那么就会造成很大的误差。</p><p>（1）robots.txt文件识别</p><p>相关厂商下的cms（内容管理系统）程序文件包含说明当前cms名称及版本的特征码，其中一些独有的文件夹以及名称都是识别cms的好方法，如Discuz官网下robots.txt文件。dedecms官网<a href="http://www.dedecms.com/robots.txt%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%EF%BC%9A">http://www.dedecms.com/robots.txt文件内容：</a></p><p>Disallow: &#x2F;plus&#x2F;feedback_js.php</p><p>Disallow: &#x2F;plus&#x2F;mytag_js.php</p><p>Disallow: &#x2F;plus&#x2F;rss.php</p><p>Disallow: &#x2F;plus&#x2F;search.php</p><p>Disallow: &#x2F;plus&#x2F;recommend.php</p><p>Disallow: &#x2F;plus&#x2F;stow.php</p><p>Disallow: &#x2F;plus&#x2F;count.php</p><p>看到这个基本可以判断为dedecms。</p><p>2）计算机md5值</p><p>计算网站所使中间件或cms目录下静态文件的md5值，md5码可以唯一地代表原信息的特征。静态文件包括html、js、css、image等，建立在站点静态文件存在的情况下访问，如 Dedecms 官网下网站根目录<a href="http://www.dedecms.com/img/buttom_logo.gif%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%9C%89%E4%B8%80%E4%BA%9B%E5%85%AC%E5%BC%80%E7%A8%8B%E5%BA%8F%EF%BC%8C%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AEcms.txt%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%BA%94%E5%80%BC%E8%BF%9B%E8%A1%8C%E8%AF%86%E5%88%AB%EF%BC%8C%E5%A6%82%E5%9B%BE1%E6%89%80%E7%A4%BA%E3%80%82">http://www.dedecms.com/img/buttom_logo.gif图片文件，目前有一些公开程序，通过配置cms.txt文件中的相应值进行识别，如图1所示。</a></p><h3 id="2-2-请求相应主体内容或头信息的关键字匹配"><a href="#2-2-请求相应主体内容或头信息的关键字匹配" class="headerlink" title="2.2 请求相应主体内容或头信息的关键字匹配"></a>2.2 请求相应主体内容或头信息的关键字匹配</h3><p>请求响应主体内容或头信息的关键字匹配方法可以寻找网站的css 、js代码的命名规则，也可以找关键字，以及head cookie等等，但是弊端是收集这些规则会耗费很久的时间。</p><h3 id="2-3-基于-URL-关键字识别"><a href="#2-3-基于-URL-关键字识别" class="headerlink" title="2.3 基于 URL 关键字识别"></a>2.3 基于 URL 关键字识别</h3><p>基于爬虫爬出来的网站目录比对web信息，准确性比较高，但是如果改了目录结构就会造成问题，而且一部分网站有反爬虫机制，会造成一些困扰</p><h3 id="2-4-基于-TCP-x2F-IP-请求协议识别服务指纹"><a href="#2-4-基于-TCP-x2F-IP-请求协议识别服务指纹" class="headerlink" title="2.4 基于 TCP&#x2F;IP 请求协议识别服务指纹"></a>2.4 基于 TCP&#x2F;IP 请求协议识别服务指纹</h3><p> 一些应用程序、组建和数据库服务会有一些特殊的指纹，一般情况下不会进行更改。网络上的通信交互均通过TCP&#x2F;TP协议簇进行，操作系统也必须实现该协议。操作系统根据不同数据包做出不同反应。如Nmap检测操作系统工具通过向目标主机发送协议数据包并分析其响应信息进行操作系统指纹识别工作，其扫描命令为“nmap –O 192.168.1.1”。</p><h3 id="2-5-在owasp中识别Web应用框架测试方法"><a href="#2-5-在owasp中识别Web应用框架测试方法" class="headerlink" title="2.5 在owasp中识别Web应用框架测试方法"></a>2.5 在owasp中识别Web应用框架测试方法</h3><p>（1）http头。查看http响应报头的X-Powered-By字段来识别，可以通过netcat来识别，使用netcat 127.0.0.1 80对127.0.0.1主机的80端口web服务器框架进行识别。</p><p>（2）Cookies。一些框架有固定的Cookies名称，这些名称一般情况都不会更改，例如zope3、cakephp、kohanasesson、laravel_session。</p><p>（3）Html源代码。html源代码中包含注释、js、css等信息，通过访问这些信息来判断和确认cms系统框架。在源代码中常常会包含powered by、bulit upon、running等特征。</p><p>（4）特殊文件和文件夹</p>]]></content>
    
    
    <categories>
      
      <category>安全研究</category>
      
      <category>指纹识别</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指纹识别</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

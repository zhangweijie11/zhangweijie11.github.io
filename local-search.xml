<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用 Ettercap嗅探工具进行 DNS 欺骗实验</title>
    <link href="/2022/03/01/%E4%BD%BF%E7%94%A8%20Ettercap%E5%97%85%E6%8E%A2%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%20DNS%20%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C/"/>
    <url>/2022/03/01/%E4%BD%BF%E7%94%A8%20Ettercap%E5%97%85%E6%8E%A2%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%20DNS%20%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="使用-Ettercap嗅探工具进行-DNS-欺骗实验"><a href="#使用-Ettercap嗅探工具进行-DNS-欺骗实验" class="headerlink" title="使用 Ettercap嗅探工具进行 DNS 欺骗实验"></a>使用 Ettercap嗅探工具进行 DNS 欺骗实验</h1><blockquote><p>前提条件：需要安装<code>kali 虚拟机</code>，或者自己安装<code>ettercap 工具</code></p><p>涉及服务器：本地服务器（172.30.0.56）、kali 虚拟机（172.30.0.133）、网关（172.30.0.1，172.30.0.254）</p></blockquote><h2 id="一、实验名称"><a href="#一、实验名称" class="headerlink" title="一、实验名称"></a>一、实验名称</h2><p><strong>DNS欺骗</strong></p><h2 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a>二、实验原理</h2><p>冒充域名服务器，将查询的 IP 地址设置为攻击者的 IP 地址，这样用户上网就只能看到攻击者主主页，而不是用户访问的真实的页面。</p><p><strong>正常情况</strong></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281509294.png" alt="image-20220228141758055"></p><p><strong>异常情况</strong></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281509975.png" alt="image-20220228141830850"></p><h2 id="三、实验步骤"><a href="#三、实验步骤" class="headerlink" title="三、实验步骤"></a>三、实验步骤</h2><h3 id="1、清除攻击机和靶机的-DNS-缓存数据"><a href="#1、清除攻击机和靶机的-DNS-缓存数据" class="headerlink" title="1、清除攻击机和靶机的 DNS 缓存数据"></a>1、清除攻击机和靶机的 DNS 缓存数据</h3><ul><li><p>MAC系统</p><figure class="highlight ebnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo killall -HUP mDNSResponder</span><br><span class="hljs-attribute">sudo dscacheutil -flushcache</span><br></code></pre></td></tr></table></figure></li><li><p>Windows 系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看 DNS 缓存内容</span><br>ipconfig/displaydns<br><span class="hljs-comment"># 清除 DNS 缓存内容</span><br>ifconfig /flushdns<br></code></pre></td></tr></table></figure></li><li><p>Linux 系统</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># Step 1. 查看 DNS 缓存状况</span><br>sudo systemd-<span class="hljs-built_in">resolve</span> <span class="hljs-comment">--statistics</span><br><br><span class="hljs-comment"># Step 2. 清除 DNS 缓存，systemd-resolve daemon 默认在所有的 Ubuntu 系统上运行</span><br>sudo systemd-<span class="hljs-built_in">resolve</span> <span class="hljs-comment">--flush-caches</span><br><br><span class="hljs-comment"># Step 3. 正在查看验证结果（SYSIN）</span><br>sudo systemd-<span class="hljs-built_in">resolve</span> <span class="hljs-comment">--statistics</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2、修改相关-DNS-文件（攻击机）"><a href="#2、修改相关-DNS-文件（攻击机）" class="headerlink" title="2、修改相关 DNS 文件（攻击机）"></a>2、修改相关 DNS 文件（攻击机）</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 输入命令</span><br><span class="hljs-attribute">vim</span> /etc/ettercap/etter.dns<br><span class="hljs-comment"># 添加内容</span><br>*  A   <span class="hljs-number">172.30.0.133</span><br>*  PTR <span class="hljs-number">172.30.0.133</span><br></code></pre></td></tr></table></figure><h3 id="3、开启自带的-Apache-服务"><a href="#3、开启自带的-Apache-服务" class="headerlink" title="3、开启自带的 Apache 服务"></a>3、开启自带的 Apache 服务</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 开启服务</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">service </span>apache2 start<br><br><span class="hljs-comment"># 查询状态</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">service </span>apache2 status<br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281455623.png" alt="image-20220228145536734"></p><h3 id="4、开启-ettercap-图形界面"><a href="#4、开启-ettercap-图形界面" class="headerlink" title="4、开启 ettercap 图形界面"></a>4、开启 ettercap 图形界面</h3><ul><li><p>方式一</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ettercap -G</span><br></code></pre></td></tr></table></figure></li><li><p>方式二</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281432316.png" alt="image-20220228143217106"></p></li></ul><h3 id="5、选择网卡"><a href="#5、选择网卡" class="headerlink" title="5、选择网卡"></a>5、选择网卡</h3><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281433117.png" alt="image-20220228143315708"></p><h3 id="6、扫描网关下的所有存活主机"><a href="#6、扫描网关下的所有存活主机" class="headerlink" title="6、扫描网关下的所有存活主机"></a>6、扫描网关下的所有存活主机</h3><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281435479.png" alt="image-20220228143537655"></p><p><strong>扫描结果</strong></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281436063.png" alt="image-20220228143633113"></p><h3 id="7、选择攻击目标"><a href="#7、选择攻击目标" class="headerlink" title="7、选择攻击目标"></a>7、选择攻击目标</h3><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281438910.png" alt="image-20220228143810935"></p><h3 id="8、开启-ARP-投毒"><a href="#8、开启-ARP-投毒" class="headerlink" title="8、开启 ARP 投毒"></a>8、开启 ARP 投毒</h3><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281439827.png" alt="image-20220228143935749"></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281440789.png" alt="image-20220228143959644"></p><h3 id="9、使用插件开启-DNS-欺骗"><a href="#9、使用插件开启-DNS-欺骗" class="headerlink" title="9、使用插件开启 DNS 欺骗"></a>9、使用插件开启 DNS 欺骗</h3><p>Plugins –&gt; manage plugins –&gt; dns spoof</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281440797.png" alt="image-20220228144057221"></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281442111.png" alt="image-20220228144218575"></p><h3 id="10、验证结果"><a href="#10、验证结果" class="headerlink" title="10、验证结果"></a>10、验证结果</h3><p><strong>当发生 DNS 欺骗后，靶机请求的数据都会在 ettercap 工具中展示出来！</strong></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281451243.png" alt="image-20220228145135214"></p><p><strong>此时靶机再去请求数据时，页面就会显示我们预想的 Apache 的默认页面！</strong></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281456734.png" alt="image-20220228145652393"></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202202281457571.png" alt="image-20220228145726419"></p>]]></content>
    
    
    <categories>
      
      <category>安全研究</category>
      
      <category>域名知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS 欺骗</tag>
      
      <tag>安全工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓存穿透、缓存击穿、缓存雪崩</title>
    <link href="/2022/01/27/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"/>
    <url>/2022/01/27/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-缓存穿透、缓存击穿、缓存雪崩"><a href="#Redis-缓存穿透、缓存击穿、缓存雪崩" class="headerlink" title="Redis - 缓存穿透、缓存击穿、缓存雪崩"></a>Redis - 缓存穿透、缓存击穿、缓存雪崩</h1><h2 id="为啥要有缓存"><a href="#为啥要有缓存" class="headerlink" title="为啥要有缓存"></a>为啥要有缓存</h2><p> 每次请求数据，都直接达到数据库上，数据库受不了，所以得在请求和数据库中间加个缓冲带。这个缓冲带需要非常快，所以就放在内存中，和 CPU 离得近，数据拷贝等操作会很快。然后就先抵挡一部分请求，直接在缓存中就能获取到部分数据，如果没命中缓存再去数据库查，也能减少很大一部分请求，尤其是针对热点数据，能减少 80%以上的请求。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>有个黑客，一直用 <code>id=-1</code>这个条件来不断向服务发起请求，但是这个 id 在数据库中并不存在，不断的发起请求，请求就会穿过缓存落在数据库中，由数据库来进行查询，这就是缓存穿透！缓存穿透无法避免，只能尽量避免高频的缓存穿透。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="1、创建空缓存对象"><a href="#1、创建空缓存对象" class="headerlink" title="1、创建空缓存对象"></a>1、创建空缓存对象</h4><p>当请求在缓存中未被命中，同时在数据库中也没有查询到数据，则直接创建一个空的缓存对象，当相同的恶意请求再次高并发袭来，可以直接使用空的缓存对象。不过这有个问题，就是一旦 id 被批量的增加或者减少，都是你数据库不存在的数据，那就会创建非常多无效的缓存数据，压垮内存。</p><h4 id="2、使用布隆过滤器"><a href="#2、使用布隆过滤器" class="headerlink" title="2、使用布隆过滤器"></a>2、使用布隆过滤器</h4><p>Bloom Filter过滤器是一个占用空间很小，效率很高的随机数据结构，由一个 bit 数组和一组 hash 算法构成，可以用于判断一个元素是否在一个集合中，查询效率很高，并且内存占用也很小。</p><p>布隆过滤器也存在hash 碰撞问题，会有一定的错误率。但是针对一个数据，布隆过滤器说存在不一定存在，但是布隆过滤器说不存在那就一定不存在。一旦被判定缓存数据不存在了，那就直接查询数据库创建缓存数据就可以。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><p>当你出现缓存穿透的情况后，一旦高并发的请求过来，会造成缓存击穿的情况。缓存击穿其实是缓存穿透的一种特殊表现。</p><p>例如微博的例子，某明星的热点数据，平时常规访问，但是一旦发布了结婚等劲爆消息后，会有非常多的吃瓜群众涌现出来去访问同一个热点数据，一旦这个热点数据过期失效后，就会将所有请求打到数据库上，直接把数据库拖垮。</p><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="1、热点数据永不过期"><a href="#1、热点数据永不过期" class="headerlink" title="1、热点数据永不过期"></a>1、热点数据永不过期</h4><p>将热点数据设置为永不过期，那么就不会出现缓存击穿的情况，但是会大量占用内存，并且一旦数据库的数据有了变化，没有及时更新到缓存中，就会出现数据不一致的情况。所以需要一种方法来保证缓存和数据库的强一致性，如果业务对于数据的一致性要求不高，保持弱一致性也可以。</p><h4 id="2、分布式锁"><a href="#2、分布式锁" class="headerlink" title="2、分布式锁"></a>2、分布式锁</h4><p>分布式的业务访问同一个 redis，达到分布式锁的目的。所有线程竞争锁资源，一个线程拿到锁资源以后，如果热点数据过期或者被删除了，重新访问数据库拿到数据然后进行缓存，释放锁以后再次竞争到锁资源的线程就能直接访问缓存数据了。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><p>缓存雪崩也是缓存穿透的一种特殊表现，一个明星宣布劲爆消息后一个热点数据过期或者被删除可能会导致缓存击穿，好几个甚至上百个明星同时宣布了劲爆消息然后这些热点数据都同时过期或者被删除，那缓存就直接血崩了，超高并发的请求打到了数据库中，数据库当场崩溃。</p><p>还有一种情况，redis 服务直接崩溃了，那所有的请求也会直接打到数据库上，导致数据库崩溃。</p><h3 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="1、热点数据设置随机过期时间"><a href="#1、热点数据设置随机过期时间" class="headerlink" title="1、热点数据设置随机过期时间"></a>1、热点数据设置随机过期时间</h4><p>热点数据设置随机过期时间，保证不会出现大批量热点数据同时失效、过期或者被删除的情况出现。</p><h4 id="2、redis-集群"><a href="#2、redis-集群" class="headerlink" title="2、redis 集群"></a>2、redis 集群</h4><p>没有什么是加机器解决不了的，如果有那就继续加。所以为了防止单个redis 服务挂掉拖累整个服务，直接搞个 redis 集群，一个挂了还有另外的可以继续使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述的问题都是很典型的缓存问题，也同时提出了解决办法，但是解决办法都是针对单个情况去解决问题，还会出现其他的衍生问题，所以需要同时去解决衍生问题。比如创建了非常多的空缓存对象，这个时候需要有一个线程去监控这些缓存对象，并进行删除。或者创建的空缓存对象设置比较短的过期时间，也可以让 redis 自己去删除。方法多种多样，可以根据实际情况去选择使用哪一种。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内核态和用户态解析</title>
    <link href="/2022/01/27/%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/01/27/%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="内核态和用户态解析"><a href="#内核态和用户态解析" class="headerlink" title="内核态和用户态解析"></a>内核态和用户态解析</h1><blockquote><p>首先需要明确用户态和内核态分别是什么，然后再去想为什么需要有这两个事物。</p></blockquote><h2 id="CPU-指令集权限"><a href="#CPU-指令集权限" class="headerlink" title="CPU 指令集权限"></a>CPU 指令集权限</h2><p>在说用户态和内核态之前，有必要说一下 CPU 指令集。指令集是值 CPU 实现软件指挥硬件执行的媒介，具体来说就是每一条汇编语句都对应了一条 CPU 指令，非常多的 CPU 指令组合在一起，就是一个或者多个指令的集合，这就是指令集。</p><p>存在指令集以后我们可以直接通过 CPU 指令去操作硬件了，但是可能出现指令操作不规范或者一些其他原因出现指令错误直接导致整个机器都崩溃。这是因为能直接操作 CPU 指令集这个事情的权限太大了，所以需要针对程序员开发人员去收回大部分权限，在 CPU 指令集之上再次抽象封装一层，既可以隐藏CPU 指令集，又可以让程序开发者关注逻辑业务的实现，而不需要去关注底层指令的执行。</p><p>针对上边的情况，硬件设备商直接提供硬件级别的支持，对 CPU 指令设置了权限，不同的权限可以使用不同的 CPU 指令集，以 intel 为例，CPU指令集操作的权限被分为四层：</p><ul><li>ring 0</li><li>ring 1</li><li>ring 2</li><li>ring 3</li></ul><p>其中 ring 0 权限最高，可以使用所有的 CPU 指令集去操作所有硬件设备。ring 3权限最低，仅能使用常规的 CPU 指令集，不能使用操作硬件资源的指令集，例如网卡访问，申请内存，硬盘访问等。</p><p><strong>注意：Linux 仅仅采用 ring 0 和 ring 3这两个权限级别</strong></p><h2 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h2><ul><li>内核态</li></ul><p>ring 0 就是内核态，完全在操作系统中运行。执行内核空间的代码，拥有 ring 0 的保护级别，拥有对硬件资源的全部操作权限，可以执行全部的 CPU指令集，访问任何地址的内存。在内核模式下运行的任何异常都是灾难级别的，将会导致整台机器崩溃。</p><ul><li>用户态</li></ul><p>ring 3 就是用户态，在用户模式下，拥有 ring 3 的保护级别。代码美欧对硬件的直接控制权限，也不能直接访问地址的内存，需要调用系统接口来达到访问硬件和内存的目的。在这种保护模式下，即使程序发生崩溃也是可以恢复的，大部分电脑都是在用户模式下运行的。</p><ul><li>两者区别</li></ul><p>用户态和内核态概念其实就是 CPU 指令集权限的区别，进程中需要读写 IO，必然会涉及到 ring 0 级别的指令集，但此时只有 ring 3 级别，所以为了能够操作 ring 0 级别的指令集，CPU 需要切换指令集操作权限到 ring 0 级别，然后再执行相应的 ring 0 级别的 CPU 指令集（内核代码），执行的内核代码会使用当前进程的内核栈。</p><p><strong>每个进程都有两个栈，分别是内核栈和用户栈，对用内核态和用户态使用。</strong></p><ul><li>内存空间使用</li></ul><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202201271447730.png" alt="image-20220127144738388"></p><p>用户态：只能操作 0-3G 范围的地位虚拟空间地址</p><p>内核态：0-4G 范围的虚拟空间地址都可以操作，尤其是 3-4G 的高位虚拟空间地址只能由内核态去操作</p><p>3-4G 的高位虚拟空间地址是共享的，所有的进程的内核态逻辑地址都是同一块内存地址，这里存放整个内核的代码和所有的内核模块，以及内核维护的数据。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过指令集权限区分内核态和用户态，还限制了内存资源的使用，操作系统为内核态和用户态划分了两块内存空间，让那对应的指令集使用。</p><h2 id="内核态和用户态切换"><a href="#内核态和用户态切换" class="headerlink" title="内核态和用户态切换"></a>内核态和用户态切换</h2><h3 id="内核态和用户态切换的需要做什么？"><a href="#内核态和用户态切换的需要做什么？" class="headerlink" title="内核态和用户态切换的需要做什么？"></a>内核态和用户态切换的需要做什么？</h3><ul><li>保留用户态现场（上下文、寄存器、用户栈等）</li><li>复制用户态参数，用户栈切换到内核栈，进入内核态</li><li>额外的检查（内核代码对于用户不信任）</li><li>执行内核态代码</li><li>复制内核态代码执行结果，返回用户态</li><li>恢复用户态现场（上下文、寄存器、用户栈等）</li></ul><p><strong>一图说明一切</strong></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202201271457284.png" alt="image-20220127145658628"></p><h3 id="什么时候切换？"><a href="#什么时候切换？" class="headerlink" title="什么时候切换？"></a>什么时候切换？</h3><ol><li>系统调用：用户态进程主动切换到内核态的方式，用户态进程通过系统调用向操作系统申请资源完成工作，例如 <code>fork()</code> 就是一个创建新进程的系统调用，系统调用的机制核心使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断，也可以称为软中断</li><li>异常：当 CPU 在执行用户态的进程时，发生了一些没有预知的异常，这时当前运行进程会切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常</li><li>中断：当 CPU 在执行用户态的进程时，外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令，转到与中断信号对应的处理程序去执行，也就是切换到了内核态。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。</li></ol><h3 id="为什么开销大？"><a href="#为什么开销大？" class="headerlink" title="为什么开销大？"></a>为什么开销大？</h3><p>其实就是来回复制数据，另外保留恢复现场需要的时间和资源比较多！</p><h2 id="用户态线程"><a href="#用户态线程" class="headerlink" title="用户态线程"></a>用户态线程</h2><p>用户态线程也叫做用户级线程，操作系统不知道它的存在，它完全是在用户空间中创建的。</p><p>用户态线程优势：</p><ul><li><strong>管理开销小</strong>：创建、销毁不需要系统调用</li><li><strong>切换成本低</strong>：用户空间程序可以自己维护，不需要走操作系统调度</li></ul><p>用户态线程劣势：</p><ul><li><strong>与内核协作成本高</strong>：线程完全在用户空间程序管理，一旦需要进行 I&#x2F;O 操作的时候无法利用到内核的优势，需要频繁的进行用户态到内核态的切换</li><li><strong>线程间协作成本高</strong>：例如两个线程进行通信的时候，需要进行 I&#x2F;O，而 I&#x2F;O需要进行系统调用，所以需要负担系统调用的资源消耗</li><li><strong>无法利用多核优势</strong>：操作系统进行调度的时候始终是调度线程所属的进程，所以不论每一个进程有多少用户态的线程，都只能被并发调用一个线程执行</li><li><strong>操作系统无法针对线程调度进行优化</strong>：当一个进程的一个用户态线程阻塞后，操作系统无法及时发现和处理阻塞问题，不会调度其他的线程去执行</li></ul><h2 id="内核态线程"><a href="#内核态线程" class="headerlink" title="内核态线程"></a>内核态线程</h2><p>内核态线程也叫做内核级线程，在内核态中执行，通过系统调用可以创建一个内核态线程</p><p>内核态线程优势：</p><ul><li><strong>可以利用多核 CPU</strong>：内核由操作系统调度，可以在多个 CPU 核上执行</li><li><strong>操作系统级优化</strong>：内核中的线程操作 I&#x2F;O 不需要进行系统调用，一个线程阻塞了，可以立刻调度另外一个线程执行</li></ul><p>内核态线程劣势：</p><ul><li><strong>创建成本高</strong>：创建的时候需要进行系统调用，也就是切换到内核态</li><li><strong>扩展性差</strong>：一个内核程序管理，数量不多</li><li><strong>切换成本高</strong>：切换的时候在内核中操作，需要切换到内核态</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>网络知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSI 七层模型</title>
    <link href="/2022/01/26/OSI%20%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/01/26/OSI%20%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081048799.png" alt="img"></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081048140.png" alt="img"></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081048210.png" alt="img"></p><p>互联网的本质就是一系列的网络协议，这个协议就叫OSI协议（一系列协议），按照功能不同，分工不同，人为的分层七层。实际上这个七层是不存在的。没有这七层的概念，只是人为的划分而已。区分出来的目的只是让你明白哪一层是干什么用的。</p><p>每一层都运行不同的协议。协议是干什么的，协议就是标准。</p><p>实际上还有人把它划成五层、四层。</p><p>七层划分为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p><p>五层划分为：应用层、传输层、网络层、数据链路层、物理层。</p><p>四层划分为：应用层、传输层、网络层、网络接口层。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081048217.png" alt="img"></p><p>物理层：</p><p>字面意思解释：物理传输、硬件、物理特性。在深圳的你与北京的朋友聊天，你的电脑必须要能上网，物理体现是什么？是不是接一根网线，插个路由器，北京的朋友那边是不是也有根网线，也得插个路由器。也就是说计算机与计算机之间的通信，必须要有底层物理层方面的连通，就类似于你打电话，中间是不是必须得连电话线。</p><p>中间的物理链接可以是光缆、电缆、双绞线、无线电波。中间传的是电信号，即010101…这些二进制位。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081049431.png" alt="img"></p><p>底层传输的010010101001…这些二级制位怎么才能让它有意义呢？</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081049462.png" alt="img"></p><p>要让这些010010101001…有意思，人为的分组再适合不过了，8位一组，发送及接收都按照8位一组来划分。接收到8位为一组的话，那么就可以按照这8位数来做运算。如果没有分组，对方接收的计算机根本就不知道从哪一位开始来做计算，也解析不了收到的数据。我发了16位你就按照16位来做计算吗？我发100位你就按照100位做计算吗？没什么意义是吧。因此要想让底层的电信号有意义，必须要把底层的电信号做分组。我做好8位一组，那么我收到数据，我就知道这几个8位做一组，这几个8位做一组。那么每个8位就可以得到一个确定的数。分组是谁干的活呢？物理层干不了，这个是数据链路层干的。</p><p>数据链路层</p><p>早期的时候，数据链路层就是来对电信号来做分组的。以前每个公司都有自己的分组方式，非常的乱，后来形成了统一的标准（标准就是协议），即以太网协议Ethernet。</p><p>Ethernet规定</p><p>一组电信号称之为一个数据包，或者叫做一个“帧”</p><p>每一数据帧分成：报头head和数据data两部分</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081049503.png" alt="img"></p><p>head包含：（固定18个字节）</p><p>发送者（源地址，6个字节）<br>接收者（目标地址，6个字节）<br>数据类型（6个字节）<br>data包含：（最短46字节，最长1500字节）</p><p>数据包的具体内容<br>head长度+data长度&#x3D;最短64字节，最长1518字节，超过最大限制就分片发送。</p><p>这就像写信，发送者的地址（源地址）就是你家的地址，接收者地址（目标地址）就是对方的收信地址，你家的路由器就相当于邮局。其实在计算机通信中的源地址和目标地址指的是mac地址。</p><p>Mac地址的由来：</p><p>head中包含的源和目标地址由来：Ethernet规定接入Internet的设备都必须具备网卡，发送端的和接收端的地址便是指网卡的地址，即Mac地址。</p><p>每块网卡出厂时都被烧录上一个实际上唯一的Mac地址，长度为48位2进制，通常由12位16进制数表示，（前六位是厂商编码，后六位是流水线号）</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081049473.png" alt="img"></p><p>有了mac地址以后，计算机就可以通信了，假设一个教室就是一个局域网（隔离的网络），这个教室里面有几台计算机，计算机的通信和人的通信是一个道理，把教室里面的人都比作一个个计算机，假设教室里面的人都是瞎子，其实计算机就是瞎子的，计算机通信基本靠吼，现在我要找教室里面的飞哥要战狼2的片，然后我就吼一声，说我要找飞哥要战狼2的片，战狼2的片就属于我的数据，但是我在发的时候我是不是要标识我是谁，我要找谁，我是谁就是我的mac地址，我要找谁就是飞哥的mac地址，这两个地址做数据包的头部，再加上数据战狼2的片就构成了一个数据帧。</p><p>这个数据包封装好以后就往外发，到物理层以后就全部转成二级制，往外发是怎么发的呢？就是靠吼。即“我是Edison，我找飞哥要战狼2的片”。这么吼了一嗓子以后，全屋子的人都能听到，这就是广播。</p><p>计算机底层，只要在一个教室里（一个局域网），都是靠广播的方式，吼。</p><p>局域网的理解：什么是互联网，互联网就是由一个个局域网组成，局域网内的计算机不管是对内还是对外都是靠吼，这就是数据链路层的工作方式—–广播。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081049002.png" alt="img"></p><p>广播出去以后，所有人都听得见，所有人都会拆开这个包，读发送者是谁，接收者是谁，只要接收者不是自己就丢弃掉。对计算机来说，它会看自己的Mac地址，飞哥收到以后，他就会把片发给我，发送回来同样采用广播的方式了，靠吼。</p><p>同一个教室（同一个局域网）的计算机靠吼来通信，那不同教室的计算机又如何？</p><p>比如说局域网1的pc1与局域网2的pc10如何通信？你在教室1（局域网1）吼，教室2（局域网2）的人肯定是听不见的。这就是跨网络进行通信，数据链路层就解决不了这个问题了，这就得靠网络层出面了。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081049603.png" alt="img"></p><p>在讲网络层之前，其实基于广播的这种通信就可以实现全世界通信了，你吼一声，如果全世界是一个局域网，全世界的计算机肯定可以听得见，从理论上似乎行得通，如果全世界的计算机都在吼，你想一想，这是不是一个灾难。因此，全世界不能是一个局域网。于是就有了网络层。</p><p>网络层：</p><p>网络层定义了一个IP协议，</p><p>你想，我是这个教室的一个学生，我想找隔壁教室一个叫老王的学生，我也不认识老王，那怎么办，我吼？老王在另外一个教室肯定是听不到的。找教室的负责人，这个教室的负责人就负责和隔壁教室的负责人说话，说我们教室的有个学生要找你们教室的老王。往外传的东西交给负责人就可以了，内部的话上面已经提到，通过广播的方式，对外的东西广播失效。教室的负责人就是网关，网关即网络关口的意思。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081049458.png" alt="img"></p><p>Mac地址是用来标识你这个教室的某个位置，IP地址是用来标识你在哪个教室（哪个局域网）。你要跨网络发包你是不是要知道对方的IP地址，比如你要访问百度，你肯定得知道百度服务器的IP地址。计算机在发包前，会判断你在哪个教室，对方在哪个教室，如果在一个教室，基于mac地址的广播发包就OK了；如果不在一个教室，即跨网络发包，那么就会把你的包交给教室负责人（网关）来转发。Mac地址及IP地址唯一标识了你在互联网中的位置。</p><p>数据链路层中会把网络层的数据包封装到数数据链路层的数据位置，然后再添加上自己的包头，再发给物理层，物理层发给网关，网关再发给对方教室的网关，对方教室的网关收到后在那个教室做广播。</p><p>在数据链路层看，数据封装了两层，跟玩俄罗斯套娃有点类似，一层套了一层。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081049955.png" alt="img"></p><p>最终变成</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081049781.png" alt="img"></p><p>现在来看另一个问题，在吼之前怎么知道对方的Mac地址？这就得靠ARP协议。</p><p>ARP协议的由来：在你找飞哥要片之前，你的先干一件事，想办法知道飞哥的Mac地址。即你的机器必须先发一个ARP包出去，ARP也是靠广播的方式发，ARP发送广播包的方式如下：</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081049974.png" alt="img"></p><p>局域网中怎么获取对方的Mac地址：</p><p>肯定要知道对方的IP地址，这是最基本的，就像你要访问百度，肯定得知道百度的域名，域名就是百度的IP地址。自己的IP可以轻松获得，自己的Mac也轻松获取，目标Mac为12个F，我们叫广播地址，表达的意思是我想要获取这个目标IP地址172.16.10.11的机器的Mac地址。Mac为12个F代表的是一种功能，这个功能就是获取对方的MAC地址，计算机的Mac永远不可能是12个F。假设是在本教室广播，一嗓子吼出去了，所有人开始解包，只有IP地址是172.16.10.11的这个人才会返回他的Mac地址，其他人全部丢弃。发回来源Mac改成飞哥自己的Mac地址，同时把飞哥的Mac地址放在数据部分。</p><p>跨网络怎么获取对方的Mac地址：</p><p>通过IP地址区分，计算机运算判断出飞哥不在同一个教室，目标IP就变成了网关的IP了。网关的IP在计算机上配死了，可以轻松获取。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081049074.png" alt="img"></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081049187.png" alt="img"></p><p>这样网关就会把它的Mac地址返回给你，然后正常发包</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081049366.png" alt="img"></p><p>网关帮你去找飞哥，但对用户来说，我们根本就感觉不到网关的存在。</p><p>传输层</p><p>传输层的由来：网络层的ip帮我们区分子网，以太网层的mac帮我们找到主机，然后大家使用的都是应用程序，你的电脑上可能同时开启qq，暴风影音，等多个应用程序，</p><p>那么我们通过ip和mac找到了一台特定的主机，如何标识这台主机上的应用程序，答案就是端口，端口即应用程序与网卡关联的编号。</p><p>传输层功能：建立端口到端口的通信</p><p>补充：端口范围0-65535，0-1023为系统占用端口</p><p>tcp协议：</p><p>可靠传输，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><p>以太网头    ip 头                  tcp头                  数据                                                    </p><p>udp协议：</p><p>不可靠传输，”报头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><p>以太网头    ip头                         udp头                               数据              </p><p>应用层</p><p>应用层由来：用户使用的都是应用程序，均工作于应用层，互联网是开发的，大家都可以开发自己的应用程序，数据多种多样，必须规定好数据的组织形式 。</p><p>应用层功能：规定应用程序的数据格式。</p><p>例：TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081049759.png" alt="img"></p><h1 id="七层协议详解"><a href="#七层协议详解" class="headerlink" title="七层协议详解"></a>七层协议详解</h1><p>我们都知道互联网的本质是一系列的网络协议，这个协议就叫做OSI协议。按照功能不同分工不同，认为的分为七层。实际上这七层是并不存在的，也就是说没有这些概念，而我们今天提到的七层概念，只是人为的划分而已。目的只是为了让大家更好地理解这些都是用来做什么的。<br>从专业的角度来说，OSI就是一个开放的通信系统互联参考模型，也是一个定义的很好的协议规范。OSI模型有7层结构，每层都可以有几个子层。OSI的7层从下到上分别是7-应用层、6-表示层、5-会话层、4-传输层、3-网络层、2-数据链路层、1-物理层。</p><h2 id="第1层-物理层"><a href="#第1层-物理层" class="headerlink" title="第1层 物理层"></a>第1层 物理层</h2><p>是参考模型的最低层。该层是网络通信的数据传输介质，由连接不同结点的电缆与设备共同构成。主要跟功能是：利用传输介质为数据链路层提供物理连接，负责处理数据传输并监控数据出错率，以便数据流的透明传输。</p><h2 id="第2层-数据链路层"><a href="#第2层-数据链路层" class="headerlink" title="第2层 数据链路层"></a>第2层 数据链路层</h2><p>是参考模型的第二层。主要功能是：在物理层提供的服务基础上，在通信的实体间建立数据链路连接，传输以“帧”为单位的数据包，并采用差错控制与流量控制方法，使有差错的物理线路变成无差错的数据链路。</p><h2 id="第3层-网络层"><a href="#第3层-网络层" class="headerlink" title="第3层 网络层"></a>第3层 网络层</h2><p>是参考模型的第三层。主要功能是：为数据在节点之间传输创建逻辑链路，通过路由选择算法为分组通过通信子网选择最适当的路径，以及实现拥塞控制、网络互连等功能。</p><h2 id="第4层-传输层"><a href="#第4层-传输层" class="headerlink" title="第4层 传输层"></a>第4层 传输层</h2><p>是参考模型的第四层。主要功能是：向用户提供可靠地端到端服务，处理数据包错误、数据包次序，以及其他一些关键传输问题。传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层。</p><h2 id="第5层-会话层"><a href="#第5层-会话层" class="headerlink" title="第5层 会话层"></a>第5层 会话层</h2><p>是参考模型的第五层。主要功能是：负责维扩两个结点之间的传输连接，以便确保点到点传输不中断，以及管理数据交换等功能。</p><h2 id="第6层-表示层"><a href="#第6层-表示层" class="headerlink" title="第6层 表示层"></a>第6层 表示层</h2><p>是参考模型的第六层。主要功能是：用于处理在两个通信系统中交换信息的表示方法，主要包括数据格式变换、数据加密与解密、数据压缩与恢复等功能。</p><h2 id="第7层-应用层"><a href="#第7层-应用层" class="headerlink" title="第7层 应用层"></a>第7层 应用层</h2><p>是参考模型的最高层。主要功能是：为应用软件提供了很多服务，比如文件服务器、数据库服务、电子邮件与其他网络软件服务。</p><h1 id="OSI历史"><a href="#OSI历史" class="headerlink" title="OSI历史"></a>OSI历史</h1><p>忘记告诉大家，这个协议是从下到上倒推出来的。<br>我们来回顾一下这段有趣的历史吧~<br>OSI模型最初是因为美国人的两台机器之间有进行通信的需求。</p><p><strong>需求1</strong>：两个硬件之间如何进行通信，具体就是一台发比特流，另一台能够收到。于是就有了物理层：主要是定义设备标准，如网线的额接口类型、管线的接口类型、各种传输介质的传输速率等。它的主要租用是传输比特流，就是从1&#x2F;0转化为电流强弱来进行传输，到达目的之后再转化为1&#x2F;0，也就是我们常说的数模转换。这一层的数据是比特。</p><p><strong>需求2</strong>：现在通过电线我能发数据流了，但是我还是希望能通过无线电波，通过其他介质来进行传输。然后我还要保证传输过去的比特流是正确的，需要由纠正错误的功能。</p><p><strong>数据链路层</strong>：定义了如何让格式化数据进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。</p><p><strong>需求3</strong>：现在我能发正确的比特流数据到另一台计算机了，但是当我发大量数据的时候，可能需要很长时间，例如：一个视频格式的，网络会中断好多次，实际上，即使有了物理层和数据链路层，网络还是经常中断，只是中断的时间是毫秒级别的。</p><p>那么，我还需要保证传输大量文件时的准确性。于是，我要对发出去的数据进行封装。就像发快递一样，一个个发送。</p><p>于是，发明了<strong>传输层</strong>（传输层在OSI模型中，是在网络层面上）。</p><p>比如TCP，是用于发送大量数据的，我发出去一万个包，另一台电脑就需要告诉我是否接收到一万个包，如果缺少3个包，就告诉我是第1001&#x2F;234&#x2F;8888个包丢了，那我再发一次。这样，就能保证对方把这个视频完整接收了。</p><p>例如UDP，适用于发送少量数据的。我发20个包出去，一般不会丢包，所以 ，我不管你收到多少，在多人互动游戏中，也经常受到UDP协议，因为一般都是简单的额信息，而且有广播的需求。如果用TCP，效率就会很低，因为它会不停地告诉主机我收到20个包，或者18个包，再发我两个！如果同时有1万台计算机都这样做，那么用TCP反而会降低效率，还不如用UDP，主机发出去就算了，丢几个包就卡一下，算了，下次再发包更新。</p><p>TCP协议是会绑定IP和端口的协议，下面会介绍IP协议。</p><p><strong>需求4</strong>：传输层是解决了打包的问题。但是如果我有多台计算机，怎么能找到我要发的那台？或者A要给F发信息，中间要经过B&#x2F;C&#x2F;D&#x2F;E，但是中间还有好多节点，如K&#x2F;J&#x2F;Z&#x2F;Y.我怎么选择最佳路径？这就是路由要做的事情。</p><p>于是，发明了<strong>网络层</strong>，也就是路由器，交换那些具有寻址功能的设备所实现的功能。这一层定义的是IP复制，通过IP地址寻址，所以产生了协议。</p><p><strong>需求5</strong>：现在已经能够给指定计算机发送正确的封装过的信息了，但是用户级别的体验并不是很好？难道我每次都要调用TCP去打包，然后调用IP协议去找路由，自己去发？当然不行，所以我们要建立一个自动收发包，自动寻址的功能。</p><p>于是发明了<strong>会话层</strong>。会话层的作用就是建立和管理应用程序之间的通信。</p><p><strong>需求6</strong>：现在我能保证应用程序自动收发包和寻址了，但是我要用Linux给window发包，两个系统语法不一致，就像安装包一样，EXE不能在Linux下用，shell在window也也是不能直接运行的。</p><p>于是需要<strong>表示层</strong>，帮我们解决不同系统之间的通信语法问题。</p><p><strong>需求7</strong>：现在所有必要条件都准备好了，我们可以写个Android程序，web程序去实现需求吧。</p><p><strong>补充</strong>：不知道有没有小伙伴熟悉<strong>Socket</strong>，这不是一个协议，而是一个通信模型。其实它最初是伯克利加州分校软件研究所，简称BSD发明的，主要是一台电脑两个进程之间进行通信，然后把它用到两台电脑的进程间通信。所以，可以把它简单理解为进程间通信，不是什么高级的东西，主要是这么做的：A发包：发请求包给某个已经绑定的端口；收到B的允许后，正式开始发送，发送完了，高速B要断开连接；收到断开允许后，马上断开，然后发送已经断开信息给B。</p><p>B收包：绑定端口和IP，然后在这个端口监听接收到A的请求，发给A，并做好接收准备，主要就是清理缓存等待接收新数据；然后正式接收，接收到断开请求，并允许断开，确认断开后，继续监听其他请求。</p><p>换句话说，socket就是I&#x2F;O操作，socket并不仅限于网络通信。在网络通信中，它涵盖了网络层、传输层、会话层、表示层、应用层。</p><h1 id="OSI七层协议中每一层的特征"><a href="#OSI七层协议中每一层的特征" class="headerlink" title="OSI七层协议中每一层的特征"></a>OSI七层协议中每一层的特征</h1><h2 id="第一层：物理层"><a href="#第一层：物理层" class="headerlink" title="第一层：物理层"></a>第一层：物理层</h2><p>机械性能：接口的形状，尺寸的大小，引脚的数目和排列方式等；</p><p>电气性能：接口规定信号的电压、电流、阻抗、波形、速率好平衡特性等；</p><p>工程规范：接口引脚的意义、特性、标准。</p><p>工作方式：确定数据位流的传输方式，如：半双工、全双工等。</p><p>物理层协议：美国电子工业协会（EIA）的RS232&#x2F;RS422&#x2F;RS423等；</p><p>国际电报电话咨询委员会（CCITT）的X.25&#x2F;X.21等；</p><p>物理层的数据单位是位（BIT），典型设备时集线器HUB。</p><p>这主要是和硬件有关，与软件关系不大。</p><h2 id="第二层：链路层"><a href="#第二层：链路层" class="headerlink" title="第二层：链路层"></a>第二层：链路层</h2><p>链路层屏蔽传输介质的物理特征，使数据可靠传送。</p><p>内容包括介质访问控制、连接控制、顺序控制、流量控制、差错控制和仲裁协议等。</p><p>链路层协议有：协议有面向字符的通讯协议（PPP）和面向位的通讯协议（HDLC）。</p><p>仲裁协议：CSMA&#x2F;CD(Carrier Sense Multiple Access with Collision Detection)、Token Bus、Token Ring</p><p>链路层数据单位是帧，实现对MAC地址的访问，典型设备是交换机SWITCH。</p><h2 id="第三层：网络层"><a href="#第三层：网络层" class="headerlink" title="第三层：网络层"></a>第三层：网络层</h2><p>网络层管理连接方式和路由选择。</p><p>连接方式：虚电路和数据报服务。</p><p>虚电路是面向连接的，数据通讯一次路由，通过会话建立的一条通路。数据报是非连接的，每个数据报都有路由能力。网络层的数据单位是包，使用的是IP地址，典型设备时路由器Router。</p><p>这一层可以进行流量控制，但流量控制更多的是使用第二层或第四层。</p><h2 id="第四层：传输层"><a href="#第四层：传输层" class="headerlink" title="第四层：传输层"></a>第四层：传输层</h2><p>提供端到端的服务，可以实现流量控制、负载均衡。</p><p>传输层信息包括端口、控制字和校验和。</p><p>传输层协议主要是TCP和UDP。</p><p>传输层位于OSI的第四层，这层使用的设备时主机本身。</p><h2 id="第五层：会话层"><a href="#第五层：会话层" class="headerlink" title="第五层：会话层"></a>第五层：会话层</h2><p>会话层主要内容时通过 绘画进行身份验证、绘画管理和确定通讯方式。一旦建立连接，会话层的任务就是管理会话。</p><h2 id="第六层：表示层"><a href="#第六层：表示层" class="headerlink" title="第六层：表示层"></a>第六层：表示层</h2><p>表示层主要是解释通讯数据的意义，如代码转换、格式变换等，使不同的终端可以表示。</p><p>还包括加密与解密、压缩与解压等。</p><h2 id="第七层：应用层"><a href="#第七层：应用层" class="headerlink" title="第七层：应用层"></a>第七层：应用层</h2><p>应用层应该是直接面向用户的程序或服务，包括系统程序和用户程序，比如www、FTP、DNS、POP3和SMTP等都是应用层服务。</p><p>数据再发送时是数据从应用层至物理层的一个大包的过程，接收时是数据从物理层至应用层的一个解包过程。</p><p>从功能角度可以分为三组：1&#x2F;2层解决网络通信问题，3&#x2F;4层解决传输问题，5&#x2F;6&#x2F;7层处理对应用进程的访问。</p><p>从控制角度可分为二组：1&#x2F;2&#x2F;3层是通信子网，4&#x2F;5&#x2F;6&#x2F;7是主机控制层。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://mp.weixin.qq.com/s/jiPMUk6zUdOY6eKxAjNDbQ">https://mp.weixin.qq.com/s/jiPMUk6zUdOY6eKxAjNDbQ</a></p><p><a href="https://mp.weixin.qq.com/s/Uf42QEL6WUSHOwJ403FwOA">https://mp.weixin.qq.com/s/Uf42QEL6WUSHOwJ403FwOA</a></p>]]></content>
    
    
    <categories>
      
      <category>网络知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>网络知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 常见错误及解决办法</title>
    <link href="/2022/01/19/Git%20%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2022/01/19/Git%20%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-常见错误及解决办法"><a href="#Git-常见错误及解决办法" class="headerlink" title="Git 常见错误及解决办法"></a>Git 常见错误及解决办法</h1><blockquote><p>收录使用 Git 过程中遇到的问题</p></blockquote><p>[TOC]</p><h2 id="1、fatal-refusing-to-merge-unrelated-histories"><a href="#1、fatal-refusing-to-merge-unrelated-histories" class="headerlink" title="1、fatal: refusing to merge unrelated histories"></a>1、<code>fatal: refusing to merge unrelated histories</code></h2><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>这种错误在两个分支合并或者<code>git pull</code>以及<code>git push </code>都会出现，这个是因为两个分支没有去的关系，或者远程分支没有和本地分支关联</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>在操作命令后添加<code>--allow-unrelated-history</code></p><h2 id="2、Could-not-read-from-remote-repository"><a href="#2、Could-not-read-from-remote-repository" class="headerlink" title="2、Could not read from remote repository."></a>2、<code>Could not read from remote repository.</code></h2><h3 id="问题描述：-1"><a href="#问题描述：-1" class="headerlink" title="问题描述："></a>问题描述：</h3><p><code>git push</code>过程中出现错误，是因为<code> ssh-key</code> 的问题，本地没有正确配置 <code>ssh-key</code></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs livecodeserver">git@github.com: Permission denied (publickey).<br>fatal: Could <span class="hljs-keyword">not</span> <span class="hljs-built_in">read</span> <span class="hljs-built_in">from</span> remote repository.<br><br>Please make sure you have <span class="hljs-keyword">the</span> correct access rights<br><span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> repository exists.<br></code></pre></td></tr></table></figure><h3 id="解决办法：-1"><a href="#解决办法：-1" class="headerlink" title="解决办法："></a>解决办法：</h3><p>首先查看是否有 ssh 数据   <code>ssh-add -l</code></p><p>如果不存在的话会出现 <code>The agent has no identities.</code></p><p>需要添加<code>ssh-key</code>:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ssh-add ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_github<br>ssh-add ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_github<br></code></pre></td></tr></table></figure><p>添加完毕以后再次验证 <code>ssh-add -l</code></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2048 </span>SHA256:izQU3fcuygtE2jr8KLFhujoS6c/bB46k09uyu/VCRzk xxx@email (RSA)<br><span class="hljs-symbol">2048 </span>SHA256:jH+IeruPI+si++vSWPrr/e14ZDT+flI4xGioGQXF+gc xxx@email (RSA)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git本地仓库关联远程仓库</title>
    <link href="/2022/01/19/Git%20%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <url>/2022/01/19/Git%20%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-本地仓库关联远程仓库"><a href="#Git-本地仓库关联远程仓库" class="headerlink" title="Git 本地仓库关联远程仓库"></a>Git 本地仓库关联远程仓库</h1><h2 id="1、建立远程仓库"><a href="#1、建立远程仓库" class="headerlink" title="1、建立远程仓库"></a>1、建立远程仓库</h2><h2 id="2、初始化本地仓库"><a href="#2、初始化本地仓库" class="headerlink" title="2、初始化本地仓库"></a>2、初始化本地仓库</h2><figure class="highlight csharp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><h2 id="3、修改git-config"><a href="#3、修改git-config" class="headerlink" title="3、修改git config"></a>3、修改git config</h2><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">git config <span class="hljs-literal">user</span>.<span class="hljs-keyword">name</span> <span class="hljs-string">&quot;zhangweijie&quot;</span><br>git config <span class="hljs-literal">user</span>.email <span class="hljs-string">&quot;15538088057@163.com&quot;</span><br></code></pre></td></tr></table></figure><h2 id="4、添加基础文件"><a href="#4、添加基础文件" class="headerlink" title="4、添加基础文件"></a>4、添加基础文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# bubble&quot;</span> &gt;&gt; README.md<br></code></pre></td></tr></table></figure><h2 id="5、提交代码并推送"><a href="#5、提交代码并推送" class="headerlink" title="5、提交代码并推送"></a>5、提交代码并推送</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> README.md<br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>git branch -M main<br>git remote <span class="hljs-built_in">add</span> origin git@github.com:zhangweijie11/bubble.git<br>git push -u origin main<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 代码编译问题</title>
    <link href="/2022/01/19/Golang%20%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/19/Golang%20%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-代码编译问题"><a href="#Golang-代码编译问题" class="headerlink" title="Golang 代码编译问题"></a>Golang 代码编译问题</h1><ul><li>Windows</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 编译代码</span><br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">CGO_ENABLED</span>=0<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">GOOS</span>=darwin<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">GOARCH</span>=amd64<br>go build main.go<br><br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">CGO_ENABLED</span>=0<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">GOOS</span>=linux<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">GOARCH</span>=amd64<br>go build main.go<br></code></pre></td></tr></table></figure><ul><li>Linux</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 编译代码</span><br><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=darwin <span class="hljs-attribute">GOARCH</span>=amd64 go build main.go<br><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=windows <span class="hljs-attribute">GOARCH</span>=amd64 go build main.go<br></code></pre></td></tr></table></figure><ul><li>MAC</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 编译代码</span><br><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=linux <span class="hljs-attribute">GOARCH</span>=amd64 go build main.go  # linux<br><span class="hljs-attribute">CGO_ENABLED</span>=0 <span class="hljs-attribute">GOOS</span>=windows <span class="hljs-attribute">GOARCH</span>=amd64 go build main.go  # windows<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqlalchemy 基本函数</title>
    <link href="/2022/01/12/SqlAlchemy%20%20%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0/"/>
    <url>/2022/01/12/SqlAlchemy%20%20%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="SqlAlchemy-基本函数"><a href="#SqlAlchemy-基本函数" class="headerlink" title="SqlAlchemy  基本函数"></a>SqlAlchemy  基本函数</h2><h3 id="CAST"><a href="#CAST" class="headerlink" title="CAST"></a>CAST</h3><ul><li>业务场景说明</li></ul><p>domain 表中存在一个字段 source，类型为 array，现在需要进行完全匹配</p><table><thead><tr><th>domain</th><th>source</th></tr></thead><tbody><tr><td>baidu.com</td><td>{brute,search}</td></tr><tr><td>163.com</td><td>{brute}</td></tr></tbody></table><p>现在需要精确匹配出<code>163.com</code></p><p>原生 SQL 语句</p><figure class="highlight pgsql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">domain</span> <span class="hljs-keyword">where</span> CAST(<span class="hljs-keyword">domain</span>.source <span class="hljs-keyword">AS</span> <span class="hljs-type">VARCHAR</span>[]) = CAST(<span class="hljs-string">&#x27;&#123;brute&#125;&#x27;</span> <span class="hljs-keyword">AS</span> <span class="hljs-type">VARCHAR</span>[])<br></code></pre></td></tr></table></figure><p>ORM 语句</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">domain = Domain<span class="hljs-selector-class">.query</span><span class="hljs-selector-class">.filter</span>(<span class="hljs-built_in">cast</span>(Domain<span class="hljs-selector-class">.source</span>, <span class="hljs-built_in">ARRAY</span>(String)) == <span class="hljs-built_in">cast</span>(<span class="hljs-selector-attr">[<span class="hljs-string">&quot;brute&quot;</span>]</span>, <span class="hljs-built_in">ARRAY</span>(String)))<span class="hljs-selector-class">.first</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>sqlalchemy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>sqlalchemy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AHP（层次分析法）</title>
    <link href="/2022/01/07/AHP%EF%BC%88%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%EF%BC%89/"/>
    <url>/2022/01/07/AHP%EF%BC%88%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="AHP（层次分析法）"><a href="#AHP（层次分析法）" class="headerlink" title="AHP（层次分析法）"></a>AHP（层次分析法）</h1><p>[TOC]</p><hr><h2 id="一、AHP层次分析法是什么？"><a href="#一、AHP层次分析法是什么？" class="headerlink" title="一、AHP层次分析法是什么？"></a>一、AHP层次分析法是什么？</h2><p>AHP(Analytic Hierarchy Process)层次分析法是美国运筹学家T. L. Saaty教授于二十世纪70年代提出的一种实用的多方案或多目标的决策方法，是一种定性与定量相结合的决策分析方法。用决策者的经验判断各衡量目标之间能否实现的标准之间的相对重要程度，并合理地给出每个决策方案的每个标准的权数，利用权数求出各方案的优劣次序，比较有效地应用于那些难以用定量方法解决的课题。，具有十分广泛的实用性。</p><h2 id="二、AHP的广泛运用"><a href="#二、AHP的广泛运用" class="headerlink" title="二、AHP的广泛运用"></a>二、AHP的广泛运用</h2><p>经过四十多年的研究与发展，AHP已经成为决策者广泛使用的一种多准则方法。其应用涉及经济与计划、能源政策与资源分配、政治问题及冲突、人力资源管理、预测、项目评价、教育发展、环境工程、企业管理与生产经营决策、会计、卫生保健、军事指挥、武器评价、法律等众多领域。AHP主要是作为一种辅助决策工具，它只有和其他方法有机结合，才能取得比较好的使用效果。从现有的研究成果看，与AHP结合使用的其他方法有模糊集理论、模糊逻辑、数字规划、成本收益分析、人工神经网络、证据推理、数据包络分析、仿真、数据挖掘等。</p><h2 id="三、AHP的优缺点"><a href="#三、AHP的优缺点" class="headerlink" title="三、AHP的优缺点"></a>三、AHP的优缺点</h2><h3 id="1-层次分析法的优点"><a href="#1-层次分析法的优点" class="headerlink" title="1.层次分析法的优点"></a>1.层次分析法的优点</h3><p>-<br>  系统性-将对象视作系统，按照分解、比较、判断、综合的思维方式进行决策。成为成为继机理分析、统计分析之后发展起来的系统分析的重要工具;</p><ul><li>实用性-定性与定量相结合,能处理许多用传统的最优化技术无法着手的实际问题,应用范围很广，同时,这种方法使得决策者与决策分析者能够相互沟通,决策者甚至可以直接应用它,这就增加了决策的有效性;</li><li>简洁性-计算简便,结果明确,具有中等文化程度的人即可以了解层次分析法的基本原理并掌握该法的基本步骤,容易被决策者了解和掌握。便于决策者直接了解和掌握。</li><li>建立所有要素(包括非量化与量化)的层级，清楚呈现各层、各准则与各要素的关系。</li><li>简化评估程序，计算过程简单易懂。</li><li>若研究资料存在遗漏或不足的部分，仍能求得各要素的重要性。</li></ul><h3 id="2-层次分析法的缺点"><a href="#2-层次分析法的缺点" class="headerlink" title="2.层次分析法的缺点"></a>2.层次分析法的缺点</h3><ul><li>囿旧-只能从原有的方案中优选一个出来,没有办法得出更好的新方案;</li><li>粗略-该法中的比较、判断以及结果的计算过程都是粗糙的,不适用于精度较高的问题。;</li><li>主观-从建立层次结构模型到给出成对比较矩阵，人主观因素对整个过程的影响很大，这就使得结果难以让所有的决策者接受。当然采取专家群体判断的办法是克服这个缺点的一种途径。</li><li>要素之间两两比较有时比较困难。</li><li>当要素比较多时，一致性检验可能无法通过(所以一般把要素控制在7个)。</li><li>分析时没有考虑要素的相关性问题。</li></ul><h2 id="四、应用步骤"><a href="#四、应用步骤" class="headerlink" title="四、应用步骤"></a>四、应用步骤</h2><p>运用层次分析法构造系统模型时,大体可以分为以下四个步骤:</p><ol><li><p>建立层次结构模型</p></li><li><p>构造判断(成对比较)矩阵</p></li><li><p>层次单排序及其—致性检验</p></li><li><p>层次总排序及其一致性检验</p></li></ol><h3 id="1、建立层次结构模型"><a href="#1、建立层次结构模型" class="headerlink" title="1、建立层次结构模型"></a>1、建立层次结构模型</h3><p>将决策的目标、考虑的因素（决策准则）和决策对象按它们之间的相互关系分为最高层、中间层和最低层,绘出层次结构图。</p><ul><li>最高层:决策的目的、要解决的问题。</li><li>最低层:决策时的备选方案。</li><li>中间层:考虑的因素、决策的准则。</li></ul><p>对于相邻的两层,称高层为目标层，低层为因素层。</p><p>例如某单位拟从3名干部中选拔一名领导,选拔的标准有政策水平、工作作风、业务知识、口才、写作能力和健康状况。我们建立层次结构模型就为：</p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202201071429227.png" alt="image-20220107142919251" style="zoom:50%;" /><h3 id="2-构造判断-成对比较-矩阵"><a href="#2-构造判断-成对比较-矩阵" class="headerlink" title="2.构造判断(成对比较)矩阵"></a>2.构造判断(成对比较)矩阵</h3><p>在确定各层次各因素之间的权重时,如果只是定性的结果,则常常不容易被别人接受,因而有人提出:一致矩阵法,即:</p><ol><li>不把所有因素放在一起比较,而是两两相互比较。</li><li>对比时采用相对尺度,以尽可能减少性质不同的诸因素相互比较的困难,以提高准确度。</li><li>判断矩阵是表示本层所有因素针对上一层某一个因素的相对重要性的比较。判断矩阵的元素aj;用Santy的1—9标度方法给出。</li></ol><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202201071429022.png" alt="image-20220107142947045" style="zoom:50%;" /><p>在依据上述给的选举领导的例子，我们构造判断矩阵为：</p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202201071430090.png" alt="image-20220107143027581" style="zoom:50%;" /><h3 id="3-层次单排序及其—致性检验"><a href="#3-层次单排序及其—致性检验" class="headerlink" title="3.层次单排序及其—致性检验"></a>3.层次单排序及其—致性检验</h3><p>对应于判断矩阵最大特征根入max的特征向量,经归一化(使向量中各元素之和等于1)后记为W。<br>W的元素为同一层次因素对于上一层次因素某因素相对重要性的排序权值,这一过程称为层次单排序。<br>能否确认层次单排序,需要进行一致性检验,所谓一致性检验是指对A确定不一致的允许范围。</p><p>首先我们要先对我们构造的比较矩阵进行归一化：</p><p>列向量归一化：求每个分量平方和，然后求它的平方根<br>再给每个分量除以上面得到的数就可以了</p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202201071431691.png" alt="image-20220107143110890" style="zoom:50%;" /><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202201071432583.png" alt="image-20220107143209613" style="zoom:50%;" /><h4 id="（1）计算一致性指标"><a href="#（1）计算一致性指标" class="headerlink" title="（1）计算一致性指标"></a>（1）计算一致性指标</h4><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202201071432735.png" alt="image-20220107143245264" style="zoom:50%;" /><h4 id="（2）为了衡量的大小，引入随机一致性指标"><a href="#（2）为了衡量的大小，引入随机一致性指标" class="headerlink" title="（2）为了衡量的大小，引入随机一致性指标"></a>（2）为了衡量的大小，引入随机一致性指标</h4><p>查找相应的平均随机一致性指标RI。对n&#x3D;1，…，9，Santy给出了RI的值，如下表（表2）：</p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202201071433879.png" alt="image-20220107143327123" style="zoom:50%;" /><h4 id="（3）计算一致性比例CR："><a href="#（3）计算一致性比例CR：" class="headerlink" title="（3）计算一致性比例CR："></a>（3）计算一致性比例CR：</h4><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202201071434889.png" alt="image-20220107143352150" style="zoom:50%;" /><h3 id="4-层次总排序及其一致性检验"><a href="#4-层次总排序及其一致性检验" class="headerlink" title="4.层次总排序及其一致性检验"></a>4.层次总排序及其一致性检验</h3><p>计算某一层次所有因素对于最高层（总目标）相对重要性的权值，称为层次总排序。这一过程是从最高层次到最低层次依次进行的。</p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202201071434891.png" alt="image-20220107143436017" style="zoom:50%;" /><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202201071435189.png" alt="image-20220107143550104" style="zoom:50%;" /><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202201071436434.png" alt="image-20220107143623162" style="zoom:50%;" /><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202201071436261.png" alt="image-20220107143643040" style="zoom:50%;" /><h2 id="五、Python-代码"><a href="#五、Python-代码" class="headerlink" title="五、Python 代码"></a>五、Python 代码</h2><figure class="highlight lua"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></div></td><td class="code"><pre><code class="hljs lua">import numpy as np<br>import pandas as pd<br>import warnings<br><br><br>class AHP:<br>    def __init__(<span class="hljs-built_in">self</span>, criteria, b):<br>        <span class="hljs-built_in">self</span>.RI = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.58</span>, <span class="hljs-number">0.9</span>, <span class="hljs-number">1.12</span>, <span class="hljs-number">1.24</span>, <span class="hljs-number">1.32</span>, <span class="hljs-number">1.41</span>, <span class="hljs-number">1.45</span>, <span class="hljs-number">1.49</span>)<br>        <span class="hljs-built_in">self</span>.criteria = criteria<br>        <span class="hljs-built_in">self</span>.b = b<br>        <span class="hljs-built_in">self</span>.num_criteria = criteria.shape[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">self</span>.num_project = b[<span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>]<br><br>    def cal_weights(<span class="hljs-built_in">self</span>, input_matrix):<br>        input_matrix = np.array(input_matrix)<br>        n, n1 = input_matrix.shape<br>        <span class="hljs-built_in">assert</span> n == n1, <span class="hljs-string">&#x27;不是一个方阵&#x27;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n):<br>                <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">abs</span>(input_matrix[i, j] * input_matrix[j, i] - <span class="hljs-number">1</span>) &gt; <span class="hljs-number">1e-7</span>:<br>                    raise ValueError(<span class="hljs-string">&#x27;不是反互对称矩阵&#x27;</span>)<br><br>        eigenvalues, eigenvectors = np.linalg.eig(input_matrix)<br><br>        max_idx = np.argmax(eigenvalues)<br>        max_eigen = eigenvalues[max_idx].real<br>        eigen = eigenvectors[:, max_idx].real<br>        eigen = eigen / eigen.sum()<br><br>        <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">9</span>:<br>            CR = None<br>            warnings.warn(<span class="hljs-string">&#x27;无法判断一致性&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            CI = (max_eigen - n) / (n - <span class="hljs-number">1</span>)<br>            CR = CI / <span class="hljs-built_in">self</span>.RI[n]<br>        <span class="hljs-keyword">return</span> max_eigen, CR, eigen<br><br>    def run(<span class="hljs-built_in">self</span>):<br>        max_eigen, CR, criteria_eigen = <span class="hljs-built_in">self</span>.cal_weights(<span class="hljs-built_in">self</span>.criteria)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;准则层：最大特征值&#123;:&lt;5f&#125;,CR=&#123;:&lt;5f&#125;,检验&#123;&#125;通过&#x27;</span>.<span class="hljs-built_in">format</span>(max_eigen, CR,<br>                                                        <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">if</span> CR &lt; <span class="hljs-number">0.1</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;不&#x27;</span>))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;准则层权重=&#123;&#125;\n&#x27;</span>.<span class="hljs-built_in">format</span>(criteria_eigen))<br><br>        max_eigen_list, CR_list, eigen_list = [], [], []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">self</span>.b:<br>            max_eigen, CR, eigen = <span class="hljs-built_in">self</span>.cal_weights(i)<br>            max_eigen_list.append(max_eigen)<br>            CR_list.append(CR)<br>            eigen_list.append(eigen)<br><br>        pd_print = pd.DataFrame(eigen_list,<br>                                index=[<span class="hljs-string">&#x27;准则&#x27;</span> + str(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">self</span>.num_criteria)],<br>                                columns=[<span class="hljs-string">&#x27;方案&#x27;</span> + str(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">self</span>.num_project)],<br>                                )<br>        pd_print.loc[:, <span class="hljs-string">&#x27;最大特征值&#x27;</span>] = max_eigen_list<br>        pd_print.loc[:, <span class="hljs-string">&#x27;CR&#x27;</span>] = CR_list<br>        pd_print.loc[:, <span class="hljs-string">&#x27;一致性检验&#x27;</span>] = pd_print.loc[:, <span class="hljs-string">&#x27;CR&#x27;</span>] &lt; <span class="hljs-number">0.1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;方案层&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(pd_print)<br><br>        # 目标层<br>        obj = np.dot(criteria_eigen.reshape(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>), np.array(eigen_list))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n目标层&#x27;</span>, obj)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;最优选择是方案&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.argmax(obj)))<br>        <span class="hljs-keyword">return</span> obj<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    # 准则重要性矩阵<br>    criteria = np.array(<span class="hljs-string">[[1, 2, 7, 5, 5],</span><br><span class="hljs-string">                         [1 / 2, 1, 4, 3, 3],</span><br><span class="hljs-string">                         [1 / 7, 1 / 4, 1, 1 / 2, 1 / 3],</span><br><span class="hljs-string">                         [1 / 5, 1 / 3, 2, 1, 1],</span><br><span class="hljs-string">                         [1 / 5, 1 / 3, 3, 1, 1]]</span>)<br><br>    # 对每个准则，方案优劣排序<br>    b1 = np.array(<span class="hljs-string">[[1, 1 / 3, 1 / 8], [3, 1, 1 / 3], [8, 3, 1]]</span>)<br>    b2 = np.array(<span class="hljs-string">[[1, 2, 5], [1 / 2, 1, 2], [1 / 5, 1 / 2, 1]]</span>)<br>    b3 = np.array(<span class="hljs-string">[[1, 1, 3], [1, 1, 3], [1 / 3, 1 / 3, 1]]</span>)<br>    b4 = np.array(<span class="hljs-string">[[1, 3, 4], [1 / 3, 1, 1], [1 / 4, 1, 1]]</span>)<br>    b5 = np.array(<span class="hljs-string">[[1, 4, 1 / 2], [1 / 4, 1, 1 / 4], [2, 4, 1]]</span>)<br><br>    b = [b1, b2, b3, b4, b5]<br>    a = AHP(criteria, b).run()<br><br></code></pre></td></tr></table></figure><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><p><a href="https://blog.csdn.net/weixin_43095238/article/details/108055579?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164153828216780265425620%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164153828216780265425620&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-5-108055579.first_rank_v2_pc_rank_v29&amp;utm_term=%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_43095238/article/details/108055579?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164153828216780265425620%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164153828216780265425620&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-5-108055579.first_rank_v2_pc_rank_v29&amp;utm_term=%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95&amp;spm=1018.2226.3001.4187</a></p><p><a href="https://blog.csdn.net/mmm_jsw/article/details/84863416?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecase">https://blog.csdn.net/mmm_jsw/article/details/84863416?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecase</a></p><p><a href="https://blog.csdn.net/weixin_43819566/article/details/112251317?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164153828216780265425620%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164153828216780265425620&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-112251317.first_rank_v2_pc_rank_v29&amp;utm_term=%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_43819566/article/details/112251317?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164153828216780265425620%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164153828216780265425620&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-112251317.first_rank_v2_pc_rank_v29&amp;utm_term=%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95&amp;spm=1018.2226.3001.4187</a></p>]]></content>
    
    
    <categories>
      
      <category>数据及算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMeter 简单教程</title>
    <link href="/2022/01/06/JMeter%20%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/"/>
    <url>/2022/01/06/JMeter%20%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="JMeter-简单教程"><a href="#JMeter-简单教程" class="headerlink" title="JMeter 简单教程"></a>JMeter 简单教程</h2><h3 id="1、JMeter-介绍"><a href="#1、JMeter-介绍" class="headerlink" title="1、JMeter 介绍"></a>1、JMeter 介绍</h3><p>Apache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。 它可以用于测试静态和动态资源，例如静态文件、Java <a href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/%E5%B0%8F%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F/4148836">小服务程序</a>、CGI 脚本、Java 对象、数据库、FTP 服务器， 等等。JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能。另外，JMeter能够对应用程序做功能&#x2F;<a href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95/1925732">回归测试</a>，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。为了最大限度的灵活性，JMeter允许<a href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/6555484">使用正则表达式</a>创建断言。</p><h3 id="2、JMeter-下载和安装"><a href="#2、JMeter-下载和安装" class="headerlink" title="2、JMeter 下载和安装"></a>2、JMeter 下载和安装</h3><p>进入JMeter的<a href="https://links.jianshu.com/go?to=http://jmeter.apache.org/download_jmeter.cgi">下载地址</a>页面，如下图，有两个版本可供下载：</p><ul><li><p>Binaries：二进制版，即已经编译好、可直接执行。</p></li><li><p>Source：源代码版，需要自己编译。</p><p><img src="https://upload-images.jianshu.io/upload_images/18137455-fa782ea87f2e953b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p></li></ul><p>我们下载apache-jmeter-5.2.1.tgz这个Binaries版本，下载完成后，解压，可以通过Finder（访达）页面双击这个文件解压，也可以通过终端输入<code>tar zxvf apache-jmeter-5.2.1.tgz</code>解压。</p><h3 id="3、启动-JMeter"><a href="#3、启动-JMeter" class="headerlink" title="3、启动 JMeter"></a>3、启动 JMeter</h3><blockquote><p>进入 JMeter 目录启动</p></blockquote><p>解压后，会得到下面的目录文件：</p><p><img src="https://upload-images.jianshu.io/upload_images/18137455-9ac0e69eb9958d7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1126/format/webp" alt="img"></p><p>Jmeter目录.png</p><p>输入<code>cd bin</code>，进入到bin目录下，通过<code>sh jmeter</code>命令来启动Jmeter。</p><p><img src="https://upload-images.jianshu.io/upload_images/18137455-a376dca8043e618f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1132/format/webp" alt="img"></p><h3 id="4、基础设置"><a href="#4、基础设置" class="headerlink" title="4、基础设置"></a>4、基础设置</h3><h4 id="4-1语言切换"><a href="#4-1语言切换" class="headerlink" title="4.1语言切换"></a>4.1语言切换</h4><ul><li>临时方法</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-b064949d43609bdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/596/format/webp" alt="img"></p><ul><li><p>永久方法：打开Jmeter解压后文件下的bin目录，找到<code>jmeter.properties</code>文件并用编辑器打开，在<code>#language=en</code>下面插入一行<code>language=zh_CN</code>，修改后保存，重启Jmeter界面默认显示为中文简体。</p><p><img src="https://upload-images.jianshu.io/upload_images/17704372-e8219b3b2d0c5339.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/825/format/webp" alt="img"></p></li></ul><h4 id="4-2-修改Jmeter默认编码为utf-8解决控制台乱码"><a href="#4-2-修改Jmeter默认编码为utf-8解决控制台乱码" class="headerlink" title="4.2 修改Jmeter默认编码为utf-8解决控制台乱码"></a>4.2 修改Jmeter默认编码为utf-8解决控制台乱码</h4><ul><li>打开Jmeter解压后文件下的bin目录，找到<code>jmeter.properties</code>文件并用编辑器打开</li><li>在<code>#The encoding to be used if none is provided (default ISO-8859-1)、#sampleresult.default.encoding=ISO-8859-1</code></li><li>下面插入一行<code>The encoding to be used if none is provided (default utf-8)、sampleresult.default.encoding=utf-8</code></li><li>修改后保存重启Jmeter</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-334bd3fa8ed97fbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1025/format/webp" alt="img"></p><h3 id="5、编写测试脚本"><a href="#5、编写测试脚本" class="headerlink" title="5、编写测试脚本"></a>5、编写测试脚本</h3><h4 id="5-1、添加线程组"><a href="#5-1、添加线程组" class="headerlink" title="5.1、添加线程组"></a>5.1、添加线程组</h4><ul><li>右键点击 “测试计划” → “添加” → “线程（用户）” → “线程组”</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-c892f46bfd05e687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/461/format/webp" alt="img"></p><p>新建线程组</p><ul><li>配置线程组参数</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-33a9edf92cfad651.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1104/format/webp" alt="img"></p><p>配置</p><h5 id="线程组主要参数详解："><a href="#线程组主要参数详解：" class="headerlink" title="线程组主要参数详解："></a>线程组主要参数详解：</h5><ol><li>线程数：虚拟用户数。一个虚拟用户占用一个进程或线程。模拟多少用户访问也就填写多少个线程数量。</li><li>Ramp-Up时间(秒)：设置的虚拟用户数需要多长时间全部启动。如果线程数为<code>100</code>，准备时长为<code>5</code>，那么需要<code>5</code>秒钟启动<code>100</code>个线程，也就是每秒钟启动<code>20</code>个线程。 相当于每秒模拟<code>20</code>个用户进行访问，设置为零我理解为并发访问。</li><li>循环次数：如果线程数为<code>100</code>，循环次数为<code>100</code>。那么总请求数为<code>100*100=10000</code> 。如果勾选了“永远”，那么所有线程会一直发送请求，直到选择停止运行脚本。</li></ol><h4 id="5-2、添加测试接口"><a href="#5-2、添加测试接口" class="headerlink" title="5.2、添加测试接口"></a>5.2、添加测试接口</h4><ul><li>右键点击 “你的线程组” →  “添加” →  “取样器” → “HTTP请求”</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-3c047912601b8f40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/530/format/webp" alt="img"></p><p>添加请求</p><ul><li>填写接口请求参数，我这里对本地的 <code>Spring-boot</code> 服务进行测试(本教程所用demo源码在文章最后)，可以参考下图填写：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-94228ac347e97ae6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>填写接口</p><h5 id="Http请求主要参数详解（做过接口测试的应该上手很快）："><a href="#Http请求主要参数详解（做过接口测试的应该上手很快）：" class="headerlink" title="Http请求主要参数详解（做过接口测试的应该上手很快）："></a>Http请求主要参数详解（做过接口测试的应该上手很快）：</h5><ul><li>协议：向目标服务器发送HTTP请求协议，可以是<code>HTTP</code>或<code>HTTPS</code>，默认为<code>HTTP</code>。</li><li>服务器名称或IP ：<code>HTTP</code>请求发送的目标服务器名称或<code>IP</code>。</li><li>端口号：目标服务器的端口号，默认值为80</li><li>方法：发送<code>HTTP</code>请求的方法，可用方法包括<code>GET</code>、<code>POST</code>、<code>HEAD</code>、<code>PUT</code>、<code>OPTIONS</code>、<code>TRACE</code>、<code>DELETE</code>等。</li><li>路径：目标<code>URL</code>路径（<code>URL</code>中去掉服务器地址、端口及参数后剩余部分）。</li><li>内容编码：编码方式，默认为<code>ISO-8859-1</code>编码，这里配置为<code>utf-8</code>。</li><li>参数：同请求一起发送参数 ，在请求中发送的<code>URL</code>参数，用户可以将<code>URL</code>中所有参数设置在本表中，表中每行为一个参数（对应<code>URL</code>中的 <code>key=value</code>），注意参数传入中文时需要勾选“编码”。</li></ul><h4 id="5-3、添加察看结果树"><a href="#5-3、添加察看结果树" class="headerlink" title="5.3、添加察看结果树"></a>5.3、添加察看结果树</h4><ul><li>右键点击 “你的线程组” → “添加” → “监听器” → “察看结果树”</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-9660e7383edf950e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/528/format/webp" alt="img"></p><p>添加结果</p><ul><li>这里，我们修改响应数据格式(你返回什么格式就选什么，我这里是返回json)，运行Http请求，可以看到本次请求返回的响应数据。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-c57fce59f3ddcffa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>查看结果</p><h4 id="5-4、添加用户自定义变量"><a href="#5-4、添加用户自定义变量" class="headerlink" title="5.4、添加用户自定义变量"></a>5.4、添加用户自定义变量</h4><ul><li>添加用户自定义变量用以Http请求参数化，右键点击 “你的线程组” → “添加” → “配置元件” → “用户定义的变量”：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-72f68cbcee253ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/579/format/webp" alt="img"></p><p>自定义变量</p><ul><li>新增一个用户名参数（与你实际请求参数key对应，做过接口测试的应该特别明白）</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-bb04d6e099773af3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1139/format/webp" alt="img"></p><p>添加变量</p><ul><li>在Http请求中使用该参数，格式为：${key} ,例如：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-2f933ecb85fcf667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1122/format/webp" alt="img"></p><p>使用参数</p><ul><li>这里我有一个根据用户名查询用户的方法，所以改变参数后，再次运行结果为zero用户数据</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-85937f3b791b0989.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1128/format/webp" alt="img"></p><p>再次查看结果树</p><h4 id="5-5、json断言-因为我这里返回是json-其他需求更据实际情况选择"><a href="#5-5、json断言-因为我这里返回是json-其他需求更据实际情况选择" class="headerlink" title="5.5、json断言(因为我这里返回是json,其他需求更据实际情况选择)"></a>5.5、json断言(因为我这里返回是json,其他需求更据实际情况选择)</h4><ul><li>添加断言：右键点击 “你的HTTP请求” → “添加” → “断言” →  “json断言”</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-259fdb31f0994e17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/577/format/webp" alt="img"></p><p>image.png</p><ul><li>配置json断言具体内容</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-0940071a2642859c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1009/format/webp" alt="img"></p><p>断言内容</p><ul><li>断言结果：右键点击 “你的HTTP请求” → “添加” → “监听器” → “断言结果”</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-0d6fdcf5e7f0c886.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/521/format/webp" alt="img"></p><p>断言结果</p><p><img src="https://upload-images.jianshu.io/upload_images/17704372-38dfdfcc43d8c1e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1126/format/webp" alt="img"></p><p>断言成功</p><blockquote><p>为了演示失败，我将断言内容进行修改为zer</p><p><img src="https://upload-images.jianshu.io/upload_images/17704372-bebbc6bc561381f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1142/format/webp" alt="img"></p><p>断言失败</p></blockquote><h4 id="5-6、添加聚合报告"><a href="#5-6、添加聚合报告" class="headerlink" title="5.6、添加聚合报告"></a>5.6、添加聚合报告</h4><ul><li>右键点击 “你的线程组” →  “添加” →  “监听器” →  “聚合报告”，用以存放性能测试报告</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-d19df46a9f0084df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/508/format/webp" alt="img"></p><p>添加报告</p><blockquote><p>到此我们已经完成了一个最基础的接口测试脚本</p></blockquote><h2 id="6、性能测试"><a href="#6、性能测试" class="headerlink" title="6、性能测试"></a>6、性能测试</h2><ul><li>为了测试出效果，我这里模拟100个用户并发访问获取数据，循环6次，线程组数据修改如下：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-f14112f0643bcc2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1090/format/webp" alt="img"></p><p>修改线程组</p><ul><li>回到聚合报告运行本次压力测试</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-22f9d3a0502302e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>压力测试</p><ul><li>分析测试报告（先得让本次压力测试运行完毕）</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/17704372-aac3d7a3020473ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1135/format/webp" alt="img"></p><p>测试数据</p><h5 id="聚合报告参数详解："><a href="#聚合报告参数详解：" class="headerlink" title="聚合报告参数详解："></a>聚合报告参数详解：</h5><ol><li>Label：每个 <code>JMeter</code> 的 <code>element</code>（例如我这里只有一个 <code>Spring WebFlux</code>）都有一个 <code>Name</code> 属性，这里显示的就是 <code>Name</code> 属性的值。</li><li>样本(Samples)：请求数——表示这次测试中一共发出了多少个请求，我这里模拟了<code>100</code>个用户循环<code>6</code>次也就为<code>100*6=600</code>。</li><li>平均值(Average)：平均响应时间(单位:<strong><code>ms</code></strong>)。默认是单个<code>Request</code>的平均响应时间，当使用了<code>Transaction Controller</code>时，也可以是<code>Transaction</code>为单位显示平均响应时间。</li><li>中位数(Median)：也就是 <code>50％</code> 用户的响应时间。</li><li>90% 百分位(Line)：<code>90％</code> 用户的响应时间。相邻几个<code>*%</code>同意。</li><li>最小值(Min)：最小响应时间。</li><li>最大值(Max)：最大响应时间。</li><li>异常(Error) %：错误率——错误请求数&#x2F;请求总数。</li><li>吞吐量(Throughput)：吞吐量——默认情况下表示每秒完成的请求数（<code>Request per Second</code>），当使用了 <code>Transaction Controller</code> 时，也可以表示类似 <code>LoadRunner</code> 的 <code>Transaction per Second</code> 数 。</li><li>接收 KB&#x2F;Sec：每秒从服务器端接收到的数据量，相当于<code>LoadRunner</code>中的<code>Throughput/Sec</code>。</li><li>发送 KB&#x2F;Sec：每秒向服务器发送的数据量，相当于<code>LoadRunner</code>中的<code>Throughput/Sec</code>。</li></ol><h2 id="7、后记"><a href="#7、后记" class="headerlink" title="7、后记"></a>7、后记</h2><blockquote><p>一般而言，性能测试中我们需要重点关注的数据有： <img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7BSamples%7D" alt="\color{green}{Samples}"> 请求数，![\color</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>性能测试</category>
      
      <category>JMeter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能测试</tag>
      
      <tag>JMeter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列-重复消费、顺序消费、分布式事务</title>
    <link href="/2021/12/31/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E3%80%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <url>/2021/12/31/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E3%80%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="消息队列-重复消费、顺序消费、分布式事务"><a href="#消息队列-重复消费、顺序消费、分布式事务" class="headerlink" title="消息队列-重复消费、顺序消费、分布式事务"></a>消息队列-重复消费、顺序消费、分布式事务</h1><h2 id="一、重复消费"><a href="#一、重复消费" class="headerlink" title="一、重复消费"></a>一、重复消费</h2><p>重复消费很容易理解，就是一条消息被重复消费，可能是消费了两次，也可能是消费了多次。但是有些重复消费是可以被接受的，有些则不能被接受，这取决于被重复消费的数据是否会对你的业务和数据产生影响。</p><p>当你的业务和数据要求幂等性，那重复消费是无法被接受的。例如金融行业，每次的扣款和存钱针对的数值，一定不允许重复消费，不然你的总金额就不对了。</p><p>当业务和数据不要求幂等性，则重复消费是可以接受的。例如发送通知类短信，你收到两次完全没有啥问题。</p><blockquote><p>幂等性（idempotent）是一个数学与计算机学概念，常见于抽象代数中。在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变</p></blockquote><ul><li>如何保证没有重复消费？</li></ul><p>当不能接受重复消时，需要自行决定一个唯一值，通过唯一值来确定该条消息是否已经被消费过了，例如惟一的订单号。</p><h2 id="二、顺序消费"><a href="#二、顺序消费" class="headerlink" title="二、顺序消费"></a>二、顺序消费</h2><p>顺序消费最稳妥的就是同步发送，同步消费。或者先发送一条，消费成功后再发送下一条消息。</p><h3 id="1、为什么会有顺序错乱？"><a href="#1、为什么会有顺序错乱？" class="headerlink" title="1、为什么会有顺序错乱？"></a>1、为什么会有顺序错乱？</h3><p>在生产中经常会有一些类似报表系统这样的系统，需要做 MySQL 的 binlog 同步。比如订单系统要同步订单表的数据到大数据部门的 MySQL 库中用于报表统计分析，通常的做法是基于 Canal 这样的中间件去监听订单数据库的 binlog，然后把这些 binlog 发送到 MQ 中，再由消费者从 MQ 中获取 binlog 落地到大数据部门的 MySQL 中。</p><p>在这个过程中，可能会有对某个订单的增删改操作，比如有三条 binlog 执行顺序是增加、修改、删除；消费者愣是换了顺序给执行成删除、修改、增加，这样能行吗？肯定是不行的</p><h3 id="RabbitMQ-消息顺序错乱"><a href="#RabbitMQ-消息顺序错乱" class="headerlink" title="RabbitMQ 消息顺序错乱"></a>RabbitMQ 消息顺序错乱</h3><p>对于 RabbitMQ 来说，导致上面顺序错乱的原因通常是消费者是集群部署，不同的消费者消费到了同一订单的不同的消息，如消费者 A 执行了增加，消费者 B 执行了修改，消费者 C 执行了删除，但是消费者 C 执行比消费者 B 快，消费者 B 又比消费者 A 快，就会导致消费 binlog 执行到数据库的时候顺序错乱，本该顺序是增加、修改、删除，变成了删除、修改、增加。</p><p>如下图是 RabbitMQ 可能出现顺序错乱的问题示意图：</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112311622877.png" alt="image-20211231162238810"></p><h3 id="Kafka-消息顺序错乱"><a href="#Kafka-消息顺序错乱" class="headerlink" title="Kafka 消息顺序错乱"></a>Kafka 消息顺序错乱</h3><p>对于 Kafka 来说，一个 topic 下同一个 partition 中的消息肯定是有序的，生产者在写的时候可以指定一个 key，通过我们会用订单号作为 key，这个 key 对应的消息都会发送到同一个 partition 中，所以消费者消费到的消息也一定是有序的。</p><p>那么为什么 Kafka 还会存在消息错乱的问题呢？问题就出在消费者身上。通常我们消费到同一个 key 的多条消息后，会使用多线程技术去并发处理来提高消息处理速度，否则一条消息的处理需要耗时几十 ms，1 秒也就只能处理几十条消息，吞吐量就太低了。而多线程并发处理的话，binlog 执行到数据库的时候就不一定还是原来的顺序了。</p><p>如下图是 Kafka 可能出现乱序现象的示意图：</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112311621977.png" alt="image-20211231162140630"></p><h3 id="RocketMQ-消息顺序错乱"><a href="#RocketMQ-消息顺序错乱" class="headerlink" title="RocketMQ 消息顺序错乱"></a>RocketMQ 消息顺序错乱</h3><p>对于 RocketMQ 来说，每个 Topic 可以指定多个 MessageQueue，当我们写入消息的时候，会把消息均匀地分发到不同的 MessageQueue 中，比如同一个订单号的消息，增加 binlog 写入到 MessageQueue1 中，修改 binlog 写入到 MessageQueue2 中，删除 binlog 写入到 MessageQueue3 中。</p><p>但是当消费者有多台机器的时候，会组成一个 Consumer Group，Consumer Group 中的每台机器都会负责消费一部分 MessageQueue 的消息，所以可能消费者 A 消费了 MessageQueue1 的消息执行增加操作，消费者 B 消费了 MessageQueue2 的消息执行修改操作，消费者 C 消费了 MessageQueue3 的消息执行删除操作，但是此时消费 binlog 执行到数据库的时候就不一定是消费者 A 先执行了，有可能消费者 C 先执行删除操作，因为几台消费者是并行执行，是不能够保证他们之间的执行顺序的。</p><p>如下图是 RocketMQ 可能出现乱序现象的示意图：</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112311622770.png" alt="image-20211231162213993"></p><h3 id="2、如何保证消息的顺序性"><a href="#2、如何保证消息的顺序性" class="headerlink" title="2、如何保证消息的顺序性?"></a>2、如何保证消息的顺序性?</h3><p>知道了为什么会出现顺序错乱之后，就要想办法保证消息的顺序性了。从前面可以知道，顺序错乱要么是由于多个消费者消费到了同一个订单号的不同消息，要么是由于同一个订单号的消息分发到了 MQ 中的不同机器中。不同的消息队列保证消息顺序性的方案也各不相同。</p><h3 id="RabbitMQ-保证消息的顺序性"><a href="#RabbitMQ-保证消息的顺序性" class="headerlink" title="RabbitMQ 保证消息的顺序性"></a>RabbitMQ 保证消息的顺序性</h3><p>RabbitMQ 的问题是由于不同的消息都发送到了同一个 queue 中，多个消费者都消费同一个 queue 的消息。解决这个问题，我们可以给 RabbitMQ 创建多个 queue，每个消费者固定消费一个 queue 的消息，生产者发送消息的时候，同一个订单号的消息发送到同一个 queue 中，由于同一个 queue 的消息是一定会保证有序的，那么同一个订单号的消息就只会被一个消费者顺序消费，从而保证了消息的顺序性。</p><p>如下图是 RabbitMQ 保证消息顺序性的方案：</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112311625641.png" alt="image-20211231162548584"></p><h3 id="Kafka-保证消息的顺序性"><a href="#Kafka-保证消息的顺序性" class="headerlink" title="Kafka 保证消息的顺序性"></a>Kafka 保证消息的顺序性</h3><p>Kafka 从生产者到消费者消费消息这一整个过程其实都是可以保证有序的，导致最终乱序是由于消费者端需要使用多线程并发处理消息来提高吞吐量，比如消费者消费到了消息以后，开启 32 个线程处理消息，每个线程线程处理消息的快慢是不一致的，所以才会导致最终消息有可能不一致。</p><p>所以对于 Kafka 的消息顺序性保证，其实我们只需要保证同一个订单号的消息只被同一个线程处理的就可以了。由此我们可以在线程处理前增加个内存队列，每个线程只负责处理其中一个内存队列的消息，同一个订单号的消息发送到同一个内存队列中即可。</p><p>如下图是 Kafka 保证消息顺序性的方案：</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112311627326.png" alt="image-20211231162622697"></p><h3 id="RocketMQ-保证消息的顺序性"><a href="#RocketMQ-保证消息的顺序性" class="headerlink" title="RocketMQ 保证消息的顺序性"></a>RocketMQ 保证消息的顺序性</h3><p>RocketMQ 的消息乱序是由于同一个订单号的 binlog 进入了不同的 MessageQueue，进而导致一个订单的 binlog 被不同机器上的 Consumer 处理。</p><p>要解决 RocketMQ 的乱序问题，我们只需要想办法让同一个订单的 binlog 进入到同一个 MessageQueue 中就可以了。因为同一个 MessageQueue 内的消息是一定有序的，一个 MessageQueue 中的消息只能交给一个 Consumer 来进行处理，所以 Consumer 消费的时候就一定会是有序的。</p><p>如下图是 RocketMQ 保证消息顺序性的方案：</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112311626334.png" alt="image-20211231162653308"></p><h2 id="三、分布式事务"><a href="#三、分布式事务" class="headerlink" title="三、分布式事务"></a>三、分布式事务</h2>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 事务隔离级别</title>
    <link href="/2021/12/09/MySQL%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <url>/2021/12/09/MySQL%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-事务、隔离级别"><a href="#MySQL-事务、隔离级别" class="headerlink" title="MySQL 事务、隔离级别"></a>MySQL 事务、隔离级别</h2><h3 id="MySQL-基础架构示意图"><a href="#MySQL-基础架构示意图" class="headerlink" title="MySQL 基础架构示意图"></a>MySQL 基础架构示意图</h3><img src="/Users/zhangweijie/Library/Application Support/typora-user-images/image-20211209173717710.png" alt="image-20211209173717710" style="zoom:50%;" /><h3 id="事务介绍"><a href="#事务介绍" class="headerlink" title="事务介绍"></a>事务介绍</h3><p>MySQL 事务主要用于处理操作量奥迪，复杂度高的数据。比如，在人员管理系统中，你删除一个人员的基本资料，肯定也需要同步删除和这个人员相关的所有资料。这些数据库操作语句就构成了一个事务。</p><p>一个经典的例子，银行转账。你要给小张转 100 块钱，并且现在你的账户只有 100 块钱。转账过程中肯定会涉及到一系列针对金额的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完了，你还没做减法之前，你完全可以再次给小张转账 100 元。如果是这样的话，银行就会造成大量的坏账了。这个时候就需要用到事务这个概念了。</p><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。不能出现一个操作是成功的，另一个操作失败的情况。在 MySQL 中，事务支出是在引擎层实现的。MySQL 是一个支持多引擎的系统，但不是所有的引擎都支持事务操作的。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是为什么现在 InnoDB 逐渐取代 MyISAM 的原因之一。</p><p>MySQL 的事务特性一共四个：</p><ul><li>原子性（Atomicity）</li></ul><p><strong>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。</strong></p><ul><li>一致性（Consistency）</li></ul><p> <strong>数据库总是从一个一致性的状态转换到另一个一致性的状态</strong>。</p><ul><li>隔离性（Isolation）</li></ul><p><strong>一个事务所做的修改在最终提交以前，对其他事务是不可见的</strong>。</p><ul><li>持久性（Durability）</li></ul><p><strong>一旦事务提交，则其所做的修改会永久保存到数据库</strong>。</p><p>按照严格的标准来说，只有同时满足 ACID特性才是事务。</p><h3 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h3><ul><li>BEGIN 或 START TRANSACTION 显式地开启一个事务；</li><li>COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；</li><li>ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li><li>SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；</li><li>RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li><li>ROLLBACK TO identifier 把事务回滚到标记点；</li><li>SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</li></ul><h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><p>1、用 BEGIN, ROLLBACK, COMMIT来实现</p><ul><li><strong>BEGIN</strong> 开始一个事务</li><li><strong>ROLLBACK</strong> 事务回滚</li><li><strong>COMMIT</strong> 事务确认</li></ul><p>2、直接用 SET 来改变 MySQL 的自动提交模式:</p><ul><li><strong>SET AUTOCOMMIT&#x3D;0</strong> 禁止自动提交</li><li><strong>SET AUTOCOMMIT&#x3D;1</strong> 开启自动提交</li></ul><h3 id="事务并发可能出现的情况"><a href="#事务并发可能出现的情况" class="headerlink" title="事务并发可能出现的情况"></a>事务并发可能出现的情况</h3><h4 id="1、脏读"><a href="#1、脏读" class="headerlink" title="1、脏读"></a>1、脏读</h4><p>一个事务读到了另一个未提交事务修改过的数据。脏读旨在读未提交隔离级别才会出现。</p><h4 id="2、不可重复读"><a href="#2、不可重复读" class="headerlink" title="2、不可重复读"></a>2、不可重复读</h4><p>一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询到最新的值。不可重复读在读未提交和读已提交隔离级别都可能会出现。</p><h4 id="3、幻读"><a href="#3、幻读" class="headerlink" title="3、幻读"></a>3、幻读</h4><p>一个事务先根据某些查询条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询的时候，能把另一个事务插入的记录也读出来。幻读在读未提交、读已提交、可重复读隔离级别都可能会出现。</p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>当数据库上有多个事务同时在执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p><p>在谈隔离级别之前，我们首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。</p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112091745966.png" alt="image-20211209174512646" style="zoom: 50%;" /><ul><li>读未提交</li></ul><p>一个事务还没提交时，它做的变更就能被别的事务看到。</p><ul><li>读提交</li></ul><p>一个事务提交之后，它做的变更才会被其他事务看到。但是这样会导致在当前事务的不同时间读取同一条数据会出现获取的结果不一致的情况出现。</p><p>举个例子，在下面的例子中就会发现SessionA在一个事务期间两次查询的数据不一样。原因就是在于当前隔离级别为 RC，SessionA的事务可以读取到SessionB提交的最新数据。</p><img src="/Users/zhangweijie/Library/Application Support/typora-user-images/image-20211209175339234.png" alt="image-20211209175339234" style="zoom:50%;" /><ul><li>可重复读</li></ul><p>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</p><img src="/Users/zhangweijie/Library/Application Support/typora-user-images/image-20211209175652604.png" alt="image-20211209175652604" style="zoom:50%;" /><ul><li>串行化</li></ul><p>顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。当前隔离级别下只支持单个请求同时执行，所有的操作都需要队列执行。所以这种隔离级别下所有的数据是最稳定的，但是性能也是最差的。数据库的锁实现就是这种隔离级别的更小粒度版本。银行的 ATM机器使用的应该就是这种隔离级别。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装 RabbitMQ</title>
    <link href="/2021/12/08/%E5%AE%89%E8%A3%85%20RabbitMQ/"/>
    <url>/2021/12/08/%E5%AE%89%E8%A3%85%20RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h2 id="Ubuntu-18-04"><a href="#Ubuntu-18-04" class="headerlink" title="Ubuntu 18.04"></a>Ubuntu 18.04</h2><h2 id="Install-RabbitMQ-signing-key"><a href="#Install-RabbitMQ-signing-key" class="headerlink" title="Install RabbitMQ signing key"></a>Install RabbitMQ signing key</h2><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">curl -fsSL https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/rabbitmq/</span>signing-keys<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/2.0/</span>rabbitmq-release-signing-key.asc | sudo apt-key add -<br></code></pre></td></tr></table></figure><h2 id="Install-apt-HTTPS-transport"><a href="#Install-apt-HTTPS-transport" class="headerlink" title="Install apt HTTPS transport"></a>Install apt HTTPS transport</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">sudo</span> apt-get install apt-trans<span class="hljs-keyword">port</span>-https<br></code></pre></td></tr></table></figure><h2 id="Add-Bintray-repositories-that-provision-latest-RabbitMQ-and-Erlang-21-x-releases"><a href="#Add-Bintray-repositories-that-provision-latest-RabbitMQ-and-Erlang-21-x-releases" class="headerlink" title="Add Bintray repositories that provision latest RabbitMQ and Erlang 21.x releases"></a>Add Bintray repositories that provision latest RabbitMQ and Erlang 21.x releases</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo tee <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list.d/</span>bintray.rabbitmq.list &lt;&lt;EOF<br>deb https:<span class="hljs-regexp">//</span>dl.bintray.com<span class="hljs-regexp">/rabbitmq-erlang/</span>debian bionic erlang-<span class="hljs-number">21</span>.x<br>deb https:<span class="hljs-regexp">//</span>dl.bintray.com<span class="hljs-regexp">/rabbitmq/</span>debian bionic main<br>EOF<br></code></pre></td></tr></table></figure><h2 id="Update-package-indices"><a href="#Update-package-indices" class="headerlink" title="Update package indices"></a>Update package indices</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span> -y<br></code></pre></td></tr></table></figure><h2 id="Install-rabbitmq-server-and-its-dependencies"><a href="#Install-rabbitmq-server-and-its-dependencies" class="headerlink" title="Install rabbitmq-server and its dependencies"></a>Install rabbitmq-server and its dependencies</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> install rabbitmq-<span class="hljs-keyword">server</span> -y <span class="hljs-comment">--fix-missing</span><br></code></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 启动rabbitmq服务</span><br>sudo service rabbitmq-server start<br><span class="hljs-comment"># 关闭rabbitmq服务</span><br>sudo service rabbitmq-server stop<br><span class="hljs-comment"># 重启服务</span><br>sudo service rabbitmq-server restart<br><span class="hljs-comment"># 查看服务运行状态</span><br>sudo service rabbitmq-server status<br><br><span class="hljs-comment"># 用systemctl管理rabbitmq-server服务</span><br>sudo ln -s <span class="hljs-regexp">/lib/</span>systemd<span class="hljs-regexp">/system/</span>rabbitmq-server.service  <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/</span>rabbitmq-server.service<br></code></pre></td></tr></table></figure><p>rabbitmq既可以命令行操作，也可以用rabbitmq自带的web管理界面，只需要启动插件便可以使用。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo rabbitmqctl start_app<br>sudo rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_management<br></code></pre></td></tr></table></figure><p>然后通过浏览器访问，如果是本机则可以输入<a href="http://127.0.0.1:15672打开登录界面，输入用户名和密码访问web管理界面了。默认用户名guest密码guest。">http://127.0.0.1:15672打开登录界面，输入用户名和密码访问web管理界面了。默认用户名guest密码guest。</a> 如果访问登录失败说明没有开启超级管理员登录。</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs nsis">新建用户<br>sudo rabbitmqctl add_user  <span class="hljs-literal">admin</span>  passwd<br><br>赋予权限<br>sudo rabbitmqctl set_user_tags <span class="hljs-literal">admin</span> administrator<br><br>赋予virtual host中所有资源的配置、写、读权限以便管理其中的资源，也是添加远程访问权限<br>sudo rabbitmqctl  set_permissions -p / <span class="hljs-literal">admin</span> <span class="hljs-string">&#x27;.*&#x27;</span> <span class="hljs-string">&#x27;.*&#x27;</span> <span class="hljs-string">&#x27;.*&#x27;</span><br><br>基本操作：<br>sudo rabbitmqctl <span class="hljs-comment"># 查看所有命令和帮助文档</span><br>sudo rabbitmqctl stop <span class="hljs-comment"># 停止服务</span><br>sudo rabbitmqctl status <span class="hljs-comment"># 查看服务状态</span><br>sudo rabbitmqctl list_users <span class="hljs-comment"># 查看当前所有用户</span><br>sudo rabbitmqctl list_user_permissions guest <span class="hljs-comment"># 查看默认guest用户的权限</span><br>sudo rabbitmqctl delete_user guest <span class="hljs-comment"># 删掉默认用户(由于RabbitMQ默认的账号用户名和密码都是guest。为了安全起见, 可以删掉默认用户）</span><br>sudo rabbitmqctl add_user username password <span class="hljs-comment"># 添加新用户</span><br>sudo rabbitmqctl set_user_tags username administrator<span class="hljs-comment"># 设置用户tag</span><br>sudo rabbitmqctl set_permissions -p / username <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-comment"># 赋予用户默认vhost的全部操作权限</span><br>sudo rabbitmqctl list_user_permissions username <span class="hljs-comment"># 查看用户的权限</span><br>rabbitmqctl set_user_tags <span class="hljs-literal">User</span> Tag<br><span class="hljs-literal">User</span>为用户名， Tag为角色名(对应于上面的administrator，monitoring，policymaker，management，或其他自定义名称)。<br><br><br>URL连接格式<br>CELERY_BROKER_URL=amqp://bs_whatweb:nbfuy7gh56@<span class="hljs-number">192.168</span>.<span class="hljs-number">199.149</span>:<span class="hljs-number">5672</span>/vhost_name<br></code></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">端口说明<br><span class="hljs-number">4369</span>  <span class="hljs-comment">-- erlang发现口 </span><br><span class="hljs-number">5672</span>  <span class="hljs-comment">-- client端通信口 </span><br><span class="hljs-number">15672</span> <span class="hljs-comment">-- 管理界面ui端口 </span><br><span class="hljs-number">25672</span> <span class="hljs-comment">-- server间内部通信口</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 日志及数据备份恢复</title>
    <link href="/2021/12/07/MySQL%20%E6%97%A5%E5%BF%97%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/"/>
    <url>/2021/12/07/MySQL%20%E6%97%A5%E5%BF%97%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL-日志及数据备份恢复"><a href="#MySQL-日志及数据备份恢复" class="headerlink" title="MySQL 日志及数据备份恢复"></a>MySQL 日志及数据备份恢复</h1><h2 id="MySQL三种日志详解"><a href="#MySQL三种日志详解" class="headerlink" title="MySQL三种日志详解"></a>MySQL三种日志详解</h2><h3 id="1、日志"><a href="#1、日志" class="headerlink" title="1、日志"></a>1、日志</h3><p>日志是 <code>MySQL</code> 数据库的重要组成部分，记录数据库运行时期的各种状态信息。<code>MySQL</code>日志主要包括错误日志、查询日志、 慢查询日志、事务日志、二进制日志几大类。作为开发，我们重点需要关注二进制日志（<code>binlog</code>）和事务日志（<code>redolog</code>和<code>undolog</code>）</p><ul><li>简单对比</li></ul><table><thead><tr><th>日志</th><th>物理日志</th><th>逻辑日志</th><th>定义</th><th>作用</th></tr></thead><tbody><tr><td>redo log</td><td>InnoDB存储引擎层的日志</td><td>N</td><td>重做日志</td><td>事务的原子性和持久性</td></tr><tr><td>undo log</td><td>N</td><td>Y</td><td>回滚日志</td><td>事务一致性，事务的回滚和实现mvcc</td></tr><tr><td>binlog</td><td>N</td><td>MySQL Server层记录的日志</td><td>归档日志</td><td>主从数据同步,数据恢复</td></tr></tbody></table><ul><li><strong>逻辑日志</strong>：可以简单理解为记录的就是sql语句 。</li><li><strong>物理日志</strong>：<code>mysql</code> 数据最终是保存在数据页中的，物理日志记录的就是数据页变更</li></ul><h3 id="2、redo-log"><a href="#2、redo-log" class="headerlink" title="2、redo log"></a>2、redo log</h3><p><code>redolog</code>包括两部分，一个是内存中的日志缓冲（<code>redo log buffer</code>），另一种是磁盘上的日志文件（<code>redo log file</code>）。<code>MySQL</code>每次执行一条 DML 语句，现将记录写入到 <code>redo log bufer</code>，然后再后续的某个合适的时间再一次性将多个操作记录写入到 <code>redo log file</code> 中。这种先写日志再写磁盘的技术就是 <code>WAl（Write-Ahead Logging）</code>技术。</p><p><code>redo log</code> 是 InnoDB 存储引擎层的日志文件，也叫做重做日志文件，用于记录事务操作的变化，记录的是数据修改后的值，不管事务是否提交都会被记录下来。在实例和介质失败时，redo log 文件就能排上用场，例如数据库断电，InnoDB 存储引擎会使用<code>redo log</code> 恢复到断电前的时刻，以此来保证数据的完整性。另外数据库也有了 <code>crash-safe</code> 能力。</p><p><code>redo log</code> 的日志大小是固定的，记录满了以后需要从头循环重新写。比如可以配置一组4个文件，每个文件大小是 1GB，那么 <code>redo log</code> 中可以记录 4GB 的操作，InnoDB 会从第一个文件开始写入，直到第四个文件写满了，又回到第一个文件开头循环写，如下图。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112071620719.png" alt="image-20211207162002931"></p><p><code>write pos</code>是记录当前的位置，一边写一边往后移，写到第四个文件的末尾后就回到第一个文件开头。<code>check point</code>是当前要擦除的位置，也是往后推移并且循环的，擦除记录之前要把记录更新到数据文件中。<code>write pos</code>和 <code>check point</code>之间的就是 <code>redo log</code>上还空着的部分，也是可以用来记录新的操作的部分。如果 <code>write pos</code>追上了 <code>check point</code>，表示 <code>redo log</code> 满了，这个时候不能再执行新的更新，得停下来先擦掉一些记录，把 <code>check point</code> 往前推进一下。</p><ul><li>redo log 参数说明及刷盘机制</li></ul><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112071630637.png" alt="image-20211207163010462"></p><h3 id="2、undolog"><a href="#2、undolog" class="headerlink" title="2、undolog"></a>2、undolog</h3><p>数据库事务四大特性中有一个是原子性，具体来说就是 原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况。</p><p>实际上，原子性底层就是通过 <code>undo log</code> 来实现的。 <code>undo log</code> 主要记录了数据的逻辑变化，比如一条 <code>insert</code> 语句，对应一条 <code>delete</code> 的 undo log。对于每个 <code>update</code> 语句，对应一条相反的 <code>update</code> 的 <code>undo log</code>，这样在发生错误的时候，就能回滚到事务之前的数据状态。</p><p>此外，保存了事务发生之前的数据的一个版本，还有另外的作用：</p><ul><li>可以用于回滚</li><li>同时可以提供多版本并发控制下的读（MVCC），非锁定读</li><li>事务开始前，将当前事务版本生成 <code>undo log</code>，undo log 也会生成 <code>redo log</code> 来保证 <code>undo log</code> 的可靠性</li><li>当事务提交以后，<code>undo log</code> 并不能马上被删除，而是放入待清理的链表中，由 <code>purge 线程</code>判断是否还有其他事务在使用 undo 表的上一个事务之前的版本信息，从而决定是否可以清理 <code>undo log</code> 的日志空间</li></ul><h3 id="4、binlog"><a href="#4、binlog" class="headerlink" title="4、binlog"></a>4、binlog</h3><p><code>binlog</code>二进制日志是 server 层的日志，无论 <code>MySQL</code>使用什么类型的引擎，都会存在这种日志。日志的主要作用是主从复制和时间点恢复。另外需要注意，<code>binglog</code> 并不记录查询语句。</p><ul><li>主从复制：在 <code>master</code> 端开启 <code>binlog</code>，然后将 <code>binlog</code> 发送到各个 <code>slave</code> 端，<code>slave</code> 端重放 <code>binlog</code>，从而达到主从数据一致</li><li>数据恢复：通过使用 <code>mysqlbinlog</code> 工具来恢复数据</li></ul><p><code>binlog</code> 是属于 <code>MySQL Server</code>层面，又称为归档日志，属于逻辑日志，是以二进制的形式存在。记录的是操作语句的原始逻辑，仅仅依靠 <code>binlog</code> 是没有 <code>crash-safe</code> 能力的。<code>binlog</code> 不会想 <code>redolog</code> 那样擦掉之前的记录然后循环写，而是一直记录（超过有效期才会被清理），如果超过单日志的最大值（默认为 1G，可通过变量 <code>max_binlog_size</code>设置），则会新起一个文件继续记录。但是由于日志可能是基于事务来记录的，而事务是绝对不可能也不应该跨文件记录，所以如果正好 <code>binlog</code> 日志达到最大值但是事务还没有提交则不会切换新的文件记录，而是继续增大日志。所以 <code>max_binlog_size</code> 指定的值和实际的 <code>binlog</code> 日志大小不一定相等。</p><p><code>binlog</code> 可以用于主从复制，从库利用主库的 <code>binlog</code> 进行重播，实现主从同步。用于数据库的基于时间点，位点等的还原操作。<code>binlog</code> 的模式有三种：<code>Statement，Row，Mixed</code>。在 MySQL5.7.7 之前，默认的格式是 <code>Statement</code>，之后默认是 <code>Row</code>。日志格式通过 <code>binlog-format</code> 指定。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112071646769.png" alt="image-20211207164649609"></p><h2 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h2><ul><li>恢复流程</li></ul><ol><li>读取 redolog 记录</li><li>从 check point开始，对日志进行重放</li><li>检查 redo log中那些事务是完整的并且处于 prepare 状态</li><li>根据 XID（事务 ID） 对照 binlog 的事务，并检查事务是否完整</li><li>事务完整，重新设置redo log 的 commit 标识</li><li>事务不完整则根据 XID 找到 undo log 进行事务回滚</li></ol><p>下面我们根据事务提交流程，在不同的阶段时刻，看看MySQL突然奔溃后，按照上述流程是如何恢复数据的。</p><ol><li><p><strong>时刻A</strong>（刚在内存中更改完数据页，还没有开始写redo log的时候奔溃）：</p><p>因为内存中的脏页还没刷盘，也没有写redo log和binlog，即这个事务还没有开始提交，所以奔溃恢复跟该事务没有关系；</p></li><li><p><strong>时刻B</strong>（正在写redo log或者已经写完redo log并且落盘后，处于prepare状态，还没有开始写binlog的时候奔溃）：</p><p>恢复后会判断redo log的事务是不是完整的，如果不是则根据undo log回滚；如果是完整的并且是prepare状态，则进一步判断对应的事务binlog是不是完整的，如果不完整则一样根据undo log进行回滚；</p></li><li><p><strong>时刻C</strong>（正在写binlog或者已经写完binlog并且落盘了，还没有开始commit redo log的时候奔溃）：</p><p>恢复后会跟时刻B一样，先检查redo log中是完整并且处于prepare状态的事务，然后判断对应的事务binlog是不是完整的，如果不完整则一样根据undo log回滚，完整则重新commit redo log；</p></li><li><p><strong>时刻D</strong>（正在commit redo log或者事务已经提交完的时候，还没有反馈成功给客户端的时候奔溃）：</p><p>恢复后跟时刻C基本一样，都会对照redo log和binlog的事务完整性，来确认是回滚还是重新提交。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>redo log</code> 用来保证 <code>crash-safe</code>，<code>binlog</code> 用来保证可以将数据库状态恢复到任一时刻，<code>undo log</code> 是用来保证事务需要回滚时数据状态的回滚和 <code>MVCC</code> 时，记录各版本数据信息。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 存储引擎原理</title>
    <link href="/2021/11/18/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8E%9F%E7%90%86/"/>
    <url>/2021/11/18/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="1、MySQL存储引擎原理"><a href="#1、MySQL存储引擎原理" class="headerlink" title="1、MySQL存储引擎原理"></a>1、MySQL存储引擎原理</h3><h4 id="1-1-MySQL-记录存储"><a href="#1-1-MySQL-记录存储" class="headerlink" title="1.1 MySQL 记录存储"></a>1.1 MySQL 记录存储</h4><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202111182124271.png" alt="image-20211118212416725"></p><ul><li>页头</li></ul><p>记录页面的控制信息，共占 56 字节，包括也得左右兄弟页面指针，页面空间使用情况等</p><ul><li>虚记录</li></ul><p>最大虚记录：比页内最大主键还大</p><p>最小虚记录：比页内最小主键还小</p><ul><li>记录堆</li></ul><p>行记录存储区，分为有效记录和已删除记录，每个记录大小都可能不相同</p><ul><li>自由空间链表</li></ul><p>已删除记录组成的链表</p><ul><li>未分配空间</li></ul><p>页面为使用的存储空间</p><ul><li>页尾</li></ul><p>页面最后的部分，占 8个字节，主要存储页面的校验信息</p><h4 id="1-2-页内记录维护"><a href="#1-2-页内记录维护" class="headerlink" title="1.2 页内记录维护"></a>1.2 页内记录维护</h4><ul><li>顺序保证</li></ul><p>物理有序：每次插入新的数据的时候，都会进行数据的移动，例如一个链表为<code>【7，8，10】</code>，当我们需要插入 9 的时候，需要把 10 后移一位，然后把 9 插入。这样会当我们进行查询的时候会非常方便，因为都在一块连续的内存空间中，并且数据是有序的，但是删除、更新、插入都会造成极大的性能消耗</p><p>逻辑有序：每次插入新的数据的时候，只需要将链表的指针指向新的数据即可。例如 <code>【7，8，10】</code>，当我们需要插入 9 的时候，只需要将 8 的后指针从 10 指向 9，然后将 9 的后指针指向 10即可，这样做会减少性能的消耗，同时达到较好的数据操作效果。不过此时数据并不在一块连续的内存空间中，所以查询效率不如物理有序。但 MySQL仍选择这种方式作为顺序保证</p><ul><li>插入策略</li></ul><p>自由空间链表：当数据被删除后会出现自由空间，但是这些自由空间的数据并不是被物理删除，因为物理删除也会造成资源消耗，所以删除后只会增加一个删除标识，标志着这块空间可以被新数据覆盖。</p><p>未使用空间：当页面不存在自由空间链表后及使用未使用空间</p><ul><li>页内查询</li></ul><p>遍历：</p><p>二分查找：使用</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查看 Docker 容器资源使用</title>
    <link href="/2021/11/08/%E6%9F%A5%E7%9C%8B%20docker%20%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/11/08/%E6%9F%A5%E7%9C%8B%20docker%20%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="查看-docker-容器资源使用"><a href="#查看-docker-容器资源使用" class="headerlink" title="查看 docker 容器资源使用"></a>查看 docker 容器资源使用</h1><p>在容器的使用过程中，如果能及时的掌握容器使用的系统资源，无论对开发还是运维工作都是非常有益的。幸运的是 docker 自己就提供了这样的命令：docker stats。</p><h2 id="默认输出"><a href="#默认输出" class="headerlink" title="默认输出"></a>默认输出</h2><p>docker stats 命令用来显示容器使用的系统资源。不带任何选项执行 docker stats 命令：</p><figure class="highlight crystal"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>docker stats<br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081045935.png" alt="img"></p><p>默认情况下，stats 命令会每隔 1 秒钟刷新一次输出的内容直到你按下 ctrl + c。下面是输出的主要内容：<br>[<strong>CONTAINER</strong>]：以短格式显示容器的 ID。<br>[<strong>CPU %</strong>]：CPU 的使用情况。<br>[<strong>MEM USAGE &#x2F; LIMIT</strong>]：当前使用的内存和最大可以使用的内存。<br>[<strong>MEM %</strong>]：以百分比的形式显示内存使用情况。<br>[<strong>NET I&#x2F;O</strong>]：网络 I&#x2F;O 数据。<br>[<strong>BLOCK I&#x2F;O</strong>]：磁盘 I&#x2F;O 数据。<br>[<strong>PIDS</strong>]：PID 号。</p><h2 id="只返回当前的状态"><a href="#只返回当前的状态" class="headerlink" title="只返回当前的状态"></a>只返回当前的状态</h2><p>如果不想持续的监控容器使用资源的情况，可以通过 –no-stream 选项只输出当前的状态：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> docker stats --<span class="hljs-keyword">no</span>-stream<br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081045858.png" alt="img"></p><p>这样输出的结果就不会变化了，看起来省劲不少。</p><h2 id="只输出指定的容器"><a href="#只输出指定的容器" class="headerlink" title="只输出指定的容器"></a>只输出指定的容器</h2><p>如果我们只想查看个别容器的资源使用情况，可以为 docker stats 命令显式的指定目标容器的名称或者是 ID：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> docker stats --<span class="hljs-keyword">no</span>-stream registry <span class="hljs-number">1493</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081045981.png" alt="img"></p><p>当有很多的容器在运行时，这样的结果看起来会清爽一些。这里的 registry 和 1493 分别是容器的名称和容器的 ID。注意，多个容器的名称或者是 ID 之间需要用空格进行分割。</p><p>细心的同学可能已经发现了，第一列不再显示默认的容器 ID，而是显示了我们传入的容器名称和 ID。基于此，我们可以通过简单的方式使用容器的名称替代默认输出中的容器 ID：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">$ docker stats <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">ps</span> --<span class="hljs-params">format</span>=&#123;&#123;.Names&#125;&#125;)</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081045866.png" alt="img"></p><p>用容器的名称替代 ID 后输出的结果是不是友好一些？</p><h2 id="格式化输出的结果"><a href="#格式化输出的结果" class="headerlink" title="格式化输出的结果"></a>格式化输出的结果</h2><p>我们在前面搞了点小手段把输出中的容器 ID 替换成了名称。其实 docker stats 命令支持我们通过 –format 选项自定义输出的内容和格式：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">$ docker stats --format &quot;table </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.Name</span>&#125;&#125;</span><span class="language-xml">\t</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.CPUPerc</span>&#125;&#125;</span><span class="language-xml">\t</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.MemUsage</span>&#125;&#125;</span><span class="language-xml">&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081045213.png" alt="img"></p><p>上面的命令中我们只输出了 Name, CPUPerc 和 Memusage 三列。下面是自定义的格式中可以使用的所有占位符：<br>.Container   根据用户指定的名称显示容器的名称或 ID。<br>.Name      容器名称。<br>.ID         容器 ID。<br>.CPUPerc    CPU 使用率。<br>.MemUsage 内存使用量。<br>.NetIO      网络 I&#x2F;O。<br>.BlockIO     磁盘 I&#x2F;O。<br>.MemPerc   内存使用率。<br>.PIDs       PID 号。<br>有了这些信息我们就可以完全按照自己的需求或者是偏好来控制 docker stats 命令输出的内容了。</p><p>除了以 table 格式输出结果，还可以通过 format 选项输出 json 格式的结果：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lsl">$ docker stats --no-stream --format \<br>    <span class="hljs-string">&quot;&#123;<span class="hljs-subst">\&quot;</span>container<span class="hljs-subst">\&quot;</span>:<span class="hljs-subst">\&quot;</span>&#123;&#123; .Container &#125;&#125;<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\&quot;</span>memory<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\&quot;</span>raw<span class="hljs-subst">\&quot;</span>:<span class="hljs-subst">\&quot;</span>&#123;&#123; .MemUsage &#125;&#125;<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\&quot;</span>percent<span class="hljs-subst">\&quot;</span>:<span class="hljs-subst">\&quot;</span>&#123;&#123; .MemPerc &#125;&#125;<span class="hljs-subst">\&quot;</span>&#125;,<span class="hljs-subst">\&quot;</span>cpu<span class="hljs-subst">\&quot;</span>:<span class="hljs-subst">\&quot;</span>&#123;&#123; .CPUPerc &#125;&#125;<span class="hljs-subst">\&quot;</span>&#125;&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081045842.png" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过 docker stats 命令我们可以看到容器使用系统资源的情况。这为我们进一步的约束容器可用资源或者是调查与资源相关的问题提供了依据。除了 docker 自带的命令，像 glances 等工具也已经支持查看容器使用的资源情况了，有兴趣的朋友可以去了解一下。</p>]]></content>
    
    
    <categories>
      
      <category>容器化</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 Docker 无法使用容器名字进行容器间链接==连接的问题</title>
    <link href="/2021/10/14/%E5%85%B3%E4%BA%8E%20docker%20%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E5%90%8D%E5%AD%97%E8%BF%9B%E8%A1%8C%E5%AE%B9%E5%99%A8%E9%97%B4%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/10/14/%E5%85%B3%E4%BA%8E%20docker%20%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E5%90%8D%E5%AD%97%E8%BF%9B%E8%A1%8C%E5%AE%B9%E5%99%A8%E9%97%B4%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="关于-docker-无法使用容器名字进行容器间连接的问题"><a href="#关于-docker-无法使用容器名字进行容器间连接的问题" class="headerlink" title="关于 docker 无法使用容器名字进行容器间连接的问题"></a>关于 docker 无法使用容器名字进行容器间连接的问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><strong>项目名称 : domain-search</strong></p><p>原始 endpoint.sh 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Waiting for postgres...&quot;</span><br><br><span class="hljs-keyword">while</span> ! nc -z domain-search-db 5432; <span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">sleep</span> 0.1<br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;PostgreSQL started&quot;</span><br></code></pre></td></tr></table></figure><p>原始 docker-compose 文件</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><br><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">domain-search</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">domain-search</span><br>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">domain-search</span><br>    <span class="hljs-attribute">build</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">context</span><span class="hljs-punctuation">:</span> <span class="hljs-string">./services/domain-search</span><br>      <span class="hljs-attribute">dockerfile</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Dockerfile-dev</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./services/domain-search:/usr/src/app&quot;</span><br>    <span class="hljs-attribute">restart</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">5013:5000</span><br>    <span class="hljs-attribute">env_file</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">domain-search-dev.env</span><br>    <span class="hljs-attribute">depends_on</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">domain-search-db</span><br><br>  <span class="hljs-attribute">domain-search-db</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">domain-search-db</span><br>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">domain-search-db</span><br>    <span class="hljs-attribute">build</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">context</span><span class="hljs-punctuation">:</span> <span class="hljs-string">./services/domain-search/project/db</span><br>      <span class="hljs-attribute">dockerfile</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Dockerfile</span><br>    <span class="hljs-attribute">restart</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">5443:5432</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_USER=postgres</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_PASSWORD=postgres</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_DB=postgres</span><br>      <br></code></pre></td></tr></table></figure><p>以上的文件配置可以使用容器名字进行连接</p><hr><p>​        新版 docker-compose文件</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs clean">version: <span class="hljs-string">&quot;3.7&quot;</span><br><br>services:<br>  domain-search:<br>    image: domain-search<br>    container_name: domain-search<br>    build:<br>      context: ./services/domain-search<br>      dockerfile: Dockerfile-dev<br>    volumes:<br>      - <span class="hljs-string">&quot;./services/domain-search:/usr/src/app&quot;</span><br>      <br>      ################# 新增文件挂载 #################<br>      - <span class="hljs-string">&quot;/Desktop/workspace/all-domain/domain-search/nameserver.txt:/etc/resolv.conf&quot;</span><br>      ##############################################<br>      <br>      <br>    restart: always<br>    ports:<br>      - <span class="hljs-number">5013</span>:<span class="hljs-number">5000</span><br>    env_file:<br>      - domain-search-dev.env<br>    depends_on:<br>      - domain-search-db<br><br>  domain-search-db:<br>    image: domain-search-db<br>    container_name: domain-search-db<br>    build:<br>      context: ./services/domain-search/project/db<br>      dockerfile: Dockerfile<br>    restart: always<br>    ports:<br>      - <span class="hljs-number">5443</span>:<span class="hljs-number">5432</span><br>    environment:<br>      - POSTGRES_USER=postgres<br>      - POSTGRES_PASSWORD=postgres<br>      - POSTGRES_DB=postgres<br>      <br></code></pre></td></tr></table></figure><p>​        挂载文件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nameserver</span> <span class="hljs-number">222.88.88.88</span>  <span class="hljs-comment"># 河南电信</span><br>nameserver <span class="hljs-number">223.5.5.5</span>  <span class="hljs-comment"># alidns</span><br>nameserver <span class="hljs-number">223.6.6.6</span>  <span class="hljs-comment"># alidns</span><br>nameserver <span class="hljs-number">180.76.76.76</span>  <span class="hljs-comment"># baidudns</span><br>nameserver <span class="hljs-number">119.29.29.29</span>  <span class="hljs-comment"># tendns</span><br>nameserver <span class="hljs-number">208.67.222.222</span>  <span class="hljs-comment"># OpenDNS</span><br>nameserver <span class="hljs-number">208.67.220.220</span>  <span class="hljs-comment"># OpenDNS</span><br>nameserver <span class="hljs-number">114.114.114.114</span>  <span class="hljs-comment"># 114DNS</span><br>nameserver <span class="hljs-number">1.1.1.1</span>  <span class="hljs-comment"># CloudFlare DNS</span><br>nameserver <span class="hljs-number">101.226.4.6</span>  <span class="hljs-comment"># DNS 派</span><br>nameserver <span class="hljs-number">218.30.118.6</span>  <span class="hljs-comment"># DNS 派</span><br></code></pre></td></tr></table></figure><p>当我们挂载进去的文件修改了 docker 容器内部的网络解析功能，就无法用容器名字进行连接，会显示  <strong>forward host lookup failed: Unknown host</strong></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>新版 endpoint.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Waiting for postgres...&quot;</span><br><br><span class="hljs-keyword">while</span> ! nc -z <span class="hljs-variable">$PG_HOST</span> <span class="hljs-variable">$PG_PORT</span>; <span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">sleep</span> 0.1<br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;PostgreSQL started&quot;</span><br></code></pre></td></tr></table></figure><p>直接使用需要连接的容器的  <strong>host</strong>  及  <strong>port</strong>  进行连接</p><h3 id="最后提示"><a href="#最后提示" class="headerlink" title="最后提示"></a>最后提示</h3><ul><li>不要随便修改 docker 容器内部的配置</li><li>对于底层配置的修改记得添加注释</li></ul>]]></content>
    
    
    <categories>
      
      <category>容器化</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>容器连接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列选型</title>
    <link href="/2021/09/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%80%89%E5%9E%8B/"/>
    <url>/2021/09/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%80%89%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="MQ-知识点"><a href="#MQ-知识点" class="headerlink" title="MQ 知识点"></a>MQ 知识点</h2><h3 id="1、什么是-MQ-？"><a href="#1、什么是-MQ-？" class="headerlink" title="1、什么是 MQ ？"></a>1、什么是 MQ ？</h3><p>MQ 即为消息队列，是服务间一种异步通信的方式，适用于无服务器和微服务架构。消息在删除和处理之前一直存储在队列上，每条消息可被一个或者多个消费者进行消费。消息队列可用于服务间的解耦，分离重量级处理、缓冲或批处理工作以及缓解高峰期工作负载。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202109031525737.png" alt="image-20210903152500688"></p><hr><h4 id="为什么我们需要消息队列？"><a href="#为什么我们需要消息队列？" class="headerlink" title="为什么我们需要消息队列？"></a>为什么我们需要消息队列？</h4><p>​        当公司的业务非常单一，并且数据量没有那么大的时候，我们采用单机架构完全可以很好的满足业务的需求，虽然这样系统的扩展性很差，但是要牢记一点，技术是为业务服务的，没有必要为了使用新技术而使用新技术。</p><p>​        当公司的业务复杂度逐渐增加，相对应的数据量也会有爆炸式的增长。这个时候再采用单机同步服务的方式确实不太适合。因为业务复杂度上来以后，会有非常多的业务节点。如果其中一个业务节点非常耗时，那会导致整个业务流都非常耗时，从而带来非常差的用户体验。</p><p>​        例如数据中心，当我们添加一条主域名后，后续会进行域名爆破、域名解析、域名数据汇总等任务，单个任务都会有几十秒甚至是几分钟的耗时，如果一直等待着，那用户肯定会认为是系统出了问题。这个时候我们只能采用异步的方式将这些任务分发下去同时执行。然后再统一汇总结果，更改数据库的数据。但是从用户角度来看，我添加了一个域名，那立刻就能在数据中心看到我的数据了。当后续的任务数据汇总过来以后，还能看到更多的数据，对用户体验很好。</p><p>​        提到了异步任务，就会有消息队列。我们各个服务之间的相互调用，消息队列是最为稳妥的方式。使用接口会有网络的抖动等问题，直接调用对方的数据库更加不可取。消息队列采用生产者-消费者模型，能将我们的消息很好的进行分发传输，每个服务只需要接收属于自己服务的消息，然后进行自己的业务逻辑就行，服务直接可以解耦。</p><h3 id="2、MQ-的优点"><a href="#2、MQ-的优点" class="headerlink" title="2、MQ 的优点"></a>2、MQ 的优点</h3><ul><li>异步处理 – 相比于传统的串行、并行方式，提高了系统的吞吐量</li><li>应用解耦 – 各个系统之间通过消息通信，不用关心其他系统的处理，甚至不关心他们处理的结果为失败还是成功</li><li>流量削峰 – 可以通过消息队列长度控制请求量；可以缓解短时间内的大量请求</li><li>日志处理 – 解决大量日志传输问题  （也可以使用 ELK 解决日志问题）</li><li>消息通讯 – 消息队列一般都内置了高效的通信机制，因此可以当做一个简单的消息通讯工具</li></ul><h3 id="3、MQ-的缺点"><a href="#3、MQ-的缺点" class="headerlink" title="3、MQ 的缺点"></a>3、MQ 的缺点</h3><ul><li>降低系统的可用性 – 每个服务之间虽然解耦，但是还是都通过消息队列进行通信，一旦消息队列挂掉，那整个系统就会崩溃</li><li>提高系统的复杂度 – 每个服务现在不仅要关注自己的逻辑处理程序，还需要关系消息队列的一系列问题，比如消息丢失，消息被重复消费，消息一致性等问题</li><li>整个系统的一致性问题 – 各个服务通过消息队列进行消息传递，但是一旦某个服务依赖于下一个服务的数据，本服务数据已经更改，但是下个服务崩溃或者数据修改未成功，那就会造成系统数据不一致的问题</li></ul><h3 id="4、技术选型问题"><a href="#4、技术选型问题" class="headerlink" title="4、技术选型问题"></a>4、技术选型问题</h3><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202109031556103.png" alt="image-20210903155605079"></p><p> ActiveMQ 作为比较早的消息中间件，在国内应用比较广泛，基础功能也很强大。但是没有办法支撑互联网的高并发、高负载以及高吞吐量的复杂场景，并且在国内的互联网公司落地的比较少，应用的基本都是一些传统企业。</p><p>RabbitMQ 使用更加广泛，并且就可以支撑高并发、高负载、高吞吐量的复杂应用场景，更为关键的是有着友好的、方便快捷的后台管理界面，极大的减少了运维的工作。另外还支持集群化、高可用部署架构，消息高可靠支持，功能很完善。另外，在国内的互联网公司使用的也比较多，各种可复制操作的例子很多。还有就是 RabbitMQ 的社区很活跃，虽然他的语言是 erlang，并不适合研究源码，但是架不住社区很活跃，绝大部分的问题都能在社区进行解决。</p><p>RocketMQ 阿里系出品，适合基础架构研发实力比较强的公司，社区不是很活跃，但是使用了Java 语言进行开发，里边用到的很多设计模式和思路值得学习。</p><p>综上所述，中小型公司更加适合使用RabbitMQ，社区活跃，可用度高。大型公司RabbitMQ 和 RocketMQ 都可以使用。</p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 配置文件相关操作</title>
    <link href="/2021/01/21/Golang%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/01/21/Golang%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-配置文件相关操作"><a href="#Golang-配置文件相关操作" class="headerlink" title="Golang 配置文件相关操作"></a>Golang 配置文件相关操作</h1><blockquote><p>本文以读取数据库配置文件为例</p></blockquote><h2 id="1、JSON-文件"><a href="#1、JSON-文件" class="headerlink" title="1、JSON 文件"></a>1、JSON 文件</h2><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 解析 json 格式的配置文件</span><br><span class="hljs-comment">文件内容如下：</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  &quot;type&quot;: &quot;json&quot;,</span><br><span class="hljs-comment">  &quot;postgres&quot;: &#123;</span><br><span class="hljs-comment">    &quot;host&quot;: &quot;localhost&quot;,</span><br><span class="hljs-comment">    &quot;port&quot;: 5432,</span><br><span class="hljs-comment">    &quot;username&quot;: &quot;postgres&quot;,</span><br><span class="hljs-comment">    &quot;password&quot;: &quot;postgres&quot;,</span><br><span class="hljs-comment">    &quot;dbname&quot;: &quot;bubble&quot;</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">// 定义第一级配置文件的结构体</span><br><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>Type     <span class="hljs-type">string</span><br>Postgres DbConf <span class="hljs-comment">// 数据类型为第二级配置文件的结构体名称</span><br>&#125;<br><br><span class="hljs-comment">// 定义第二级配置文件的结构体   注意数据类型</span><br><span class="hljs-keyword">type</span> DbConf <span class="hljs-keyword">struct</span> &#123;<br>Host     <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;host&quot;`</span><br>Port     <span class="hljs-type">uint</span>   <span class="hljs-string">`json:&quot;port&quot;`</span><br>Username <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;username&quot;`</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;password&quot;`</span><br>DbName   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;dbname&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// 定义配置文件结构体</span><br><span class="hljs-keyword">type</span> JsonStruct <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// 创建配置文件的构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewJsonStruct</span><span class="hljs-params">()</span></span> *JsonStruct &#123;<br><span class="hljs-keyword">return</span> &amp;JsonStruct&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 加载配置文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(jt *JsonStruct)</span></span> Load(filename <span class="hljs-type">string</span>, v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-comment">// 读取配置文件</span><br>data, err := ioutil.ReadFile(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 解析配置文件</span><br>err = json.Unmarshal(data, v)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>JsonParse := NewJsonStruct()<br>v := Config&#123;&#125;<br><span class="hljs-comment">// 获取配置文件路径</span><br>osGwd, _ := os.Getwd()<br>confPath := osGwd + <span class="hljs-string">&quot;/conf_json.json&quot;</span><br><span class="hljs-comment">// 加载配置文件</span><br>JsonParse.Load(confPath, &amp;v)<br>fmt.Printf(<span class="hljs-string">&quot;配置文件的类型为 %s \n&quot;</span>, v.Type)<br>fmt.Printf(<span class="hljs-string">&quot;PG 数据库的配置为 %s \n&quot;</span>, v.Postgres)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2、YAML-文件-推荐"><a href="#2、YAML-文件-推荐" class="headerlink" title="2、YAML 文件(推荐)"></a>2、YAML 文件(<strong>推荐</strong>)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">解析 yaml 格式的配置文件</span><br><span class="hljs-comment">文件内容如下：</span><br><span class="hljs-comment">database:</span><br><span class="hljs-comment">  postgres:</span><br><span class="hljs-comment">    host: localhost</span><br><span class="hljs-comment">    port: 5432</span><br><span class="hljs-comment">    username: postgres</span><br><span class="hljs-comment">    password: postgres</span><br><span class="hljs-comment">    dbname: bubble</span><br><span class="hljs-comment">&#125; */</span><br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;gopkg.in/yaml.v2&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> YamlStruct <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewYamlStruct</span><span class="hljs-params">()</span></span> *YamlStruct &#123;<br><span class="hljs-keyword">return</span> &amp;YamlStruct&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> YamlConfig <span class="hljs-keyword">struct</span> &#123;<br>DataBase DataBase <span class="hljs-string">`yaml:&quot;database&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> DataBase <span class="hljs-keyword">struct</span> &#123;<br>PgConf PgConf <span class="hljs-string">`yaml:&quot;postgres&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> PgConf <span class="hljs-keyword">struct</span> &#123;<br>Host     <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;host&quot;`</span><br>Port     <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;port&quot;`</span><br>Username <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;username&quot;`</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;password&quot;`</span><br>DbName   <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;dbname&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(yam *YamlStruct)</span></span> Load(filename <span class="hljs-type">string</span>, v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>data, err := ioutil.ReadFile(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err.Error())<br>&#125;<br>err = yaml.Unmarshal(data, v)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err.Error())<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>YamlStruct := NewYamlStruct()<br>v := YamlConfig&#123;&#125;<br>osGwd, _ := os.Getwd()<br>confPath := osGwd + <span class="hljs-string">&quot;/conf_yaml.yaml&quot;</span><br>YamlStruct.Load(confPath, &amp;v)<br>fmt.Printf(<span class="hljs-string">&quot;配置文件的数据为 %s \n&quot;</span>, v.DataBase)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3、INI-文件"><a href="#3、INI-文件" class="headerlink" title="3、INI 文件"></a>3、INI 文件</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 解析 ini 格式的配置文件</span><br><span class="hljs-comment">文件内容如下：</span><br><span class="hljs-comment">mode=debug</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">[postgres]</span><br><span class="hljs-comment">host=localhost</span><br><span class="hljs-comment">port=5432</span><br><span class="hljs-comment">username=postgres</span><br><span class="hljs-comment">password=postgres</span><br><span class="hljs-comment">dbname=bubble</span><br><span class="hljs-comment"> */</span><br><br>import (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/go-ini/ini&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">//type Postgres struct &#123;</span><br><span class="hljs-comment">//Host     string</span><br><span class="hljs-comment">//Port     uint</span><br><span class="hljs-comment">//Username string</span><br><span class="hljs-comment">//Password string</span><br><span class="hljs-comment">//DbName   string</span><br><span class="hljs-comment">//&#125;</span><br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br>osGwd, _ := os<span class="hljs-selector-class">.Getwd</span>()<br>confPath := osGwd + <span class="hljs-string">&quot;/conf_ini.ini&quot;</span><br>config, err := ini<span class="hljs-selector-class">.Load</span>(confPath)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-built_in">panic</span>(err<span class="hljs-selector-class">.Error</span>())<br>&#125;<br><span class="hljs-comment">// 可以直接读取配置，并设置默认值</span><br>mode := config<span class="hljs-selector-class">.Section</span>(<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-selector-class">.Key</span>(<span class="hljs-string">&quot;mode&quot;</span>)<span class="hljs-selector-class">.MustString</span>(<span class="hljs-string">&quot;debug&quot;</span>)<br>fmt<span class="hljs-selector-class">.Println</span>(mode)<br>postgres, err := config<span class="hljs-selector-class">.GetSection</span>(<span class="hljs-string">&quot;postgres&quot;</span>)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-built_in">panic</span>(err<span class="hljs-selector-class">.Error</span>())<br>&#125;<br><span class="hljs-comment">// 可通过 Key 去取值</span><br>fmt<span class="hljs-selector-class">.Println</span>(postgres<span class="hljs-selector-class">.Key</span>(<span class="hljs-string">&quot;host&quot;</span>))  <span class="hljs-comment">// localhost</span><br>fmt<span class="hljs-selector-class">.Println</span>(postgres<span class="hljs-selector-class">.Keys</span>())       <span class="hljs-comment">//  [localhost 5432 postgres postgres bubble]</span><br>fmt<span class="hljs-selector-class">.Println</span>(postgres<span class="hljs-selector-class">.KeyStrings</span>()) <span class="hljs-comment">// [host port username password dbname]</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 基本介绍及性能分析</title>
    <link href="/2020/12/12/Redis%20%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/2020/12/12/Redis%20%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-基本介绍及性能分析"><a href="#Redis-基本介绍及性能分析" class="headerlink" title="Redis 基本介绍及性能分析"></a>Redis 基本介绍及性能分析</h1><h2 id="什么是-Redis？"><a href="#什么是-Redis？" class="headerlink" title="什么是 Redis？"></a>什么是 Redis？</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h2 id="为什么选用-Redis？"><a href="#为什么选用-Redis？" class="headerlink" title="为什么选用 Redis？"></a>为什么选用 Redis？</h2><p>要想知道为什么现在很多厂商都选择 Redis 作为自己产品的缓存和中间件，就得知道 Redis 相较于其他的竞品的优势和劣势。</p><ul><li>是否需要复杂的数据结构？若是选择使用 Redis 作为存储，否则 Redis和 MC 都可以考虑。若是简单的 get&#x2F;post 请求，且需要较高的性能需求，可以是使用 MC 代替 Redis</li><li>是否需要进行数据的持久化存储，不允许数据丢失？若是选择使用 Redis 作为存储，并且在申请服务的时候注明需要作为存储而非缓存，需要开启持久化存储并对数据进行定期备份</li><li>是否需要 Master&#x2F;Slave 机制保证服务的高可用？若是选择 Redis作为存储，平台会默认为所有的 Redis 服务部署 Slave 从库</li></ul><h3 id="1、Memcache优势"><a href="#1、Memcache优势" class="headerlink" title="1、Memcache优势"></a>1、Memcache优势</h3><ul><li>Memcache 可以利用多核优势，单实例吞吐量极高，可以达到几十万的 QPS（每秒查询数），适用于最大程度康数据量</li><li>支持直接配置 session handler</li><li>坑少</li></ul><h3 id="2、Memcache劣势"><a href="#2、Memcache劣势" class="headerlink" title="2、Memcache劣势"></a>2、Memcache劣势</h3><ul><li>只支持简单的字符串类型数据</li><li>无法进行持久化，数据不能备份，只能作为缓存使用，一旦重启数据全部丢失</li><li>无法进行数据同步，不能将 MC 实例的数据迁移到另一个 MC 实例</li><li>Memcached内存分配采用Slab Allocation机制管理内存，value大小分布差异较大时会造成内存利用率降低，并引发低利用率时依然出现踢出等问题。需要用户注重value设计</li></ul><h3 id="3、Redis优势"><a href="#3、Redis优势" class="headerlink" title="3、Redis优势"></a>3、Redis优势</h3><ul><li>性能极高 – Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性 – Redis还支持 publish&#x2F;subscribe, 通知, key 过期等等特性。</li><li>支持数据持久化，包括 RDB（Redis DataBase）和 AOF（append only file）两种方式，生产环境可以两种方式结合使用</li><li>支持 Master&#x2F;Slave机制，最大程度保证服务的高可用，并且可以实时进行数据的同步复制</li><li>支持集群</li><li>单线程请求，命令串行化，请求不用考虑加锁释放锁造成的性能消耗</li><li>支持 pub&#x2F;sub 订阅发布机制，可以用来做消息订阅和通知</li></ul><h3 id="4、Redis-劣势"><a href="#4、Redis-劣势" class="headerlink" title="4、Redis 劣势"></a>4、Redis 劣势</h3><ul><li>Redis 是单线程，性能受限于内存，同时无法最大程度发挥多核 CPU 的性能，单实例 CPU 最高可以达到 5-6 W 的 QPS</li><li>Redis 在 string 类型上会消耗较多的内存，可以使用 dict压缩存储以降低内存耗用</li></ul><h3 id="5、与其他-key-value-存储的区别"><a href="#5、与其他-key-value-存储的区别" class="headerlink" title="5、与其他 key-value 存储的区别"></a>5、与其他 key-value 存储的区别</h3><ul><li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li><li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问</li></ul><h2 id="Redis-为什么快？"><a href="#Redis-为什么快？" class="headerlink" title="Redis 为什么快？"></a>Redis 为什么快？</h2><ul><li>Redis 是单线程，不需要进行各种上下文切换，加锁释放锁的操作，也避免了出现死锁的现象从而造成的性能消耗</li><li>Redis 重新设计了自己的数据类型 SDS（simple dynamic string），在最底层有自己的编码方式，可以根据数据的长度和类型去自动分析选取最适合的数据类型</li><li>Redis 是纯内存操作，就一个字快</li><li>Redis可以 I&#x2F;O多路复用</li></ul><h2 id="Redis-配置文件详解"><a href="#Redis-配置文件详解" class="headerlink" title="Redis 配置文件详解"></a>Redis 配置文件详解</h2><figure class="highlight pf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs pf"><span class="hljs-comment"># redis进程是否以守护进程的方式运行，yes为是，no为否(不以守护进程的方式运行会占用一个终端)。</span><br>daemonize <span class="hljs-keyword">no</span><br><span class="hljs-comment"># 指定redis进程的PID文件存放位置</span><br>pidfile /var/run/redis.pid<br><span class="hljs-comment"># redis进程的端口号</span><br><span class="hljs-keyword">port</span> <span class="hljs-number">6379</span><br><span class="hljs-comment"># 绑定的主机地址</span><br>bind <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-comment"># 客户端闲置多长时间后关闭连接，默认此参数为0即关闭此功能</span><br><span class="hljs-keyword">timeout</span> <span class="hljs-number">300</span><br><span class="hljs-comment"># redis日志级别，可用的级别有debug.verbose.notice.warning</span><br>loglevel verbose<br><span class="hljs-comment"># log文件输出位置，如果进程以守护进程的方式运行，此处又将输出文件设置为stdout的话，就会将日志信息输出到/dev/null里面去了</span><br>logfile stdout<br><span class="hljs-comment"># 设置数据库的数量，默认为0可以使用select &lt;dbid&gt;命令在连接上指定数据库id</span><br>databases <span class="hljs-number">16</span><br><span class="hljs-comment"># 指定在多少时间内刷新次数达到多少的时候会将数据同步到数据文件</span><br>save <span class="hljs-variable">&lt;seconds&gt;</span> <span class="hljs-variable">&lt;changes&gt;</span><br><span class="hljs-comment"># 指定存储至本地数据库时是否压缩文件，默认为yes即启用存储</span><br>rdbcompression yes<br><span class="hljs-comment"># 指定本地数据库文件名</span><br>dbfilename dump.db<br><span class="hljs-comment"># 指定本地数据问就按存放位置</span><br>dir ./<br><span class="hljs-comment"># 指定当本机为slave服务时，设置master服务的IP地址及端口，在redis启动的时候他会自动跟master进行数据同步</span><br>slaveof <span class="hljs-variable">&lt;masterip&gt;</span> <span class="hljs-variable">&lt;masterport&gt;</span><br><span class="hljs-comment"># 当master设置了密码保护时，slave服务连接master的密码</span><br>masterauth <span class="hljs-variable">&lt;master-password&gt;</span><br><span class="hljs-comment"># 设置redis连接密码，如果配置了连接密码，客户端在连接redis是需要通过AUTH&lt;password&gt;命令提供密码，默认关闭</span><br>requirepass footbared<br><span class="hljs-comment"># 设置同一时间最大客户连接数，默认无限制。redis可以同时连接的客户端数为redis程序可以打开的最大文件描述符，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回 max number of clients reached 错误信息</span><br>maxclients <span class="hljs-number">128</span><br><span class="hljs-comment"># 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key。当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span><br>maxmemory<span class="hljs-variable">&lt;bytes&gt;</span><br><span class="hljs-comment"># 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no。</span><br>appendonly <span class="hljs-keyword">no</span><br><span class="hljs-comment"># 指定跟新日志文件名默认为appendonly.aof</span><br>appendfilename appendonly.aof<br><span class="hljs-comment"># 指定更新日志的条件，有三个可选参数 - no：表示等操作系统进行数据缓存同步到磁盘(快)，always：表示每次更新操作后手动调用fsync()将数据写到磁盘(慢，安全)， everysec：表示每秒同步一次(折衷，默认值)；</span><br>appendfsync everysec<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作文件基础</title>
    <link href="/2020/11/06/%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/11/06/%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>其实我们可以随便排列存储文件，而且我们也可以自己定义文件格式，但是按照标准格式的话会更加方便，不管是存储还是查询。</p><p>文件其实是一长串二进制数据，我们通过 ASCII 码去解读文件。</p><p>文件有很多种类，大致分为五类：</p><ol><li>文字文件</li><li>图片文件</li><li>视频文件</li><li>音乐文件</li><li>其他文件</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2020/11/02/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2020/11/02/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="红黑树知识点"><a href="#红黑树知识点" class="headerlink" title="红黑树知识点"></a>红黑树知识点</h2><hr><h3 id="红黑树五大定义："><a href="#红黑树五大定义：" class="headerlink" title="红黑树五大定义："></a>红黑树五大定义：</h3><ol><li><p>节点颜色有红色和黑色</p></li><li><p>根节点必须为黑色</p><p>2-3 树中如果根节点为 2 节点，那么他本来就对应红黑树中黑色节点，如果根节点为3 节点，也可以用黑色节点表示较大的那个元素，然后较小的元素作为左倾红节点存在于红黑树中</p></li><li><p>所有叶子节点都是黑色</p></li><li><p>任意节点到叶子节点经过的黑色节点数目相同</p><p>红黑树中的红节点是和黑色父节点绑定的，在 2-3 树中本来就是同一层，只有黑色节点才会在 2-3 树中真正贡献高度，由于 2-3 树的任一节点到空链接的距离相同，因此反应在红黑树中就是黑色完美平衡</p></li><li><p>不会有连续的红色节点</p><p>2-3 树中本来就规定没有 4 节点，2-3-4 树中虽然有 4 节点，但是要求在红黑树中体现为一黑色节点带两个红色儿子，分布左右，所以也不会有连续红节点</p></li></ol><h3 id="关于树的旋转"><a href="#关于树的旋转" class="headerlink" title="关于树的旋转"></a>关于树的旋转</h3><p>​        为了调平一颗二叉树，使其左右节点数据分布均匀，通常会选择旋转的手段。可以把一颗二叉树某节点的左右子树想象成天平上待称量的物品，如果那边重了，我们就从重的那边拿出一部分，放到轻的那边，以此保持相对的平均。</p><p><strong>旋转是二叉树调平的精髓</strong></p><p>简单理解：</p><ul><li><p>左旋就是旋转点的右节点上升，同时将旋转点作为子节点挂载到右节点左边</p></li><li><p>右旋就是旋转点的左节点上升，同时将旋转点作为子节点挂载到左节点右边</p></li></ul><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081056391.png" alt="image-20201105101451656"></p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081056934.png" alt="image-20201105101508405"></p><h3 id="https-mp-weixin-qq-com-s-sPIE54UmvNgINZIATQKyew"><a href="#https-mp-weixin-qq-com-s-sPIE54UmvNgINZIATQKyew" class="headerlink" title="https://mp.weixin.qq.com/s/sPIE54UmvNgINZIATQKyew"></a><a href="https://mp.weixin.qq.com/s/sPIE54UmvNgINZIATQKyew">https://mp.weixin.qq.com/s/sPIE54UmvNgINZIATQKyew</a></h3>]]></content>
    
    
    <categories>
      
      <category>数据及算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红黑树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置 GitHub 以及 GitLab 账户</title>
    <link href="/2020/03/17/%E9%85%8D%E7%BD%AE%20GitHub%20%E4%BB%A5%E5%8F%8A%20Gitlab%20%E8%B4%A6%E6%88%B7/"/>
    <url>/2020/03/17/%E9%85%8D%E7%BD%AE%20GitHub%20%E4%BB%A5%E5%8F%8A%20Gitlab%20%E8%B4%A6%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="配置-GitHub-以及-Gitlab-账户"><a href="#配置-GitHub-以及-Gitlab-账户" class="headerlink" title="配置 GitHub 以及 Gitlab 账户"></a>配置 GitHub 以及 Gitlab 账户</h2><h3 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h3><p>全局配置 Git 账户</p><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-comment">// 配置全局用户名，如Github上注册的用户名</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;yyy@mail.com&quot;</span> <span class="hljs-comment">// 配置全局邮箱，如Github上配置的邮箱</span><br></code></pre></td></tr></table></figure><p>这个<code>--global</code>选项，是指这里配置的<code>user.name</code>和<code>user.email</code>是相对于全局进行配置的，即不同的Git仓库默认的用户名和邮箱都是这个值。由于需要管理多个账户，所以仅仅使用这个全局值是不够的，<strong>需要在每个仓库中单独配置</strong>。对此，有两种处理方法：</p><p>如果之前已经使用该命令进行配置，则先使用如下命令清除</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> user<span class="hljs-selector-class">.name</span><br>git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> user.email<br></code></pre></td></tr></table></figure><p>如果不确定是否已经配置过，可以使用下面的命令查看</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.name</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.email</span><br></code></pre></td></tr></table></figure><h3 id="2、开始配置"><a href="#2、开始配置" class="headerlink" title="2、开始配置"></a>2、开始配置</h3><h4 id="2-1-针对不同的账户生成不同的密匙"><a href="#2-1-针对不同的账户生成不同的密匙" class="headerlink" title="2.1 针对不同的账户生成不同的密匙"></a>2.1 针对不同的账户生成不同的密匙</h4><p>进入保存密匙的目录</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/.ssh</span> <span class="hljs-string">//</span> 进入目录，该目录下保存生成的秘钥<br></code></pre></td></tr></table></figure><p>然后，根据账户邮箱生成秘钥。例如我在GitHub上的邮箱是<a href="mailto:&#120;&#120;&#x78;&#x40;&#121;&#x79;&#x79;&#x2e;&#99;&#x6f;&#x6d;">&#120;&#120;&#x78;&#x40;&#121;&#x79;&#x79;&#x2e;&#99;&#x6f;&#x6d;</a>，则命令为：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;xxx@yyy.com&quot;</span><br></code></pre></td></tr></table></figure><p>输入完成后，会有如下提示：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Generating <span class="hljs-keyword">public</span>/<span class="hljs-keyword">private</span> rsa key pair.<br>Enter <span class="hljs-keyword">file</span> in which to save the key (<span class="hljs-regexp">/Users/</span>zhangweijie<span class="hljs-regexp">/.ssh/i</span>d_rsa):<span class="hljs-regexp">/Users/</span>zhangweijie<span class="hljs-regexp">/.ssh/i</span>d_rsa_github<br></code></pre></td></tr></table></figure><p>这里要求对秘钥进行命名，默认的文件名是<code>id_rsa</code>。为了方便区分，我这里命名为<code>id_rsa_github</code>。接下来的提示都直接进行回车，直到秘钥生成。通过<code>ls</code>命令，可以看到刚刚生成的密钥对<code>id_rsa_github</code>和<code>id_rsa_github.pub</code>。其中<code>id_rsa_github.pub</code>是公钥。</p><p>同样，对于GitLab上的账户，我是用另一个邮箱注册的，按照同样的步骤生成<code>id_rsa_gitlab</code>的秘钥对。接下来的步骤，除额外说明外，两个账户的操作完全相同。</p><h4 id="2-2-私匙添加到本地"><a href="#2-2-私匙添加到本地" class="headerlink" title="2.2 私匙添加到本地"></a>2.2 私匙添加到本地</h4><p>SSH协议的原理，就是在托管网站上使用公钥，在本地使用私钥，这样本地仓库就可以和远程仓库进行通信。在上一步已经生成了秘钥文件，接下来需要使用秘钥文件，首先是在本地使用秘钥文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">ssh-add ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_github <span class="hljs-regexp">//</span> 将GitHub私钥添加到本地<br>ssh-add ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_gitlab <span class="hljs-regexp">//</span> 将GitLab私钥添加到本地<br></code></pre></td></tr></table></figure><p>为了检验本地是否添加成功，可以使用<code>ssh-add -l</code>命令进行查看</p><h4 id="2-3-对本地秘钥进行配置"><a href="#2-3-对本地秘钥进行配置" class="headerlink" title="2.3  对本地秘钥进行配置"></a>2.3  对本地秘钥进行配置</h4><p>由于添加了多个密钥文件，所以需要对这多个密钥进行管理。在<code>.ssh</code>目录下新建一个config文件：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">touch config<br></code></pre></td></tr></table></figure><p>文件中的内容如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">Host github <span class="hljs-regexp">//</span> 网站的别名，随意取<br>HostName github.com <span class="hljs-regexp">//</span> 托管网站的域名<br>User liugui <span class="hljs-regexp">//</span> 托管网站上的用户名<br>IdentityFile ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_github <span class="hljs-regexp">//</span> 使用的密钥文件<br><br><span class="hljs-regexp">//</span> GitLab的配置相同<br>Host gitlab<br>HostName gitlab.com<br>User liugui<br>IdentityFile ~<span class="hljs-regexp">/.ssh/i</span>d_rsa_gitlab<br></code></pre></td></tr></table></figure><h4 id="2-4-公匙添加到托管网站"><a href="#2-4-公匙添加到托管网站" class="headerlink" title="2.4 公匙添加到托管网站"></a>2.4 公匙添加到托管网站</h4><p>以GitHub为例，先在本地复制公钥。进入<code>.ssh</code>目录，使用<code>vim id_rsa_github.pub</code>查看生成的GitHub公钥，全选进行复制。</p><p>登录GitHub，点击右上角头像选择<code>settings</code>，在打开的页面中选择SSH and GPG keys，</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081111553.png" alt="图片描述"></p><p>在打开的页面的Key输入框中粘贴刚刚复制的公钥，title的名字自己随便去，然后点击下方的<code>Add SSH key</code>按钮：<br><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081111010.png" alt="图片描述"></p><p>至此，托管网站的公钥添加完成。总结来说，就是针对每个托管网站分别生成一对密钥，然后分别添加到本地和托管网站。</p><p>这时候，可以测试一下配置是否成功，测试命令使用别名。例如，对于GitHub，本来应该使用的测试命令是：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><p>在config文件中，给GitHub网站配置的别名就是github，所以直接使用别名，就是</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span><br></code></pre></td></tr></table></figure><h3 id="3、如何使用"><a href="#3、如何使用" class="headerlink" title="3、如何使用"></a>3、如何使用</h3><p>使用有两种情况，一种情况是从远端拉取代码到本地，一种是本地已有仓库需要与远程仓库关联。</p><h4 id="3-1-从远端拉取代码"><a href="#3-1-从远端拉取代码" class="headerlink" title="3.1 从远端拉取代码"></a>3.1 从远端拉取代码</h4><p>选择SSH协议的复制命令，如对于GitLab上代码库test，其复制命令为</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@gitlab.com:liugui/test.git<br></code></pre></td></tr></table></figure><p>由于使用了别名gitlab，所以实际使用的复制命令应当为：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">git clone git<span class="hljs-variable">@gitlab</span><span class="hljs-symbol">:liugui/test</span>.git<br></code></pre></td></tr></table></figure><p>也可以不进行修改，git 会自己找到对应的域名</p><h4 id="3-2-本地已有的仓库"><a href="#3-2-本地已有的仓库" class="headerlink" title="3.2 本地已有的仓库"></a>3.2 本地已有的仓库</h4><p>这种情况适用于本地新建的仓库需要与远端进行关联，或者之前已经使用sourceTree等图形界面软件拷贝的仓库。进入本地仓库文件夹，需要单独配置该仓库的用户名和邮箱</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">git config <span class="hljs-literal">user</span>.<span class="hljs-keyword">name</span> <span class="hljs-string">&quot;xxx&quot;</span><br>git config <span class="hljs-literal">user</span>.email <span class="hljs-string">&quot;xxx@yyy.com&quot;</span><br></code></pre></td></tr></table></figure><p>然后，进入本地仓库的git目录，打开config文件</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">.git</span> <span class="hljs-string">//</span> 该目录是隐藏的，<span class="hljs-keyword">ls</span>命令不可见，但是可以直接进入，如果是新建的文件夹需要先执行git init<br>vim config<br></code></pre></td></tr></table></figure><p>在config文件中，修改（config文件中已有remote “origin”信息）或者添加（config文件中不包含remote “origin”信息）分支信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[remote <span class="hljs-string">&quot;origin&quot;</span>]<br>        url = git<span class="hljs-variable">@gitlab</span><span class="hljs-symbol">:xxx/test</span>.git<br>        fetch = +refs/heads/*<span class="hljs-symbol">:refs/remotes/origin/*</span><br></code></pre></td></tr></table></figure><p>主要是URL部分，原生的信息一般是<code>git@gitlab.com:xxx/test.git</code>，需要将gitlab.com使用别名gitlab代替。</p><p>可以看到，仓库中的关键是要配置好用户名和邮箱，以及使用别名。使用别名的目的是为了通过别名，将本地仓库与密钥目录<code>.ssh</code>文件夹下的密钥进行管理，这样就完成了本地仓库使用的私钥与托管网站使用的公钥的配对，而用户名和邮箱是该仓库使用SSH协议时需要用到的信息</p>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>GitLab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KONG 网关简介及简单使用</title>
    <link href="/2020/02/07/Kong%20%E7%BD%91%E5%85%B3%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/02/07/Kong%20%E7%BD%91%E5%85%B3%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Kong-网关简介及简单使用"><a href="#Kong-网关简介及简单使用" class="headerlink" title="Kong 网关简介及简单使用"></a>Kong 网关简介及简单使用</h2><h3 id="1、kong-网关简介"><a href="#1、kong-网关简介" class="headerlink" title="1、kong 网关简介"></a>1、kong 网关简介</h3><p>Kong是在客户端和微服务端转发 API 通信的 API 网关，可以通过插件扩展功能。Kong 主要有两个重要的的组件：</p><ul><li>Kong Server：基于 nginx 的服务器，用来接收 API 请求</li><li>Apache Cassandra：用于存储操作数据</li></ul><p>我们可以通过增加更多的 Kong Server服务器对 Kong 服务进行水平扩展，通过前置的负载均衡器向这些机器发送分发请求。根据文档描述，两个 Cassandra 节点就足以支撑绝大多数情况，但如果网络非常拥挤，可以适当考虑增加更多的节点。</p><p>对于我们来说，Kong 中最为重要的一个特性就是可以通过插件扩展已有功能，这些插件在 API 请求响应循环的生命周期内被执行。插件使用 Lua 编写，而且 Kong 还有如下几个基础功能：</p><p>HTTP 基本认证，密匙认证，CORS（Cross-origin Resource Sharing，跨域资源共享），TCP，UDP，文件日志，API请求限流，请求转发及 Nginx 监控等等</p><h3 id="2、docker-部署-kong"><a href="#2、docker-部署-kong" class="headerlink" title="2、docker 部署 kong"></a>2、docker 部署 kong</h3><p>官方文档：<a href="https://hub.docker.com/_/kong/">https://hub.docker.com/_/kong/</a></p><p>设置网络</p><figure class="highlight dos"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs dos">docker network create kong-<span class="hljs-built_in">net</span><br></code></pre></td></tr></table></figure><p>安装数据库， PostgreSQL and Cassandra，推荐使用 postgres（版本号可自由选择）</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">docker run -d --name kong-database \<br>              --network=kong-net \<br>              -p <span class="hljs-number">5432</span>:<span class="hljs-number">5432</span> \<br>              -e <span class="hljs-string">&quot;POSTGRES_USER=kong&quot;</span> \<br>              -e <span class="hljs-string">&quot;POSTGRES_DB=kong&quot;</span> \<br>              postgres:<span class="hljs-number">11</span>.<span class="hljs-number">1</span>-alpine<br></code></pre></td></tr></table></figure><p>准备 kong 数据</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run --rm <span class="hljs-string">\</span><br>    --network=kong-net <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_DATABASE=postgres&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_PG_HOST=kong-database&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot;</span> <span class="hljs-string">\</span><br>    kong:latest kong migrations bootstrap<br></code></pre></td></tr></table></figure><p>启动kong，设置postgres 数据库</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run -d --name kong <span class="hljs-string">\</span><br>    --network=kong-net <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_DATABASE=postgres&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_PG_HOST=kong-database&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_PROXY_ACCESS_LOG=/dev/stdout&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_ADMIN_ACCESS_LOG=/dev/stdout&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_PROXY_ERROR_LOG=/dev/stderr&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_ADMIN_ERROR_LOG=/dev/stderr&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot;</span> <span class="hljs-string">\</span><br>    -p <span class="hljs-number">8000</span>:<span class="hljs-number">8000</span> <span class="hljs-string">\</span><br>    -p <span class="hljs-number">8443</span>:<span class="hljs-number">8443</span> <span class="hljs-string">\</span><br>    -p <span class="hljs-number">8001</span>:<span class="hljs-number">8001</span> <span class="hljs-string">\</span><br>    -p <span class="hljs-number">8444</span>:<span class="hljs-number">8444</span> <span class="hljs-string">\</span><br>    kong:latest<br></code></pre></td></tr></table></figure><p>：8000 Kong 在该端口上侦听来自客户端的传入 HTTP 流量，并将其转发到上游服务</p><p>：8443 Kong 在其上侦听传入的 HTTPS 流量。此端口具有与端口 8000 类似的行为，不过他仅支持 HTTPS通信，可以通过配置文件禁用此端口</p><p>：8001 用于配置 Kong 侦听的 admin api</p><p>：8444 admin api 在其上侦听 HTTPS 流量</p><p>检查 kong 是否正常运行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -i http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8001</span>/<br></code></pre></td></tr></table></figure><p>安装图形化界面</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -d <span class="hljs-comment">--name kong-dashboard \</span><br>    <span class="hljs-comment">--network=kong-net \</span><br>    <span class="hljs-comment">--link kong:kong \</span><br>    -p <span class="hljs-number">8081</span>:<span class="hljs-number">8080</span> \<br>    pgbi/kong-dashboard:v2 migrations up<br></code></pre></td></tr></table></figure><h3 id="3、配置服务"><a href="#3、配置服务" class="headerlink" title="3、配置服务"></a>3、配置服务</h3><p>向 kong添加 API，我们需要先添加一个 service，即使用 kong 用来指代其管理的上游 API 和微服务的名称</p><p>我们将创建一个指向<a href="https://mockbin.com/">Mockbin API的服务</a>。Mockbin是一个“回声”类型的公共网站，它将返回的请求返回给请求者，作为响应。这有助于了解Kong如何代理您的API请求。</p><p>在开始对服务提出请求之前，需要为其添加一条<em>路由</em>。路线指定到达香港后如何（以及<em>是否</em>）将请求发送到其服务。单个服务可以具有多个路由。</p><p>配置服务和路线后，您将可以使用它们通过Kong发出请求。</p><p>Kong 在port上公开了<a href="https://docs.konghq.com/2.0.x/admin-api">RESTful Admin API</a><code>:8001</code>。Kong的配置（包括添加服务和路由）是通过该API上的请求进行的。</p><h4 id="1）使用-admin-api添加服务"><a href="#1）使用-admin-api添加服务" class="headerlink" title="1）使用 admin api添加服务"></a>1）使用 admin api添加服务</h4><p>发出以下cURL请求以将您的第一个服务（指向<a href="https://mockbin.com/">Mockbin API</a>）添加到Kong：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">curl -<span class="hljs-selector-tag">i</span> -X POST \<br>  <span class="hljs-attr">--url</span> http:<span class="hljs-comment">//localhost:8001/services/ \</span><br>  <span class="hljs-attr">--data</span> <span class="hljs-string">&#x27;name=example-service&#x27;</span> \<br>  <span class="hljs-attr">--data</span> <span class="hljs-string">&#x27;url=http://mockbin.org&#x27;</span><br></code></pre></td></tr></table></figure><p>内容回复：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">201</span> Created<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 07 Feb 2020 09:04:51 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json; charset=utf-8<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>kong/2.0.1<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>296<br><span class="hljs-attribute">X-Kong-Admin-Latency</span><span class="hljs-punctuation">: </span>210<br><br><span class="language-1c">&#123;<span class="hljs-string">&quot;host&quot;</span>:<span class="hljs-string">&quot;mockbin.org&quot;</span>,<span class="hljs-string">&quot;created_at&quot;</span>:<span class="hljs-number">1581066291</span>,<span class="hljs-string">&quot;connect_timeout&quot;</span>:<span class="hljs-number">60000</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;1148d98c-2eeb-4988-af84-d3173080bdd9&quot;</span>,<span class="hljs-string">&quot;protocol&quot;</span>:<span class="hljs-string">&quot;http&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;example-service&quot;</span>,<span class="hljs-string">&quot;read_timeout&quot;</span>:<span class="hljs-number">60000</span>,<span class="hljs-string">&quot;port&quot;</span>:<span class="hljs-number">80</span>,<span class="hljs-string">&quot;path&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;updated_at&quot;</span>:<span class="hljs-number">1581066291</span>,<span class="hljs-string">&quot;retries&quot;</span>:<span class="hljs-number">5</span>,<span class="hljs-string">&quot;write_timeout&quot;</span>:<span class="hljs-number">60000</span>,<span class="hljs-string">&quot;tags&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;client_certificate&quot;</span>:<span class="hljs-literal">null</span>&#125;%</span><br></code></pre></td></tr></table></figure><h4 id="SERVICES-API详解"><a href="#SERVICES-API详解" class="headerlink" title="SERVICES API详解"></a>SERVICES API详解</h4><h4 id="1、添加-services"><a href="#1、添加-services" class="headerlink" title="1、添加 services"></a>1、添加 services</h4><p>请求地址：&#x2F;service&#x2F;</p><p>请求方法：POST</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">name（可选）</td><td align="left">服务名称.</td></tr><tr><td align="left">protocol</td><td align="left">该协议用于与upstream通信。它可以是http（默认）或https。</td></tr><tr><td align="left">host</td><td align="left">upstream服务器的主机。</td></tr><tr><td align="left">port</td><td align="left">upstream服务器端口。默认为80</td></tr><tr><td align="left">path（可选）</td><td align="left">在向upstream服务器请求中使用的路径。默认为空。</td></tr><tr><td align="left">retries（可选）</td><td align="left">在代理失败的情况下执行的重试次数。默认值是5。</td></tr><tr><td align="left">connect_timeout（可选）</td><td align="left">建立到upstream服务器的连接的超时时间。默认为60000。</td></tr><tr><td align="left">write_timeout（可选）</td><td align="left">将请求发送到upstream服务器的两个连续写操作之间的超时时间。默认为60000。</td></tr><tr><td align="left">read_timeout（可选）</td><td align="left">将请求发送到upstream服务器的两个连续读取操作之间的超时时间。默认为60000。</td></tr><tr><td align="left">url（简写属性）</td><td align="left">将协议、主机、端口和路径立即设置成简短的属性。这个属性是只写的（管理API从来不“返回”url）。</td></tr></tbody></table><h4 id="2、查找-service"><a href="#2、查找-service" class="headerlink" title="2、查找 service"></a>2、查找 service</h4><p>请求地址：&#x2F;services&#x2F;{name or id}</p><p>请求方法：GET</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">name or id（必填）</td><td align="left">检索的唯一标识符或服务名称。</td></tr></tbody></table><p>请求地址：&#x2F;routes&#x2F;{route id}&#x2F;service</p><p>请求方法：GET</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">route id（必填）</td><td align="left">属于要检索的服务的路由的唯一标识符。</td></tr></tbody></table><h4 id="3、查找-service-列表"><a href="#3、查找-service-列表" class="headerlink" title="3、查找 service 列表"></a>3、查找 service 列表</h4><p>请求地址：&#x2F;services&#x2F;</p><p>请求方法：GET</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">offset（可选）</td><td align="left">用于分页的游标。偏移量是定义列表中的位置的对象标识符。</td></tr><tr><td align="left">size（可选，默认是100 max是1000）</td><td align="left">每个页面返回的对象数量的限制。</td></tr></tbody></table><h4 id="4、更新-service"><a href="#4、更新-service" class="headerlink" title="4、更新 service"></a>4、更新 service</h4><p>请求地址：&#x2F;service&#x2F;{name or id}</p><p>请求方法：PATCH</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">name or id（必填）</td><td align="left">要更新的服务的id或name属性。</td></tr></tbody></table><p>请求地址：&#x2F;routes&#x2F;{route id}&#x2F;service</p><p>请求方法：PATCH</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">route id（必填）</td><td align="left">要更新服务的路由的id属性。</td></tr></tbody></table><h4 id="5、删除-service"><a href="#5、删除-service" class="headerlink" title="5、删除 service"></a>5、删除 service</h4><p>请求地址：&#x2F;services&#x2F;{name or id}</p><p>请求方法：DELETE</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">name or id（必填）</td><td align="left">要删除的服务的id或name属性。</td></tr></tbody></table><h4 id="2）添加服务路线"><a href="#2）添加服务路线" class="headerlink" title="2）添加服务路线"></a>2）添加服务路线</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -i -X POST \<br>  --url http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8001</span><span class="hljs-regexp">/services/</span>example-service/routes \<br>  --data <span class="hljs-string">&#x27;hosts[]=example.com&#x27;</span><br></code></pre></td></tr></table></figure><p>内容回复：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">201</span> Created<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 07 Feb 2020 09:05:40 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json; charset=utf-8<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>kong/2.0.1<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>429<br><span class="hljs-attribute">X-Kong-Admin-Latency</span><span class="hljs-punctuation">: </span>26<br><br><span class="language-elixir">&#123;<span class="hljs-string">&quot;id&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;535592c2-c8b5-4f40-9a37-22f1dae115b8&quot;</span></span>,<span class="hljs-string">&quot;path_handling&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;v0&quot;</span></span>,<span class="hljs-string">&quot;paths&quot;</span><span class="hljs-symbol">:null</span>,<span class="hljs-string">&quot;destinations&quot;</span><span class="hljs-symbol">:null</span>,<span class="hljs-string">&quot;headers&quot;</span><span class="hljs-symbol">:null</span>,<span class="hljs-string">&quot;protocols&quot;</span><span class="hljs-symbol">:</span>[<span class="hljs-string">&quot;http&quot;</span>,<span class="hljs-string">&quot;https&quot;</span>],<span class="hljs-string">&quot;methods&quot;</span><span class="hljs-symbol">:null</span>,<span class="hljs-string">&quot;snis&quot;</span><span class="hljs-symbol">:null</span>,<span class="hljs-string">&quot;service&quot;</span><span class="hljs-symbol">:</span>&#123;<span class="hljs-string">&quot;id&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;1148d98c-2eeb-4988-af84-d3173080bdd9&quot;</span></span>&#125;,<span class="hljs-string">&quot;name&quot;</span><span class="hljs-symbol">:null</span>,<span class="hljs-string">&quot;strip_path&quot;</span><span class="hljs-symbol">:true</span>,<span class="hljs-string">&quot;preserve_host&quot;</span><span class="hljs-symbol">:false</span>,<span class="hljs-string">&quot;regex_priority&quot;</span><span class="hljs-symbol">:</span><span class="hljs-number">0</span>,<span class="hljs-string">&quot;updated_at&quot;</span><span class="hljs-symbol">:</span><span class="hljs-number">1581066340</span>,<span class="hljs-string">&quot;sources&quot;</span><span class="hljs-symbol">:null</span>,<span class="hljs-string">&quot;hosts&quot;</span><span class="hljs-symbol">:</span>[<span class="hljs-string">&quot;example.com&quot;</span>],<span class="hljs-string">&quot;https_redirect_status_code&quot;</span><span class="hljs-symbol">:</span><span class="hljs-number">426</span>,<span class="hljs-string">&quot;tags&quot;</span><span class="hljs-symbol">:null</span>,<span class="hljs-string">&quot;created_at&quot;</span><span class="hljs-symbol">:</span><span class="hljs-number">1581066340</span>&#125;%</span><br></code></pre></td></tr></table></figure><p>kong 现在知道服务名称，并准备代理请求</p><h4 id="ROUTE-API详解"><a href="#ROUTE-API详解" class="headerlink" title="ROUTE API详解"></a>ROUTE API详解</h4><h4 id="1、添加-route"><a href="#1、添加-route" class="headerlink" title="1、添加 route"></a>1、添加 route</h4><p>请求地址：&#x2F;routes&#x2F;</p><p>请求方法：POST</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">protocols</td><td align="left">这条路线应该允许的协议列表。默认情况下，它是“http”、“https”，这意味着路由接受这两种方式。当设置为“HTTPS”时，HTTP请求会被请求升级到HTTPS。通过表单编码，符号是协议&#x3D;http&amp;协议&#x3D;https。使用JSON，使用数组。</td></tr><tr><td align="left">methods(半可选)</td><td align="left">与此路由相匹配的HTTP方法列表。例如: [“GET”, “POST”].至少有一个主机、路径或方法必须被设置。用表单编码参数是methods[]&#x3D;GET&amp;methods[]&#x3D;OPTIONS。使用JSON，使用数组。</td></tr><tr><td align="left">hosts(半可选)</td><td align="left">与此路径匹配的域名列表。例如:example.com. 至少有一个主机、路径或方法必须被设置。用表单编码参数是 hosts[]&#x3D;foo.com&amp;hosts[]&#x3D;bar.com。使用JSON，使用数组。</td></tr><tr><td align="left">paths(半可选)</td><td align="left">与此路径相匹配的路径列表。例如: &#x2F;my-path.至少有一个主机、路径或方法必须被设置。用表单编码参数是 paths[]&#x3D;&#x2F;foo&amp;paths[]&#x3D;&#x2F;bar. 使用JSON，使用数组。</td></tr><tr><td align="left">strip_path(可选)</td><td align="left">当通过一条路径匹配一条路径时，从upstream请求URL中剥离匹配的前缀。默认值为true。</td></tr><tr><td align="left">preserve_host(可选)</td><td align="left">当通过一个主机域名匹配一条路由时，在upstream请求头中使用请求主机头。默认设置为false，upstream主机头将是服务主机的主机头。</td></tr><tr><td align="left">service</td><td align="left">这条路线的服务是相关的。这是路由代理通信的地方。用表单编码参数是service.id&#x3D;<service_id>。如果是JSON，则使用”service”:{“id”:”<service_id>“}</td></tr></tbody></table><h4 id="2、查找-route"><a href="#2、查找-route" class="headerlink" title="2、查找 route"></a>2、查找 route</h4><p>请求地址：&#x2F;routes&#x2F;{id}</p><p>请求方法：GET</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">id（必填）</td><td align="left">检索路由的id属性。</td></tr></tbody></table><h4 id="3、查找-route-列表"><a href="#3、查找-route-列表" class="headerlink" title="3、查找 route 列表"></a>3、查找 route 列表</h4><p>请求地址：&#x2F;routes&#x2F;</p><p>请求方法：GET</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">offset（可选）</td><td align="left">用于分页的游标。偏移量是定义列表中的位置的对象标识符。</td></tr><tr><td align="left">size（可选，默认是100 max是1000）</td><td align="left">每个页面返回的对象数量的限制。</td></tr></tbody></table><h4 id="4、更新-route"><a href="#4、更新-route" class="headerlink" title="4、更新 route"></a>4、更新 route</h4><p>请求地址：&#x2F;routes&#x2F;{id}</p><p>请求方法：PATCH</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">id（必填）</td><td align="left">更新路由的id属性。</td></tr></tbody></table><h4 id="5、删除-route"><a href="#5、删除-route" class="headerlink" title="5、删除 route"></a>5、删除 route</h4><p>请求地址：&#x2F;route&#x2F;{ id}</p><p>请求方法：DELETE</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">id（必填）</td><td align="left">删除路由的id属性。</td></tr></tbody></table><h4 id="6、列出与-service-相关的-route"><a href="#6、列出与-service-相关的-route" class="headerlink" title="6、列出与 service 相关的 route"></a>6、列出与 service 相关的 route</h4><p>请求地址：&#x2F;services&#x2F;{service name or id}&#x2F;routes</p><p>请求方法：GET</p><p>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">service name or id（必填）</td><td align="left">要检索路由的服务的id或name属性。当使用这个API时，只有属于指定服务的路由才会被列出。</td></tr></tbody></table><h4 id="3）通过-kong-转发请求"><a href="#3）通过-kong-转发请求" class="headerlink" title="3）通过 kong 转发请求"></a>3）通过 kong 转发请求</h4><p>发出以下cURL请求，以验证Kong是否正确地将请求转发到您的服务。请注意，<a href="https://docs.konghq.com/2.0.x/configuration/#nginx-section">默认情况下，</a> Kong在port上处理代理请求<code>:8000</code>：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">curl -<span class="hljs-selector-tag">i</span> -X GET \<br>  <span class="hljs-attr">--url</span> http:<span class="hljs-comment">//localhost:8000/ \</span><br>  <span class="hljs-attr">--header</span> <span class="hljs-string">&#x27;Host: example.com&#x27;</span><br></code></pre></td></tr></table></figure><p>如果成功响应，表示 kong 已经成功转发我们的请求，转发 url 地址为步骤 1 中的地址</p><h3 id="4、启用插件"><a href="#4、启用插件" class="headerlink" title="4、启用插件"></a>4、启用插件</h3><p>Kong的核心原则之一是其通过<a href="https://docs.konghq.com/plugins">插件的</a>可扩展性。插件使我们可以轻松地向服务中添加新功能或使其更易于管理。</p><p>在下面的步骤中，将配置<a href="https://docs.konghq.com/plugins/key-authentication">key-auth</a>插件以向服务添加身份验证。在添加此插件之前， 对服务的<strong>所有</strong>请求都将在上游被代理。添加并配置此插件后，<strong>只会</strong>代理具有正确密钥的请求-Kong将拒绝所有其他请求，从而保护上游服务免遭未经授权的使用。</p><h4 id="1）配置密匙身份验证插件"><a href="#1）配置密匙身份验证插件" class="headerlink" title="1）配置密匙身份验证插件"></a>1）配置密匙身份验证插件</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -i -X POST \<br>  --url http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8001</span><span class="hljs-regexp">/services/</span>example-service<span class="hljs-regexp">/plugins/</span> \<br>  --data <span class="hljs-string">&#x27;name=key-auth&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>此插件还接受一个<code>config.key_names</code>参数，默认为<code>[&#39;apikey&#39;]</code>。它是应该在请求期间包含apikey的标头和参数名称（均受支持）的列表。</p><p>内容回复：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">201</span> Created<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 07 Feb 2020 09:15:07 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json; charset=utf-8<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>kong/2.0.1<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>363<br><span class="hljs-attribute">X-Kong-Admin-Latency</span><span class="hljs-punctuation">: </span>52<br><br><span class="language-actionscript">&#123;<span class="hljs-string">&quot;created_at&quot;</span>:<span class="hljs-number">1581066907</span>,<span class="hljs-string">&quot;config&quot;</span>:&#123;<span class="hljs-string">&quot;key_names&quot;</span>:[<span class="hljs-string">&quot;apikey&quot;</span>],<span class="hljs-string">&quot;run_on_preflight&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;anonymous&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;hide_credentials&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;key_in_body&quot;</span>:<span class="hljs-literal">false</span>&#125;,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;c032c177-dac4-435b-a3b6-b39edd9c11fe&quot;</span>,<span class="hljs-string">&quot;service&quot;</span>:&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;1148d98c-2eeb-4988-af84-d3173080bdd9&quot;</span>&#125;,<span class="hljs-string">&quot;enabled&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;protocols&quot;</span>:[<span class="hljs-string">&quot;grpc&quot;</span>,<span class="hljs-string">&quot;grpcs&quot;</span>,<span class="hljs-string">&quot;http&quot;</span>,<span class="hljs-string">&quot;https&quot;</span>],<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;key-auth&quot;</span>,<span class="hljs-string">&quot;consumer&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;route&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;tags&quot;</span>:<span class="hljs-literal">null</span>&#125;%</span><br></code></pre></td></tr></table></figure><h4 id="2）确认插件配置正确"><a href="#2）确认插件配置正确" class="headerlink" title="2）确认插件配置正确"></a>2）确认插件配置正确</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">curl -<span class="hljs-selector-tag">i</span> -X GET \<br>  <span class="hljs-attr">--url</span> http:<span class="hljs-comment">//localhost:8000/ \</span><br>  <span class="hljs-attr">--header</span> <span class="hljs-string">&#x27;Host: example.com&#x27;</span><br></code></pre></td></tr></table></figure><p>由于未指定所需的apikey 标题或者参数，因此响应应为 401authorized</p><p>内容回复：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">401</span> Unauthorized<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 07 Feb 2020 09:15:28 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json; charset=utf-8<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">WWW-Authenticate</span><span class="hljs-punctuation">: </span>Key realm=&quot;kong&quot;<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>41<br><span class="hljs-attribute">X-Kong-Response-Latency</span><span class="hljs-punctuation">: </span>14<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>kong/2.0.1<br><br><span class="language-erlang-repl">&#123;<span class="hljs-string">&quot;message&quot;</span>:<span class="hljs-string">&quot;No API key found in request&quot;</span>&#125;<span class="hljs-comment">%</span></span><br></code></pre></td></tr></table></figure><h3 id="5、添加消费者"><a href="#5、添加消费者" class="headerlink" title="5、添加消费者"></a>5、添加消费者</h3><h4 id="通过-restful-api-创建消费者"><a href="#通过-restful-api-创建消费者" class="headerlink" title="通过 restful api 创建消费者"></a>通过 restful api 创建消费者</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -i -X POST \<br>  --url http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8001</span><span class="hljs-regexp">/consumers/</span> \<br>  --data <span class="hljs-string">&quot;username=Jason&quot;</span><br></code></pre></td></tr></table></figure><p>内容回复：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">201</span> Created<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 07 Feb 2020 09:22:44 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json; charset=utf-8<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>kong/2.0.1<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>117<br><span class="hljs-attribute">X-Kong-Admin-Latency</span><span class="hljs-punctuation">: </span>46<br><br><span class="language-1c">&#123;<span class="hljs-string">&quot;custom_id&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;created_at&quot;</span>:<span class="hljs-number">1581067364</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;947b5a94-f0d1-4955-9903-d5d489be4015&quot;</span>,<span class="hljs-string">&quot;tags&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;username&quot;</span>:<span class="hljs-string">&quot;Jason&quot;</span>&#125;%</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong><code>custom_id</code>在<a href="https://docs.konghq.com/2.0.x/admin-api#create-consumer">创建使用者</a>以将使用者与现有用户数据库相关联时，Kong还接受参数。</p><p>CONSUMER API 详解：</p><h4 id="1、创建Consumer"><a href="#1、创建Consumer" class="headerlink" title="1、创建Consumer"></a>1、创建Consumer</h4><p>请求地址：*&#x2F;consumers&#x2F;*<br>请求方法：<em>POST</em><br>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">username（半可选）</td><td align="left">用户的唯一用户名。<code>username</code>或<code>custom_id</code>二选一。</td></tr><tr><td align="left">custom_id（半可选）</td><td align="left">消费者存储唯一ID - 用于现有数据库中的用户进行映射。<code>username</code>或<code>custom_id</code>二选一。</td></tr></tbody></table><h4 id="2、检索Consumer"><a href="#2、检索Consumer" class="headerlink" title="2、检索Consumer"></a>2、检索Consumer</h4><p>请求地址：*&#x2F;consumers&#x2F;{username or id}*<br>请求方法：<em>GET</em><br>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">username or id（必选）</td><td align="left">要检索的消费者的唯一标识符或用户名。</td></tr></tbody></table><h4 id="3、Consumer列表"><a href="#3、Consumer列表" class="headerlink" title="3、Consumer列表"></a>3、Consumer列表</h4><p>请求地址：*&#x2F;consumers&#x2F;*<br>请求方法：<em>GET</em><br>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">id（可选）</td><td align="left">基于消费者<code>id</code>字段的过滤器。</td></tr><tr><td align="left">custom_id（可选）</td><td align="left">基于消费者<code>custom_id</code>字段的过滤器。</td></tr><tr><td align="left">username（可选）</td><td align="left">基于消费者<code>username</code>字段的过滤器。</td></tr><tr><td align="left">offset（可选）</td><td align="left">用于分页的游标。偏移量是定义列表中的位置的对象标识符。</td></tr><tr><td align="left">size（可选，默认是100）</td><td align="left">每个页面返回的对象数量的限制。</td></tr></tbody></table><h4 id="4、更新Consumer"><a href="#4、更新Consumer" class="headerlink" title="4、更新Consumer"></a>4、更新Consumer</h4><p>请求地址：*&#x2F;consumers&#x2F;{username or id}*<br>请求方法：<em>PATCH</em><br>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">username or id（必选）</td><td align="left">更新的唯一标识符或用户名。</td></tr></tbody></table><p>请求主体：同1、添加Consumer</p><h4 id="5、更新或创建Consumer"><a href="#5、更新或创建Consumer" class="headerlink" title="5、更新或创建Consumer"></a>5、更新或创建Consumer</h4><p>请求地址：*&#x2F;consumers&#x2F;*<br>请求方法：<em>PUT</em><br>请求主体：同1、添加Consumer</p><h4 id="6、删除Consumer"><a href="#6、删除Consumer" class="headerlink" title="6、删除Consumer"></a>6、删除Consumer</h4><p>请求地址：*&#x2F;consumers&#x2F;{username or id}*<br>请求方法：<em>DELETE</em><br>请求主体：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">username or id（必选）</td><td align="left">更新的唯一标识符或用户名。</td></tr></tbody></table><h4 id="2）为消费者提供关键凭证"><a href="#2）为消费者提供关键凭证" class="headerlink" title="2）为消费者提供关键凭证"></a>2）为消费者提供关键凭证</h4><p>现在，我们可以<code>Jason</code>通过发出以下请求为我们最近创建的使用者创建密钥：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -i -X POST \<br>  --url http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8001</span><span class="hljs-regexp">/consumers/</span>Jason<span class="hljs-regexp">/key-auth/</span> \<br>  --data <span class="hljs-string">&#x27;key=ENTER_KEY_HERE&#x27;</span><br></code></pre></td></tr></table></figure><p>内容回复：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">201</span> Created<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 07 Feb 2020 09:27:40 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json; charset=utf-8<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>kong/2.0.1<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>172<br><span class="hljs-attribute">X-Kong-Admin-Latency</span><span class="hljs-punctuation">: </span>56<br><br><span class="language-1c">&#123;<span class="hljs-string">&quot;created_at&quot;</span>:<span class="hljs-number">1581067660</span>,<span class="hljs-string">&quot;consumer&quot;</span>:&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;947b5a94-f0d1-4955-9903-d5d489be4015&quot;</span>&#125;,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;6b59a5e1-fa04-4d4b-b3b1-2e044b9c0605&quot;</span>,<span class="hljs-string">&quot;tags&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;ttl&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;key&quot;</span>:<span class="hljs-string">&quot;ENTER_KEY_HERE&quot;</span>&#125;%</span><br></code></pre></td></tr></table></figure><h4 id="3）验证消费者凭证有效"><a href="#3）验证消费者凭证有效" class="headerlink" title="3）验证消费者凭证有效"></a>3）验证消费者凭证有效</h4><p>现在，我们可以发出以下请求来验证我们的<code>Jason</code>消费者凭证是否有效：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">curl -<span class="hljs-selector-tag">i</span> -X GET \<br>  <span class="hljs-attr">--url</span> http:<span class="hljs-comment">//localhost:8001 \</span><br>  <span class="hljs-attr">--header</span> <span class="hljs-string">&quot;Host: example.com&quot;</span> \<br>  <span class="hljs-attr">--header</span> <span class="hljs-string">&quot;apikey: ENTER_KEY_HERE&quot;</span><br></code></pre></td></tr></table></figure><p>内容回复：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>10695<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Cowboy<br><span class="hljs-attribute">Etag</span><span class="hljs-punctuation">: </span>W/&quot;29c7-XG+PICJmz/J+UYWt5gkKqqAUXjc&quot;<br><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Encoding<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 07 Feb 2020 09:28:04 GMT<br><span class="hljs-attribute">Via</span><span class="hljs-punctuation">: </span>kong/2.0.1<br><span class="hljs-attribute">X-Kong-Upstream-Status</span><span class="hljs-punctuation">: </span>200<br><span class="hljs-attribute">X-Kong-Upstream-Latency</span><span class="hljs-punctuation">: </span>746<br><span class="hljs-attribute">X-Kong-Proxy-Latency</span><span class="hljs-punctuation">: </span>1523<br><span class="hljs-attribute">Kong-Cloud-Request-ID</span><span class="hljs-punctuation">: </span>3a1112d6c34f47aeb5df4ba2435b0f70<br></code></pre></td></tr></table></figure><p>如果正常响应表示该消费者请求被kong成功转发并返回数据</p>]]></content>
    
    
    <categories>
      
      <category>认证授权</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kong</tag>
      
      <tag>网关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kibana简介</title>
    <link href="/2020/02/06/kibana%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/02/06/kibana%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Kibana简介"><a href="#Kibana简介" class="headerlink" title="Kibana简介"></a>Kibana简介</h2><h3 id="1、kibana-下载"><a href="#1、kibana-下载" class="headerlink" title="1、kibana 下载"></a>1、kibana 下载</h3><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.elastic.co<span class="hljs-regexp">/cn/</span>downloads/kibana<br></code></pre></td></tr></table></figure><h3 id="2、kibana-启动"><a href="#2、kibana-启动" class="headerlink" title="2、kibana 启动"></a>2、kibana 启动</h3><p>解压后进入该目录，首先启动kibana</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kibana <span class="hljs-comment"># 启动命令</span><br>网址为：localhost:5601 <span class="hljs-comment"># 查看是否启动成功</span><br></code></pre></td></tr></table></figure><h3 id="3、插件管理"><a href="#3、插件管理" class="headerlink" title="3、插件管理"></a>3、插件管理</h3><p>查看插件信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kiban-plugin list<br></code></pre></td></tr></table></figure><p>下载插件</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bin/kiban-plugin </span><span class="hljs-keyword">install </span>plugin_location <br></code></pre></td></tr></table></figure><h3 id="4、DSL-基本命令"><a href="#4、DSL-基本命令" class="headerlink" title="4、DSL 基本命令"></a>4、DSL 基本命令</h3>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>ELK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ELK</tag>
      
      <tag>Kibana</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>logstash 简介</title>
    <link href="/2020/02/05/logstash%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/02/05/logstash%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="logstash-简介"><a href="#logstash-简介" class="headerlink" title="logstash 简介"></a>logstash 简介</h2><h3 id="1、下载及启动"><a href="#1、下载及启动" class="headerlink" title="1、下载及启动"></a>1、下载及启动</h3><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.elastic.co<span class="hljs-regexp">/cn/</span>downloads/logstash  <span class="hljs-comment"># 下载地址</span><br></code></pre></td></tr></table></figure><p>解压后进入该目录，将写好的配置文件放进 bin 文件夹</p><p>文件如下</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs puppet"><span class="hljs-keyword">input</span> &#123;<br>  file &#123;<br>    <span class="hljs-attr">path</span> =&gt; <span class="hljs-string">&quot;/Users/zhangweijie/ELK/logstash-7.5.2/bin/movies.csv&quot;</span><br>    <span class="hljs-attr">start_position</span> =&gt; <span class="hljs-string">&quot;beginning&quot;</span><br>    <span class="hljs-attr">sincedb_path</span> =&gt; <span class="hljs-string">&quot;/dev/null&quot;</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">filter</span> &#123;<br>  csv &#123;<br>    <span class="hljs-attr">separator</span> =&gt; <span class="hljs-string">&quot;,&quot;</span><br>    <span class="hljs-attr">columns</span> =&gt; [<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>,<span class="hljs-string">&quot;genre&quot;</span>]<br>  &#125;<br><br>  <span class="hljs-keyword">mutate</span> &#123;<br>    <span class="hljs-attr">split</span> =&gt; &#123; <span class="hljs-string">&quot;genre&quot;</span> =&gt; <span class="hljs-string">&quot;|&quot;</span> &#125;<br>    <span class="hljs-keyword">remove_field</span> =&gt; [<span class="hljs-string">&quot;path&quot;</span>, <span class="hljs-string">&quot;host&quot;</span>,<span class="hljs-string">&quot;@timestamp&quot;</span>,<span class="hljs-string">&quot;message&quot;</span>]<br>  &#125;<br><br>  <span class="hljs-keyword">mutate</span> &#123;<br><br>    <span class="hljs-attr">split</span> =&gt; [<span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-string">&quot;(&quot;</span>]<br>    <span class="hljs-attr">add_field</span> =&gt; &#123; <span class="hljs-string">&quot;title&quot;</span> =&gt; <span class="hljs-string">&quot;%&#123;[content][0]&#125;&quot;</span>&#125;<br>    <span class="hljs-keyword">add_field</span> =&gt; &#123; <span class="hljs-string">&quot;year&quot;</span> =&gt; <span class="hljs-string">&quot;%&#123;[content][1]&#125;&quot;</span>&#125;<br>  &#125;<br><br>  <span class="hljs-keyword">mutate</span> &#123;<br>    <span class="hljs-attr">convert</span> =&gt; &#123;<br>      <span class="hljs-string">&quot;year&quot;</span> =&gt; <span class="hljs-string">&quot;integer&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">strip</span> =&gt; [<span class="hljs-string">&quot;title&quot;</span>]<br>    remove_field =&gt; [<span class="hljs-string">&quot;path&quot;</span>, <span class="hljs-string">&quot;host&quot;</span>,<span class="hljs-string">&quot;@timestamp&quot;</span>,<span class="hljs-string">&quot;message&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>]<br>  &#125;<br><br>&#125;<br><span class="hljs-keyword">output</span> &#123;<br>   elasticsearch &#123;<br>     <span class="hljs-attr">hosts</span> =&gt; <span class="hljs-string">&quot;http://localhost:9200&quot;</span><br>     <span class="hljs-attr">index</span> =&gt; <span class="hljs-string">&quot;movies&quot;</span><br>     <span class="hljs-attr">document_id</span> =&gt; <span class="hljs-string">&quot;%&#123;id&#125;&quot;</span><br>   &#125;<br>  <span class="hljs-keyword">stdout</span> &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ./logstash -f logstash.conf<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>ELK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ELK</tag>
      
      <tag>logstash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch 简介</title>
    <link href="/2020/02/05/Elasticsearch%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/02/05/Elasticsearch%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch简介"><a href="#Elasticsearch简介" class="headerlink" title="Elasticsearch简介"></a>Elasticsearch简介</h2><h3 id="1、Elasticsearch-下载及启动"><a href="#1、Elasticsearch-下载及启动" class="headerlink" title="1、Elasticsearch 下载及启动"></a>1、Elasticsearch 下载及启动</h3><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.elastic.co<span class="hljs-regexp">/cn/</span>downloads/elasticsearch   <span class="hljs-comment"># 下载地址</span><br></code></pre></td></tr></table></figure><p>下载完成后解压进入该文件目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/elasticsearch  <span class="hljs-comment"># 启动 elasticsearch</span><br>网址输入为：localhost:9200  <span class="hljs-comment"># 查看是否启动成功</span><br></code></pre></td></tr></table></figure><h3 id="2、插件管理"><a href="#2、插件管理" class="headerlink" title="2、插件管理"></a>2、插件管理</h3><p>查看插件目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/elasticsearch-plugins list<br></code></pre></td></tr></table></figure><p>安装插件</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bin/elasticsearch-plugins </span><span class="hljs-keyword">install </span>analysis-icu<br></code></pre></td></tr></table></figure><p>如何查看插件是否安装成功</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">bin/elasticsearch <span class="hljs-comment"># 启动 elasticsearch</span><br>网址输入为：localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_cat/</span>plugins   <span class="hljs-comment"># _cat 为一个查询API</span><br></code></pre></td></tr></table></figure><h3 id="3、node-管理"><a href="#3、node-管理" class="headerlink" title="3、node 管理"></a>3、node 管理</h3><p>启动多个elasticsearch 实例</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># node.name为节点名称或实例名称   cluster.name为集群名称  path.data为存放数据路径</span><br>bin/elasticsearch -E node.<span class="hljs-attribute">name</span>=node0 -E cluster.<span class="hljs-attribute">name</span>=geektime -E path.<span class="hljs-attribute">data</span>=node0_data -d<br>bin/elasticsearch -E node.<span class="hljs-attribute">name</span>=node1 -E cluster.<span class="hljs-attribute">name</span>=geektime -E path.<span class="hljs-attribute">data</span>=node1_data -d<br></code></pre></td></tr></table></figure><p>查看 node</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">网址为：localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_cat/</span>nodes<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>ELK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ELK</tag>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>selenium/standalone-chrome:latest 找不到服务名称解决办法</title>
    <link href="/2019/12/17/seleniumstandalone-chromelatest%20%E6%89%BE%E4%B8%8D%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%90%8D%E7%A7%B0%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2019/12/17/seleniumstandalone-chromelatest%20%E6%89%BE%E4%B8%8D%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%90%8D%E7%A7%B0%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="selenium-x2F-standalone-chrome-latest-找不到服务名称解决办法"><a href="#selenium-x2F-standalone-chrome-latest-找不到服务名称解决办法" class="headerlink" title="selenium&#x2F;standalone-chrome:latest 找不到服务名称解决办法"></a>selenium&#x2F;standalone-chrome:latest 找不到服务名称解决办法</h3><h4 id="问题概述："><a href="#问题概述：" class="headerlink" title="问题概述："></a>问题概述：</h4><p>使用 docker-compose 创建和管理容器，使用镜像selenium&#x2F;standalone-chrome:latest 创建容器 chrome</p><p>docker-compose文件如下：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;3.6&#x27;</span><br><br><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">whatweb</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">whatweb:v0.0.2</span><br>    <span class="hljs-attribute">build</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">context</span><span class="hljs-punctuation">:</span> <span class="hljs-string">./services/whatweb</span><br>      <span class="hljs-attribute">dockerfile</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Dockerfile-information</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;./services/whatweb:/usr/src/app&#x27;</span><br>    <span class="hljs-attribute">restart</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attribute">env_file</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">whatweb-information.env</span><br>    <span class="hljs-attribute">network_mode</span><span class="hljs-punctuation">:</span> <span class="hljs-string">host</span><br><br>  <span class="hljs-attribute">whatweb-chrome</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">selenium/standalone-chrome:latest</span><br>    <span class="hljs-attribute">restart</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attribute">shm_size</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2g</span><br>    <span class="hljs-attribute">network_mode</span><span class="hljs-punctuation">:</span> <span class="hljs-string">host</span><br><br></code></pre></td></tr></table></figure><p>配置文件如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># chromedriver_url</span><br>COMMAND_EXECUTOR=http:<span class="hljs-regexp">//</span>chrome:<span class="hljs-number">4444</span><span class="hljs-regexp">/wd/</span>hub  <span class="hljs-comment"># 此处的chrome 为容器名称</span><br></code></pre></td></tr></table></figure><p>当启动容器时并没有问题，可能正常使用 4444 端口，但是一旦调用配置文件中的信息就会出现问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">raised unexpected: MaxRetryError(\&quot;HTTPConnectionPool(host=<span class="hljs-string">&#x27;whatweb-chrome&#x27;</span>, port=4444): Max retries exceeded with url: /wd/hub/session (Caused by NewConnectionError(<span class="hljs-string">&#x27;&lt;urllib3.connection.HTTPConnection object at 0x7f02296f2e90&gt;: Failed to establish a new connection: [Errno -2] Name or service not known&#x27;</span>))\&quot;)<span class="hljs-string">&quot;,</span><br></code></pre></td></tr></table></figure><p>此时是因为在docker-compose 文件中我们配置的 network 为 host模式，我们是直接使用宿主机的网络配置，并没有出现chrome 与 ip 地址的映射关系，所以服务并不能识别访问<a href="http://chrome:4444/wd/hub">http://chrome:4444/wd/hub</a></p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># chromedriver_url</span><br>COMMAND_EXECUTOR=http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">4444</span><span class="hljs-regexp">/wd/</span>hub  <span class="hljs-comment"># 将 Chrome 直接替换为 localhost 地址，会直接调用本机网络配置去访问</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>容器化</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>selenium/standalone-chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深究 sqlalchemy 中表关系table relationships</title>
    <link href="/2019/12/12/%E6%B7%B1%E7%A9%B6%20sqlalchemy%20%E4%B8%AD%E8%A1%A8%E5%85%B3%E7%B3%BBtable%20relationships/"/>
    <url>/2019/12/12/%E6%B7%B1%E7%A9%B6%20sqlalchemy%20%E4%B8%AD%E8%A1%A8%E5%85%B3%E7%B3%BBtable%20relationships/</url>
    
    <content type="html"><![CDATA[<h2 id="深究-sqlalchemy-中表关系table-relationships"><a href="#深究-sqlalchemy-中表关系table-relationships" class="headerlink" title="深究 sqlalchemy 中表关系table relationships"></a>深究 sqlalchemy 中表关系table relationships</h2><h2 id="为什么需要定义Relationships"><a href="#为什么需要定义Relationships" class="headerlink" title="为什么需要定义Relationships"></a>为什么需要定义Relationships</h2><p>在相关联的表中，我们可以不创建表关联的定义，而只是单纯互相引用id即可。但是，查询和使用起来就要麻烦很多：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs pgsql">＃给定参数<span class="hljs-keyword">User</span>.name,获取该<span class="hljs-keyword">user</span>的addresses<br># 参考知乎：https://www.zhihu.com/question/<span class="hljs-number">38456789</span>/answer/<span class="hljs-number">90470689</span><br><br>def get_addresses_from_user(user_name):<br>    <span class="hljs-keyword">user</span> = <span class="hljs-keyword">session</span>.query(<span class="hljs-keyword">User</span>).filter_by(<span class="hljs-type">name</span>=user_name).first()<br>    addresses = <span class="hljs-keyword">session</span>.query(Address).filter_by(user_id=<span class="hljs-keyword">user</span>.id).<span class="hljs-keyword">all</span>()<br>    <span class="hljs-keyword">return</span> addresses<br></code></pre></td></tr></table></figure><p>可以看到，这样的效率非常低。<br>好在原生的SQL就有relationship设置，SQLAlchemy将其引入到了ORM模型中。</p><p><strong>它可以让我们只在表中声明表之间的关系，之后每次使用就完全无需手动<code>交叉搜索</code>，而是像对待一个表中的数据一样直接使用。</strong></p><h2 id="为什么不需要定义relationships？"><a href="#为什么不需要定义relationships？" class="headerlink" title="为什么不需要定义relationships？"></a>为什么不需要定义relationships？</h2><p>经过实践返回来加的这一节：实践中的SQLAlchemy的”relationship”在一定程度上反而导致了整体表关联关系的极大复杂化，还有效率的极其低下。</p><p>如果你的数据库只有两个表的话，那么relationship随便定义随便用。如果只有几百条数据的话，那么也请随便玩。</p><p>但是，当数据库中有数十个表以上，单个关联层级就多过三个表以上层层关联，而且各个数据量以万为单位。那么，”relationship”会把整个人都搞垮，简直还不如手写SQL语句清晰好理解，并且效率也差在了秒级与毫秒级的区别上。</p><blockquote><p>SQLAlchemy只能很轻松handle <code>Many to Many</code>，但是如果是常见的<code>Many to Many to Many</code>，或者是<code>Many to Many to Many to Many</code>，那简直就是噩梦。</p></blockquote><p>但是，我们都知道，项目做到一定程度，都会摆脱不了ORM。无论是自己造轮子还是用别人的，无论起点是不是纯SQL，终点都是ORM。<br>那么该怎么办呢？</p><p>网友的建议是：<br><strong>用SQLAlchemy建立各种ORM类对象，不要用内置的关联，直接在查询的时候手动SQL语句！</strong></p><p>经过实践，我的建议是：</p><ul><li>容易SQL-Injection注入的地方，用SQLAlchemy的<code>query</code></li><li>创建ORM对象时候，用SQLAlchemy</li><li><strong>多层关联的时候，不要用SQLAlchemy</strong></li><li>查询的时候，用SQL</li><li>插入数据的时候，不要用SQLAlchemy。（官方都说明了插入百万级的时候，和SQL插件是秒级的）</li></ul><h2 id="relationship-函数"><a href="#relationship-函数" class="headerlink" title="relationship() 函数"></a>relationship() 函数</h2><p><a href="https://docs.sqlalchemy.org/en/rel_1_0/orm/backref.html#relationships-backref">参考官方文档：Linking Relationships with Backref</a></p><p>SQLAlchemy创建表关联时，使用的是<code>relationshi()</code>这个函数。<br>它返回的是一个类的属性，比如father类的<code>children</code>属性。但是，它实际上并没有在father表中创建任何叫children的列，而是自动帮你到相关联的children表中去找数据，让你用起来感觉没有差别而已。<br>这是非常方便的！</p><p><code>relationship()</code>这个函数的参数非常多，每一个参数都有很多内容需要理解。因为所有的表关联的形态，都是在这个函数里面定义的。<br>以下分别讲解。</p><h2 id="Reference-正向引用"><a href="#Reference-正向引用" class="headerlink" title="Reference 正向引用"></a>Reference 正向引用</h2><p>传统的方法，是在父类中定义一个<code>关系 relationship</code>或叫<code>正向引用 Reference</code>，子类只需定义一个外键。比如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Father</span>(..): </span><br><span class="hljs-class">    id = <span class="hljs-type">Column</span>(..)</span><br><span class="hljs-class">    children = relationship(&#x27;<span class="hljs-type">Child</span>&#x27;)</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Child</span>(..):</span><br><span class="hljs-class">    father_id = <span class="hljs-type">Column</span>( <span class="hljs-type">Integer</span>, <span class="hljs-type">ForeignKey</span>(&#x27;<span class="hljs-title">father</span>.<span class="hljs-title">id&#x27;</span>) )</span><br><span class="hljs-class"></span><br><span class="hljs-class"># 添加数据</span><br><span class="hljs-class">daddy = <span class="hljs-type">Father</span>()</span><br><span class="hljs-class">jason = <span class="hljs-type">Child</span>()</span><br><span class="hljs-class">emma = <span class="hljs-type">Child</span>()</span><br><span class="hljs-class"></span><br><span class="hljs-class"># 将孩子挂到父亲名下</span><br><span class="hljs-class">daddy.children.append(<span class="hljs-title">jason</span>)</span><br><span class="hljs-class">daddy.children.append(<span class="hljs-title">emma</span>)</span><br></code></pre></td></tr></table></figure><p>这样当每次我们使用<code>father.children</code>的时候，就会自动返回与这个father相关联的所有children了。</p><h2 id="Back-Reference-反向引用"><a href="#Back-Reference-反向引用" class="headerlink" title="Back Reference 反向引用"></a>Back Reference 反向引用</h2><p>单纯定义的<code>relationship(&#39;子类名&#39;)</code>只是一个正向引用，也就是只能让父类调用子对象。反过来，如果要问children他们的父亲是谁，就不行了。</p><p><strong>所以，我们还需要一个<code>反向引用 (Back Reference)</code>的声明，让子对象能够知道父对象是谁。</strong></p><p>定义方式是在父类的relationship(..)中加一个参数<code>backref</code>：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>(..): <br>    children = relationship( <span class="hljs-string">&#x27;Child&#x27;</span>, backref=<span class="hljs-string">&#x27;parent&#x27;</span> )<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>backref参数里面使用的随便写，主要用于之后子类的引用。</li><li>backref参数是<code>双向性</code>的，意思是，只需要在父类中声明一次，那么<code>父⇄子</code>的双向关系就确立了，不用再去子类中写一遍。</li></ol><p>这时候，我们在添加就可以这样互相调用了：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">&gt;&gt;&gt; <span class="hljs-variable">Jason</span> = <span class="hljs-function"><span class="hljs-title">Child</span>()</span><br>&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title">print</span>( <span class="hljs-variable">Jason.parent</span> )</span><br> &lt;<span class="hljs-variable">__main__.Father</span> <span class="hljs-variable"><span class="hljs-class">object</span></span> <span class="hljs-variable">at</span> <span class="hljs-number">0</span><span class="hljs-variable">x10222f860</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="Bidirectional-amp-Unidirectional-Back-Reference-双向和单向的反向引用"><a href="#Bidirectional-amp-Unidirectional-Back-Reference-双向和单向的反向引用" class="headerlink" title="Bidirectional &amp; Unidirectional Back Reference 双向和单向的反向引用"></a>Bidirectional &amp; Unidirectional Back Reference 双向和单向的反向引用</h2><p>后来，SQLAlchemy发现这种只在一边定义双向性<code>backref</code>的方法有点不太直观，所以又添加了另一个参数<code>back_populates</code>参数，而这个back_populates参数是单向性的，也就是说：<br>你要确立双方向关系就必须在两边的类中都声明一遍。这样比较直观。</p><blockquote><p>可以把<code>backref</code>和<code>back_populates</code>都读为”as”，这样就好记忆了。</p></blockquote><p>比如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Father</span>(..): </span><br><span class="hljs-class">    id = <span class="hljs-type">Column</span>(..)</span><br><span class="hljs-class">    children = relationship( &#x27;<span class="hljs-type">Child</span>&#x27;, <span class="hljs-title">back_populates</span>=&#x27;<span class="hljs-title">parent&#x27;</span> )</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Child</span>(..):</span><br><span class="hljs-class">    father_id = <span class="hljs-type">Column</span>( <span class="hljs-type">Integer</span>, <span class="hljs-type">ForeignKey</span>(&#x27;<span class="hljs-title">father</span>.<span class="hljs-title">id&#x27;</span>) )</span><br><span class="hljs-class">    parent = relationship( &#x27;<span class="hljs-type">Father</span>&#x27;, <span class="hljs-title">back_populates</span>=&#x27;<span class="hljs-title">children&#x27;</span> )</span><br></code></pre></td></tr></table></figure><p><strong>注意：<code>back_populates</code>要求父类子类的关系名称必须严格“对称”：</strong></p><ul><li>父类的relationship属性名<code>children</code>，必须对应子类的关系中的<code>back_populates</code>中的值</li><li>子类的relationship属性名<code>parent</code>，必须对应父类的关系中的<code>back_populates</code>中的值</li></ul><p>这样一来利用<code>反向引用</code>参数创建的关系就确立了。但是注意，<br>无论用<code>backref</code>还是<code>back_populates</code>创建的关联，如果我们必须要为父子对象添加对象间的关联才能引用，否则谁也不知道谁是谁的父亲、儿子：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="language-python">daddy = Father()</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="language-python">son = Child()</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="language-python">daughter = Child()</span><br><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="language-python">daddy.children</span><br>[]<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="language-python">son.parent</span><br>None<br><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="language-python">daddy.children.append( son )</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="language-python">daddy.children.append( daughter )</span><br><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="language-python">daddy.children</span><br>[ &lt;Child ...&gt;, &lt;Child ...&gt; ]<br><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="language-python">son.parent</span><br>&lt;Father ...&gt;<br></code></pre></td></tr></table></figure><p>另外：上面添加父子关系的时候，不光可以用<code>daddy.children.append</code>，<br>还可以在声明子对象的时候确定：<code>son = Child( parent=daddy )</code></p><p><code>反向引用</code>参数对比：</p><ul><li><code>backref</code>参数：双方向。在父类中定义即可。只能通过<code>daddy.children.append()</code>方式添加子对象关联。</li><li><code>back_populates</code>参数：单方向。必须在父子类中都定义，且属性名称必须严格对称。还可以通过<code>Child(parent=daddy)</code>的方式添加父对象关联。</li></ul><h2 id="SQL中的表关系"><a href="#SQL中的表关系" class="headerlink" title="SQL中的表关系"></a>SQL中的表关系</h2><p>对应关系：</p><ul><li>One to Many 一对多：</li><li>Many to One 多对一：</li><li>Many to Many 多对多：</li></ul><h3 id="One-to-Many-一对多"><a href="#One-to-Many-一对多" class="headerlink" title="One to Many 一对多"></a>One to Many 一对多</h3><p>建立一个<code>One-to-Many</code>的多表关联：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-meta"># ...</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Person</span>(<span class="hljs-type">Base</span>):</span><br><span class="hljs-class">    id = <span class="hljs-type">Column</span>(...)</span><br><span class="hljs-class">    name = <span class="hljs-type">Column</span>(...)</span><br><span class="hljs-class">    pets = relationship(&#x27;<span class="hljs-type">Pet</span>&#x27;, <span class="hljs-title">backref</span>=&#x27;<span class="hljs-title">owner&#x27;</span>)</span><br><span class="hljs-class">    # 上面这句是添加一关联，而不是实际的列</span><br><span class="hljs-class">    # 注意：1. &#x27;<span class="hljs-type">Pet&#x27;</span>是大写开头，因为指向了<span class="hljs-type">Python</span>类，而不是数据库中表</span><br><span class="hljs-class">    # 2. backref是指建立一个不存在于数据库的“假列”，</span><br><span class="hljs-class">    # 用于添加数据时候指认关联对象，代替传统id指定</span><br><span class="hljs-class"></span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Pet</span>(<span class="hljs-type">Base</span>):</span><br><span class="hljs-class">    id = <span class="hljs-type">Column</span>(...)</span><br><span class="hljs-class">    name = <span class="hljs-type">Column</span>(...)</span><br><span class="hljs-class">    owner_id = <span class="hljs-type">Column</span>(<span class="hljs-type">Integer</span>, <span class="hljs-type">ForeignKey</span>(&#x27;<span class="hljs-title">person</span>.<span class="hljs-title">id&#x27;</span>)</span><br><span class="hljs-class">    # 上面这句添加了一个外键，</span><br><span class="hljs-class">    # 注意外键的&#x27;person&#x27;是数据库中的表名，而不是<span class="hljs-keyword">class</span>类名，所以用小写以区分</span><br></code></pre></td></tr></table></figure><p>创建好关联的表以后，我们就可以直接插入数据了。注意，插入带关联的数据也和SQL插入有些不同：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#...</span><br><br><span class="hljs-comment"># 添加主人</span><br>andy = Person(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Andrew&#x27;</span>)<br>session.<span class="hljs-built_in">add</span>( andy )<br>seession.commit()<br><br><span class="hljs-comment"># 添加狗</span><br>pp01 = Pet(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Puppy&#x27;</span>, <span class="hljs-attribute">owner</span>=andy)<br>pp02 = Pet(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Puppy&#x27;</span>, <span class="hljs-attribute">owner</span>=andy)<br><span class="hljs-comment"># 注意这句话中，owner是刚才主表中注册relationship中的backref指定的参数名，</span><br><span class="hljs-comment"># 传给owner的是主表的一个Python实例化对象，而不是什么id</span><br><span class="hljs-comment"># 看起来复杂，实际上sqlalchemy可以自动取出object的id然后匹配副表中的foreignkey。</span><br><br>session.<span class="hljs-built_in">add</span>(pp01)<br>session.<span class="hljs-built_in">add</span>(pp02)<br>session.commit()<br><br><span class="hljs-built_in">print</span>( andy.pets )<br><span class="hljs-comment"># &gt;&gt;&gt; [&lt;Pet 1&gt;, &lt;Pet, 2&gt;]</span><br><span class="hljs-comment"># 返回的是两个Pet对象</span><br><br><span class="hljs-built_in">print</span>( pp01.owner )<br><span class="hljs-comment"># &gt;&gt;&gt; &lt;Person &#x27;Andrew&#x27;&gt;</span><br><span class="hljs-comment"># 同样，副表中利用owner这个backref定义的假列，返回的是Person对象。</span><br></code></pre></td></tr></table></figure><h3 id="Many-to-One-多对一"><a href="#Many-to-One-多对一" class="headerlink" title="Many to One 多对一"></a>Many to One 多对一</h3><p>比如职工和公司的关系就是多对一。这和公司与职工对一对多有什么区别？<br>区别其实是在SQL语句中的：多对一的关联关系，是在多的一方的表中定义，一的一方表中没有任何关系定义：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> <span class="hljs-constructor">Company(<span class="hljs-operator">...</span>)</span>:<br>    id = <span class="hljs-constructor">Column(<span class="hljs-operator">...</span>)</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-constructor">Employee(..)</span>:<br>    id = <span class="hljs-constructor">Column(<span class="hljs-operator">...</span>)</span><br>    company_id = <span class="hljs-constructor">Column( <span class="hljs-operator">...</span>, ForeignKey(&#x27;<span class="hljs-params">company</span>.<span class="hljs-params">id</span>&#x27;)</span> )<br>    company = relationship(<span class="hljs-string">&quot;Company&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="Many-to-Many-多对多"><a href="#Many-to-Many-多对多" class="headerlink" title="Many to Many 多对多"></a>Many to Many 多对多</h3><p>多对多的关系也很常见，比如User和Radio的关系：<br>一个Radio可以有多个用户可以订阅，一个用户可以订阅多个Radio。</p><p>SQL中处理多对多的关系时，是把多对多分拆成两个一对多关系。做法是：新创建一个表，专门存储映射关系。原本的两个表无需设置任何外键。</p><p>SQLAlchemy的实践中，也和SQL中的做法一样。</p><p><strong>注意：既然有了专门的Mapping映射表，那么两个表各自就不需要注册任何ForeignKey外键了。</strong></p><p>示例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"># 做出一个专门的表，存储映射关系<br># 注意：<span class="hljs-number">1.</span> 这个表中两个<span class="hljs-string">&quot;id&quot;</span>都不是主键，因为是多对多的关系，所以二者都可以有多条数据。<br>#  <span class="hljs-number">2.</span> 映射表必须在前面定义，否则后面的类引用时，编译器会找不到<br>radio_users = Table(<span class="hljs-string">&#x27;radio_users&#x27;</span>, Base.metadata,<br>    Column(<span class="hljs-string">&#x27;whatever_name1&#x27;</span>, Integer, ForeignKey(<span class="hljs-string">&#x27;radios.id&#x27;</span>)),<br>    Column(<span class="hljs-string">&#x27;whatever_name2&#x27;</span>, Integer, ForeignKey(<span class="hljs-string">&#x27;users.id&#x27;</span>))<br>)<br><br># 定义两个ORM对象：<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Radio</span>(<span class="hljs-symbol">Base</span>):<br>    <span class="hljs-symbol">__tablename__</span> = &#x27;<span class="hljs-symbol">radios</span>&#x27;<br><br>    <span class="hljs-symbol">rid</span> = <span class="hljs-symbol">Column</span>(&#x27;<span class="hljs-symbol">id</span>&#x27;, <span class="hljs-symbol">Integer, <span class="hljs-symbol">primary_key</span></span>=<span class="hljs-symbol">True</span>)<br>    <span class="hljs-symbol">followers</span> = <span class="hljs-symbol">relationship</span>(&#x27;<span class="hljs-symbol">User</span>&#x27;,<br>        <span class="hljs-symbol">secondary</span>=<span class="hljs-symbol">radio_users,     </span># `<span class="hljs-symbol">secondary</span>`是专门用来指明映射表的<br>        <span class="hljs-symbol">back_populates</span>=&#x27;<span class="hljs-symbol">subscriptions</span>&#x27;    # 这个值要对应另一个类的属性名<br>    )<br><br><span class="hljs-symbol">class</span> <span class="hljs-symbol">User</span>(<span class="hljs-symbol">Base</span>):<br>    <span class="hljs-symbol">__tablename__</span> = &#x27;<span class="hljs-symbol">users</span>&#x27;<br><br>    <span class="hljs-symbol">uid</span> = <span class="hljs-symbol">Column</span>(&#x27;<span class="hljs-symbol">id</span>&#x27;, <span class="hljs-symbol">Integer, <span class="hljs-symbol">primary_key</span></span>=<span class="hljs-symbol">True</span>)<br>    <span class="hljs-symbol">subscriptions</span> = <span class="hljs-symbol">relationship</span>(&#x27;<span class="hljs-symbol">Radio</span>&#x27;,<br>        <span class="hljs-symbol">secondary</span>=<span class="hljs-symbol">radio_users,</span><br><span class="hljs-symbol">        <span class="hljs-symbol">back_populates</span></span>=&#x27;<span class="hljs-symbol">followers</span>&#x27;   # 这个值要对应另一个类的属性名<br>    )<br></code></pre></td></tr></table></figure><p>其中，<code>secondary</code>是专门用来指明映射表的。</p><blockquote><p>注意：多对多的时候我们也可以用<code>backref</code>参数来添加互相引用。但是这种方法太不直观了，容易产生混乱。所以这里建议用<code>back_populates</code>参数，在两方都添加引用，表现一种平行地位，方便理解。</p></blockquote><p>然后插入数据时候是这么用：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-built_in">r1</span> = Radio()<br><span class="hljs-built_in">r2</span> = Radio()<br><span class="hljs-built_in">r3</span> = Radio()<br><br>u1 = User()<br>u2 = User()<br>u3 = User()<br><br><span class="hljs-meta"># 添加对象间的关联</span><br><span class="hljs-built_in">r1</span>.followers += [u1, u2, u3]<br><br><span class="hljs-meta"># 反过来添加也一样</span><br>u1.subscriptions += [<span class="hljs-built_in">r2</span>, <span class="hljs-built_in">r3</span>]<br></code></pre></td></tr></table></figure><h2 id="Many-to-Many-to-Many-多对多对多-（深层关联）"><a href="#Many-to-Many-to-Many-多对多对多-（深层关联）" class="headerlink" title="Many to Many to Many 多对多对多 （深层关联）"></a>Many to Many to Many 多对多对多 （深层关联）</h2><p>深层关联，为了避免理解困难，最笨的方法就是简单的使用外键ID，然后手动搜索另一个表的对应ID。<br><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081130360.png" alt="image"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>sqlalchemy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>sqlalchemy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 docker 部署基于 selenium+chrome-headless的服务</title>
    <link href="/2019/11/29/%E4%BD%BF%E7%94%A8%20docker%20%E9%83%A8%E7%BD%B2%E5%9F%BA%E4%BA%8E%20selenium+chrome-headless%E7%9A%84%E6%9C%8D%E5%8A%A1/"/>
    <url>/2019/11/29/%E4%BD%BF%E7%94%A8%20docker%20%E9%83%A8%E7%BD%B2%E5%9F%BA%E4%BA%8E%20selenium+chrome-headless%E7%9A%84%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="使用-docker-部署基于-selenium-chrome-headless的服务"><a href="#使用-docker-部署基于-selenium-chrome-headless的服务" class="headerlink" title="使用 docker 部署基于 selenium+chrome-headless的服务"></a>使用 docker 部署基于 selenium+chrome-headless的服务</h2><h3 id="1、编写-docker-compose-文件"><a href="#1、编写-docker-compose-文件" class="headerlink" title="1、编写 docker-compose 文件"></a>1、编写 docker-compose 文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">bs-whatweb-chrome:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">selenium/standalone-chrome:latest</span>  <span class="hljs-comment"># 使用官方镜像</span><br>    <span class="hljs-attr">ports:</span>  <span class="hljs-comment"># 端口映射（后续可能没用）</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">9999</span><span class="hljs-string">:4444</span><br>    <span class="hljs-attr">shm_size:</span> <span class="hljs-string">2g</span>  <span class="hljs-comment"># docker 默认的共享内存只有 64M，当启动多个 Chrome 实例的时候可能会导致 Chrome 崩溃，所以需要增大/dev/shm的内存</span><br></code></pre></td></tr></table></figure><h3 id="2、基础配置"><a href="#2、基础配置" class="headerlink" title="2、基础配置"></a>2、基础配置</h3><p>selenium 容器的 hostname 是 Chrome，所以需要修改COMMAND_EXECUTOR的 IP地址，修改如下：</p><p>bs-whatweb-chrome 为项目中关于 selenium容器名字</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># chromedriver_url</span><br>COMMAND_EXECUTOR=http:<span class="hljs-regexp">//</span>bs-whatweb-chrome:<span class="hljs-number">4444</span><span class="hljs-regexp">/wd/</span>hub <br></code></pre></td></tr></table></figure><h3 id="3、使用示例"><a href="#3、使用示例" class="headerlink" title="3、使用示例"></a>3、使用示例</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.chrome.<span class="hljs-keyword">options</span> <span class="hljs-keyword">import</span> <span class="hljs-keyword">Options</span><br><span class="hljs-keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="hljs-keyword">import</span> DesiredCapabilities<br><br># 无界面浏览器获取最新的网址（网站可能存在重定向情况）<br>chrome_options = <span class="hljs-keyword">Options</span>()<br>chrome_options.add_argument(<span class="hljs-string">&#x27;--headless&#x27;</span>)  # 使用无界面浏览器<br>driver = webdriver.Remote(<br>    command_executor=current_app.config.<span class="hljs-keyword">get</span>(&quot;COMMAND_EXECUTOR&quot;),<br>    desired_capabilities=DesiredCapabilities.CHROME<br>)<br>driver.<span class="hljs-keyword">get</span>(target_url)<br>new_target_url = driver.current_url<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><code class="hljs text">最近在看一些底层的东西。<br><br>driver翻译过来是驱动，司机的意思。如果将webdriver比做成司机，竟然非常恰当。<br><br>我们可以把WebDriver驱动浏览器类比成出租车司机开出租车。<br><br>在开出租车时有三个角色：<br>乘客：他/她告诉出租车司机去哪里，大概怎么走<br>出租车司机：他按照乘客的要求来操控出租车<br>出租车：出租车按照司机的操控完成真正的行驶，把乘客送到目的地<br><br>在WebDriver中也有类似的三个角色：<br><br>自动化测试代码：自动化测试代码发送请求给浏览器的驱动（比如火狐驱动、谷歌驱动）<br>浏览器的驱动：它来解析这些自动化测试的代码，解析后把它们发送给浏览器<br>浏览器：执行浏览器驱动发来的指令，并最终完成工程师想要的操作。<br><br>所以在这个类比中：<br><br>工程师写的自动化测试代码就相当于是乘客<br><br>浏览器的驱动就相当于是出租车司机<br><br>浏览器就相当于是出租车<br><br>面再从技术上解释下WebDriver的工作原理：<br>从技术上讲，也同样是上面的三个角色：<br><br>WebDriver API（基于Java、Python、C#等语言）<br><br>对于java语言来说，就是下载下来的selenium的Jar包，比如selenium-java-3.8.1.zip包，代表Selenium3.8.1的版本<br><br>浏览器的驱动（browser driver）<br><br>每个浏览器都有自己的驱动，均以exe文件形式存在<br><br>比如谷歌的chromedriver.exe、火狐的geckodriver.exe、IE的IEDriverServer.exe<br><br>浏览器<br><br>浏览器当然就是我们很熟悉的常用的各种浏览器。<br><br>那在WebDriver脚本运行的时候，它们之间是如何通信的呢？为什么同一个browser driver即可以处理java语言的脚本，也可以处理python语言的脚本呢？让我们来看一下，一条Selenium脚本执行时后端都发生了哪些事情：<br><br>对于每一条Selenium脚本，一个http请求会被创建并且发送给浏览器的驱动<br>浏览器驱动中包含了一个HTTP Server，用来接收这些http请求<br>HTTP Server接收到请求后根据请求来具体操控对应的浏览器<br>浏览器执行具体的测试步骤<br>浏览器将步骤执行结果返回给HTTP Server<br>HTTP Server又将结果返回给Selenium的脚本，如果是错误的http代码我们就会在控制台看到对应的报错信息。<br>为什么使用HTTP协议呢？<br><br>因为HTTP协议是一个浏览器和Web服务器之间通信的标准协议，而几乎每一种编程语言都提供了丰富的http libraries，这样就可以方便的处理客户端Client和服务器Server之间的请求request及响应response，WebDriver的结构中就是典型的C/S结构，WebDriver API相当于是客户端，而小小的浏览器驱动才是服务器端。<br><br>WebDriver基于的协议：JSON Wire protocol。<br><br>JSON Wire protocol是在http协议基础上，对http请求及响应的body部分的数据的进一步规范。<br><br>我们知道在HTTP请求及响应中常常包括以下几个部分：http请求方法、http请求及响应内容body、http响应状态码等。<br><br>常见的http请求方法：<br><br>GET：用来从服务器获取信息。比如获取网页的标题信息<br><br>POST：向服务器发送操作请求。比如findElement，Click等<br><br>http响应状态码：<br><br>在WebDriver中为了给用户以更明确的反馈信息，提供了更细化的http响应状态码，比如：<br><br>7：NoSuchElement<br><br>11：ElementNotVisible<br><br>200：Everything OK<br><br>现在到了最关键的http请求及响应的body部分了：<br><br>body部分主要传送具体的数据，在WebDriver中这些数据都是以JSON的形式存在并进行传送的，这就是JSON Wire protocol。<br><br>Selenium 是将各个浏览器的API封装成&quot; Selenium自己设计定义的协议，名字叫做The WebDriver Wire Protocol &quot; 的webdriver API <br><br>操作层面：<br><br>1、测试人员编写UI自动化测试脚本（java,python等等），运行脚本后，程序会打开指定的webdriver浏览器<br><br>webdriver浏览器作为一个remote-server 接受脚本的命令，同时webservice会打开一个端口：http://localhost:9515 浏览器则会监听这个端口<br><br>2、webservice会将脚本语言翻译成json格式传递给浏览器执行操作命令<br><br>逻辑层面：<br><br>1、测试人员执行测试脚本后，就创建了一个session, 通过http 请求向webservice发送了restfull的请求。<br><br>2、webservice翻译restfull的请求为浏览器能懂的脚本，然后接受脚本执行结果。<br><br>3、webservice将结果进行封装--json 给到客户端client/测试脚本 ，然后client就知道操作是否成功，同时测试也可以进行校验了。<br><br>我们可以验证一下：<br>下载好chromedriver，放到环境变量里，注意要和chrome浏览器版本对上，然后执行chromedriver<br>可以看到，会启动一个server, 并开启端口9515：<br><br>andersons-iMac:~ anderson$ chromedriver<br>Starting ChromeDriver 2.39.562713 (dd642283e958a93ebf6891600db055f1f1b4f3b2) on port 9515<br>Only local connections are allowed.<br>GVA info: Successfully connected to the Intel plugin, offline Gen9<br>强调了只允许本地连接。<br><br>前面已经提过了，乘客向司机发一个请求，<br>行为是构造一个http请求<br>构造的请求是这样子的：<br><br>请求方式 ：POST<br>请求地址 ：http://localhost:9515/session<br>请求body ：<br><br>capabilities = &#123;<br>    &quot;capabilities&quot;: &#123;<br>        &quot;alwaysMatch&quot;: &#123;<br>            &quot;browserName&quot;: &quot;chrome&quot;<br>        &#125;,<br>        &quot;firstMatch&quot;: [<br>            &#123;&#125;<br>        ]<br>    &#125;,<br>    &quot;desiredCapabilities&quot;: &#123;<br>        &quot;platform&quot;: &quot;ANY&quot;,<br>        &quot;browserName&quot;: &quot;chrome&quot;,<br>        &quot;version&quot;: &quot;&quot;,<br>        &quot;chromeOptions&quot;: &#123;<br>            &quot;args&quot;: [],<br>            &quot;extensions&quot;: []<br>        &#125;<br>    &#125;<br>&#125;<br>我们可以尝试使用python requests 向 ChromeDriver发送请求<br><br>import requests<br>import json<br>session_url = &#x27;http://localhost:9515/session&#x27;<br>session_pars = &#123;&quot;capabilities&quot;: &#123;&quot;firstMatch&quot;: [&#123;&#125;], \<br>                      &quot;alwaysMatch&quot;: &#123;&quot;browserName&quot;: &quot;chrome&quot;,\<br>                                      &quot;platformName&quot;: &quot;any&quot;, \<br>                                      &quot;goog:chromeOptions&quot;: &#123;&quot;extensions&quot;: [], &quot;args&quot;: []&#125;&#125;&#125;, \<br>                &quot;desiredCapabilities&quot;: &#123;&quot;browserName&quot;: &quot;chrome&quot;, \<br>                             &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;, &quot;goog:chromeOptions&quot;: &#123;&quot;extensions&quot;: [], &quot;args&quot;: []&#125;&#125;&#125;<br>r_session = requests.post(session_url,json=session_pars)<br>print(json.dumps(r_session.json(),indent=2))<br>结果：<br><br>&#123;<br>  &quot;sessionId&quot;: &quot;44fdb7b1b048a76c0f625545b0d2567b&quot;,<br>  &quot;status&quot;: 0,<br>  &quot;value&quot;: &#123;<br>    &quot;acceptInsecureCerts&quot;: false,<br>    &quot;acceptSslCerts&quot;: false,<br>    &quot;applicationCacheEnabled&quot;: false,<br>    &quot;browserConnectionEnabled&quot;: false,<br>    &quot;browserName&quot;: &quot;chrome&quot;,<br>    &quot;chrome&quot;: &#123;<br>      &quot;chromedriverVersion&quot;: &quot;2.40.565386 (45a059dc425e08165f9a10324bd1380cc13ca363)&quot;,<br>      &quot;userDataDir&quot;: &quot;/var/folders/yd/dmwmz84x5rj354qkz9rwwzbc0000gn/T/.org.chromium.Chromium.RzlABs&quot;<br>    &#125;,<br>    &quot;cssSelectorsEnabled&quot;: true,<br>    &quot;databaseEnabled&quot;: false,<br>    &quot;handlesAlerts&quot;: true,<br>    &quot;hasTouchScreen&quot;: false,<br>    &quot;javascriptEnabled&quot;: true,<br>    &quot;locationContextEnabled&quot;: true,<br>    &quot;mobileEmulationEnabled&quot;: false,<br>    &quot;nativeEvents&quot;: true,<br>    &quot;networkConnectionEnabled&quot;: false,<br>    &quot;pageLoadStrategy&quot;: &quot;normal&quot;,<br>    &quot;platform&quot;: &quot;Mac OS X&quot;,<br>    &quot;rotatable&quot;: false,<br>    &quot;setWindowRect&quot;: true,<br>    &quot;takesHeapSnapshot&quot;: true,<br>    &quot;takesScreenshot&quot;: true,<br>    &quot;unexpectedAlertBehaviour&quot;: &quot;&quot;,<br>    &quot;version&quot;: &quot;71.0.3578.80&quot;,<br>    &quot;webStorageEnabled&quot;: true<br>  &#125;<br>&#125;<br>如何打开一个网页，类似driver.get(url)<br>那么构造的请求是：<br><br>请求方式 ：POST<br>请求地址 ：http://localhost:9515/session/:sessionId/url<br><br>注意：上述地址中的 &quot;:sessionId&quot;<br>要用启动浏览器的请求返回结果中的sessionId的值<br>例如：我刚刚发送请求，启动浏览器，返回结果中&quot;sessionId&quot;: &quot;44fdb7b1b048a76c0f625545b0d2567b&quot;  <br>然后请求的URL地址<br>请求地址：http://localhost:9515/session/b2801b5dc58b15e76d0d3295b04d295c/url<br><br>请求body ：&#123;&quot;url&quot;: &quot;https://www.baidu.com&quot;, &quot;sessionId&quot;: &quot;44fdb7b1b048a76c0f625545b0d2567b&quot;&#125;<br>即：<br><br>import requests<br>url = &#x27;http://localhost:9515/session/44fdb7b1b048a76c0f625545b0d2567b/url&#x27;<br>pars = &#123;&quot;url&quot;: &quot;https://www.baidu.com&quot;, &quot;sessionId&quot;: &quot;44fdb7b1b048a76c0f625545b0d2567b&quot;&#125;<br>r = requests.post(url,json=pars)<br>print(r.json())<br>如何定位元素，类似driver.finde_element_by_xx:<br><br>请求方式 ：POST<br>请求地址 ：http://localhost:9515/session/:sessionId/element<br><br>注意：上述地址中的 &quot;:sessionId&quot;<br>要用启动浏览器的请求返回结果中的sessionId的值<br>例如：我刚刚发送请求，启动浏览器，返回结果中&quot;sessionId&quot;: &quot;b2801b5dc58b15e76d0d3295b04d295c&quot;  <br>然后我构造 查找页面元素的请求地址<br>请求地址：http://localhost:9515/session/b2801b5dc58b15e76d0d3295b04d295c/element<br><br>请求body ：&#123;&quot;using&quot;: &quot;css selector&quot;, &quot;value&quot;: &quot;.postTitle a&quot;, &quot;sessionId&quot;: &quot;b2801b5dc58b15e76d0d3295b04d295c&quot;&#125;<br>即：<br><br>import requests<br>url = &#x27;http://localhost:9515/session/b2801b5dc58b15e76d0d3295b04d295c/element&#x27;<br>pars = &#123;&quot;using&quot;: &quot;css selector&quot;, &quot;value&quot;: &quot;.postTitle a&quot;, &quot;sessionId&quot;: &quot;b2801b5dc58b15e76d0d3295b04d295c&quot;&#125;<br>r = requests.post(url,json=pars)<br>print(r.json())<br>如何操作元素：类似click()<br><br>请求方式 ：POST<br>请求地址 ：http://localhost:9515/session/:sessionId/element/:id/click<br><br>注意：上述地址中的 &quot;:sessionId&quot;<br>要用启动浏览器的请求返回结果中的sessionId的值<br>:id 要用元素定位请求后返回ELEMENT的值<br><br>例如：我刚刚发送请求，启动浏览器，返回结果中&quot;sessionId&quot;: &quot;b2801b5dc58b15e76d0d3295b04d295c&quot;  <br>元素定位,返回ELEMENT的值&quot;0.11402119390850629-1&quot;<br><br>然后我构造 点击页面元素的请求地址<br>请求地址：http://localhost:9515/session/b2801b5dc58b15e76d0d3295b04d295c/element/0.11402119390850629-1/click<br><br>请求body ：&#123;&quot;id&quot;: &quot;0.11402119390850629-1&quot;, &quot;sessionId&quot;: &quot;b2801b5dc58b15e76d0d3295b04d295c&quot;&#125;<br>即：<br><br>import requests<br>url = &#x27;http://localhost:9515/session/b2801b5dc58b15e76d0d3295b04d295c/element/0.11402119390850629-1/click&#x27;<br>pars =&#123;&quot;id&quot;: &quot;0.5930642995574296-1&quot;, &quot;sessionId&quot;: &quot;b2801b5dc58b15e76d0d3295b04d295c&quot;&#125;<br>r = requests.post(url,json=pars)<br>print(r.json())<br>从上面可以看出来，UI自动化，其实也可以写成API自动化。<br>只是，只是<br>好繁琐，没有封装好的wedriver指令好用，有点脱裤子放屁的感觉。<br>我们来写段代码感觉一下：<br><br>import requests<br>import time<br><br>capabilities = &#123;<br>    &quot;capabilities&quot;: &#123;<br>        &quot;alwaysMatch&quot;: &#123;<br>            &quot;browserName&quot;: &quot;chrome&quot;<br>        &#125;,<br>        &quot;firstMatch&quot;: [<br>            &#123;&#125;<br>        ]<br>    &#125;,<br>    &quot;desiredCapabilities&quot;: &#123;<br>        &quot;platform&quot;: &quot;ANY&quot;,<br>        &quot;browserName&quot;: &quot;chrome&quot;,<br>        &quot;version&quot;: &quot;&quot;,<br>        &quot;chromeOptions&quot;: &#123;<br>            &quot;args&quot;: [],<br>            &quot;extensions&quot;: []<br>        &#125;<br>    &#125;<br>&#125;<br><br># 打开浏览器 http://127.0.0.1:9515/session<br>res = requests.post(&#x27;http://127.0.0.1:9515/session&#x27;, json=capabilities).json()<br>session_id = res[&#x27;sessionId&#x27;]<br><br># 打开百度<br>requests.post(&#x27;http://127.0.0.1:9515/session/%s/url&#x27; % session_id,<br>              json=&#123;&quot;url&quot;: &quot;http://www.baidu.com&quot;, &quot;sessionId&quot;: session_id&#125;)<br><br>time.sleep(3)<br><br># 关闭浏览器，删除session<br>requests.delete(&#x27;http://127.0.0.1:9515/session/%s&#x27; % session_id, json=&#123;&quot;sessionId&quot;: session_id&#125;)<br>其实搞懂真正的原理，也就是为了方便解决问题，在debug的时候，更方便的查看和解决问题。<br><br>当然，如果在接口自动化里面也需要调用少量的UI自动化，可以考虑这种方式。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>容器化</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>selenium</tag>
      
      <tag>Chrom-Headless</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>inint与 new 方法</title>
    <link href="/2019/11/20/init%20%E4%B8%8E%20new%20%E6%96%B9%E6%B3%95/"/>
    <url>/2019/11/20/init%20%E4%B8%8E%20new%20%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="init-与-new-方法"><a href="#init-与-new-方法" class="headerlink" title="__init__与 __new__ 方法"></a><code>__init__</code>与 <code>__new__</code> 方法</h2><h3 id="new-和-init-参数的不同"><a href="#new-和-init-参数的不同" class="headerlink" title="__new__和__init__参数的不同"></a><code>__new__</code>和<code>__init__</code>参数的不同</h3><p><code>__new__</code>所接收的第一个参数是<code>cls</code>，而<code>__init__</code>所接收的第一个参数是<code>self</code>。这是因为当我们调用<code>__new__</code>的时候，该类的实例还并不存在（也就是<code>self</code>所引用的对象还不存在），所以需要接收一个类作为参数，从而产生一个实例。而当我们调用<code>__init__</code>的时候，实例已经存在，因此<code>__init__</code>接受<code>self</code>作为第一个参数并对该实例进行必要的初始化操作。这也意味着<code>__init__</code>是在<code>__new__</code>之后被调用的。</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">newStyleClass</span>(<span class="hljs-title class_ inherited__">object</span>): <br>    <span class="hljs-comment"># In Python2, we need to specify the object as the base.</span><br>    <span class="hljs-comment"># In Python3 it&#x27;s default.</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;__new__ is called&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(newStyleClass, cls).__new__(cls)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;__init__ is called&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;self is: &quot;</span>, self)<br><br>n=newStyleClass()<br><span class="hljs-built_in">print</span>(n)<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">__new__ <span class="hljs-keyword">is</span> called<br>__init__ <span class="hljs-keyword">is</span> called<br>self <span class="hljs-keyword">is</span>: &lt;__main__.newStyleClass <span class="hljs-keyword">at</span> <span class="hljs-number">0</span>x109290890&gt;<br>&lt;__main__.newStyleClass <span class="hljs-keyword">at</span> <span class="hljs-number">0</span>x109290890&gt;<br></code></pre></td></tr></table></figure><p>创建类实例并初始化的过程中<code>__new__</code>和<code>__init__</code>被调用的顺序也能从上面代码的输出结果中看出：<code>__new__</code>函数首先被调用，构造了一个<code>newStyleClass</code>的实例，接着<code>__init__</code>函数在<code>__new__</code>函数返回一个实例的时候被调用，并且这个实例作为<code>self</code>参数被传入了<code>__init__</code>函数。****</p><p>这里需要注意的是，如果<code>__new__</code>函数返回一个已经存在的实例（不论是哪个类的），<code>__init__</code>不会被调用。如下面代码所示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">obj = <span class="hljs-number">12</span> <br># obj can be an <span class="hljs-keyword">object</span> from any <span class="hljs-keyword">class</span>, even <span class="hljs-keyword">object</span>.<span class="hljs-constructor">__new__(<span class="hljs-params">object</span>)</span><br><br><span class="hljs-keyword">class</span> return<span class="hljs-constructor">ExistedObj(<span class="hljs-params">object</span>)</span>:<br>    def <span class="hljs-constructor">__new__(<span class="hljs-params">cls</span>)</span>:<br>        print(<span class="hljs-string">&quot;__new__ is called&quot;</span>)<br>        return obj<br><br>    def <span class="hljs-constructor">__init(<span class="hljs-params">self</span>)</span>:<br>        print(<span class="hljs-string">&quot;__init__ is called&quot;</span>)<br><br>r=return<span class="hljs-constructor">ExistedObj()</span><br>print(r)<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">__new__ <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span><br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>同时另一个需要注意的点是：</p><p>如果我们在<code>__new__</code>函数中不返回任何对象，则<code>__init__</code>函数也不会被调用。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">notReturnObj</span>(<span class="hljs-symbol">object</span>):<br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">__new__</span>(<span class="hljs-symbol">cls</span>):<br>        <span class="hljs-symbol">print</span>(&quot;<span class="hljs-symbol">__new__</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">called</span>&quot;)<br><br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">__init__</span>(<span class="hljs-symbol">self</span>):<br>        <span class="hljs-symbol">print</span>(&quot;<span class="hljs-symbol">__init__</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">called</span>&quot;)<br><br><span class="hljs-symbol">print</span>(<span class="hljs-symbol">notReturnObj</span>())<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">__new__ <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span><br><span class="hljs-keyword">None</span><br></code></pre></td></tr></table></figure><p>可见如果<code>__new__</code>函数不返回对象的话，不会有任何对象被创建，<code>__init__</code>函数也不会被调用来初始化对象，<code>__new__</code>返回 None</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>__init__</code>不能有返回值</li><li><code>__new__</code>函数直接上可以返回别的类的实例。如上面例子中的<code>returnExistedObj</code>类的<code>__new__</code>函数返回了一个<code>int</code>值。</li><li>只有在<code>__new__</code>返回一个新创建属于该类的实例时当前类的<code>__init__</code>才会被调用.</li><li>![image-20191120105155474](&#x2F;Users&#x2F;zhangweijie&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20191120105155474.png)</li></ol>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>标准库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JWT 简介</title>
    <link href="/2019/11/09/JWT%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2019/11/09/JWT%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JWT（JSON-Web-Token）入门教程"><a href="#JWT（JSON-Web-Token）入门教程" class="headerlink" title="JWT（JSON Web Token）入门教程"></a>JWT（JSON Web Token）入门教程</h1><h2 id="1、跨域认证问题"><a href="#1、跨域认证问题" class="headerlink" title="1、跨域认证问题"></a>1、跨域认证问题</h2><p>互联网服务离不开用户认证。一般流程是下面这样。</p><blockquote><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p><p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p></blockquote><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><h3 id="1-1-传统的session-问题"><a href="#1-1-传统的session-问题" class="headerlink" title="1.1 传统的session 问题"></a>1.1 传统的session 问题</h3><p> 我们知道，http 协议本身是一种无状态协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次发起请求的时候用户还是需要再次进行用户认证才可以，因为根据 http 协议我们并不知道是哪个用户发出的请求，所以为了让我们的应用能够识别是哪个用户发起的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应的时候传递给浏览器，告诉其保存为 cookies，以便下次请求时发送给我们的应用。这样我们的应用就可以识别请求来自哪个用户，这就是传统的基于 session 的认证。</p><p>但是这种基于 session 的认证是应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这个时候基于 session 认证应用的问题就会暴露出来。</p><h3 id="1-2-基于-session-认证所显露的问题"><a href="#1-2-基于-session-认证所显露的问题" class="headerlink" title="1.2 基于 session 认证所显露的问题"></a>1.2 基于 session 认证所显露的问题</h3><ul><li><p>session：每个用户经过我们的应用认证之后，都需要在服务端进行记录，以方便用户下次请求的鉴别。通常而言session 都是保存在内存总的，而随着认证用户的增多，服务端的开销会明显增大。</p></li><li><p>扩展性：用户认证以后，服务端做认证记录，如果认证记录被保存在内存中，这意味着用户下次请求还必须要在这台服务器上，这样才能拿到授权的资源。而这样的方式在分布式应用上就会相应的限制了负载均衡的能力，也就意味着限制了应用的扩展能力。</p></li><li><p>CSRF：因为是基于cookies 进行用户识别的，cookies 如果被截获了，用户很容易受到跨站请求伪造的攻击。</p></li></ul><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h2 id="2、JWT-原理"><a href="#2、JWT-原理" class="headerlink" title="2、JWT 原理"></a>2、JWT 原理</h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-string">&quot;姓名&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-string">&quot;角色&quot;</span>: <span class="hljs-string">&quot;管理员&quot;</span>,<br>  <span class="hljs-string">&quot;到期时间&quot;</span>: <span class="hljs-string">&quot;2018年7月1日0点0分&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h2 id="3、JWT-数据结构"><a href="#3、JWT-数据结构" class="headerlink" title="3、JWT 数据结构"></a>3、JWT 数据结构</h2><p>实际的 JWT 的数据结构</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072304.jpg" alt="bg2018072304"></p><p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分：</p><blockquote><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072303.jpg" alt="bg2018072303"></p><h3 id="3-1-Header"><a href="#3-1-Header" class="headerlink" title="3.1 Header"></a>3.1 Header</h3><p>Header部分是一个 JSON对象，描述 JWT 元数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><h3 id="3-2-Payload"><a href="#3-2-Payload" class="headerlink" title="3.2 Payload"></a>3.2 Payload</h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><blockquote><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></blockquote><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-string">&quot;sub&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span>,<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>  <span class="hljs-string">&quot;admin&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h3 id="3-3-Signature"><a href="#3-3-Signature" class="headerlink" title="3.3 Signature"></a>3.3 Signature</h3><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">HMACSHA256</span>(<br>  <span class="hljs-title function_">base64UrlEncode</span>(header) + <span class="hljs-string">&quot;.&quot;</span> +<br>  <span class="hljs-title function_">base64UrlEncode</span>(payload),<br>  secret)<br></code></pre></td></tr></table></figure></blockquote><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p><h3 id="3-4-Base64URL"><a href="#3-4-Base64URL" class="headerlink" title="3.4 Base64URL"></a>3.4 Base64URL</h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com&#x2F;?token&#x3D;xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h3 id="3-5-生成过程"><a href="#3-5-生成过程" class="headerlink" title="3.5 生成过程"></a>3.5 生成过程</h3><p>头信息指定了该JWT使用的签名算法:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">header</span> = &#x27;&#123;<span class="hljs-string">&quot;alg&quot;</span>:<span class="hljs-string">&quot;HS256&quot;</span>,<span class="hljs-string">&quot;typ&quot;</span>:<span class="hljs-string">&quot;JWT&quot;</span>&#125;&#x27;<br></code></pre></td></tr></table></figure><p><code>HS256</code> 表示使用了 HMAC-SHA256 来生成签名。</p><p>消息体包含了JWT的意图：</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scilab">payload = <span class="hljs-string">&#x27;&#123;&quot;</span>loggedInAs<span class="hljs-string">&quot;:&quot;</span>admin<span class="hljs-string">&quot;,&quot;</span>iat<span class="hljs-string">&quot;:1422779638&#125;&#x27;</span><span class="hljs-comment">//iat表示令牌生成的时间</span><br></code></pre></td></tr></table></figure><p>未签名的令牌由<code>base64url</code>编码的头信息和消息体拼接而成（使用”.”分隔），签名则通过私有的key计算而成：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">key</span> = <span class="hljs-string">&#x27;secretkey&#x27;</span>  <br><span class="hljs-attr">unsignedToken</span> = encodeBase64(header) + <span class="hljs-string">&#x27;.&#x27;</span> + encodeBase64(payload)  <br><span class="hljs-attr">signature</span> = HMAC-SHA256(key, unsignedToken)<br></code></pre></td></tr></table></figure><p>最后在未签名的令牌尾部拼接上<code>base64url</code>编码的签名（同样使用”.”分隔）就是JWT了：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">token = encode<span class="hljs-constructor">Base64(<span class="hljs-params">header</span>)</span> + <span class="hljs-character">&#x27;.&#x27;</span> + encode<span class="hljs-constructor">Base64(<span class="hljs-params">payload</span>)</span> + <span class="hljs-character">&#x27;.&#x27;</span> + encode<span class="hljs-constructor">Base64(<span class="hljs-params">signature</span>)</span> <br><br># token看起来像这样: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsb2dnZWRJbkFzIjoiYWRtaW4iLCJpYXQiOjE0MjI3Nzk2Mzh9.gzSraSYS8EXBxLN_oWnFSRgCzcmJmMjLiuyu5CSpyHI<br></code></pre></td></tr></table></figure><p>JWT常常被用作保护服务端的资源（resource），客户端通常将JWT通过HTTP的<code>Authorization</code> header发送给服务端，服务端使用自己保存的key计算、验证签名以判断该JWT是否可信：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">Authorization: Bearer eyJhbGci*<span class="hljs-string">...</span>&lt;snip&gt;<span class="hljs-string">...</span>*yu5CSpyHI<br></code></pre></td></tr></table></figure><h2 id="4、JWT-的使用方式"><a href="#4、JWT-的使用方式" class="headerlink" title="4、JWT 的使用方式"></a>4、JWT 的使用方式</h2><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Authorization</span>: <span class="hljs-title class_">Bearer</span> &lt;token&gt;<br></code></pre></td></tr></table></figure></blockquote><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h2 id="5、JWT的几个特点"><a href="#5、JWT的几个特点" class="headerlink" title="5、JWT的几个特点"></a>5、JWT的几个特点</h2><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>]]></content>
    
    
    <categories>
      
      <category>认证授权</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JWT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务与日志级别</title>
    <link href="/2019/11/08/%E6%9C%8D%E5%8A%A1%E4%B8%8E%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB/"/>
    <url>/2019/11/08/%E6%9C%8D%E5%8A%A1%E4%B8%8E%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="服务与日志级别"><a href="#服务与日志级别" class="headerlink" title="服务与日志级别"></a>服务与日志级别</h2><h3 id="常见情况分类"><a href="#常见情况分类" class="headerlink" title="常见情况分类"></a>常见情况分类</h3><table><thead><tr><th align="center">服务器状态</th><th align="center">状态码</th><th align="center">日志级别</th><th align="center">推送系统</th></tr></thead><tbody><tr><td align="center">请求成功</td><td align="center">200、201、204</td><td align="center">INFO</td><td align="center">ELK</td></tr><tr><td align="center">请求参数错误</td><td align="center">400</td><td align="center">WARNING</td><td align="center">ELK</td></tr><tr><td align="center">用户未登录</td><td align="center">401</td><td align="center">WARNING</td><td align="center">ELK</td></tr><tr><td align="center">用户无权限</td><td align="center">403</td><td align="center">WARNING</td><td align="center">ELK</td></tr><tr><td align="center">资源未找到</td><td align="center">404</td><td align="center">WARNING</td><td align="center">ELK</td></tr><tr><td align="center">请求方法错误</td><td align="center">405</td><td align="center">WARNING</td><td align="center">ELK</td></tr><tr><td align="center">请求参数解析错误</td><td align="center">422</td><td align="center">WARNING</td><td align="center">ELK</td></tr><tr><td align="center">服务器内部错误</td><td align="center">500</td><td align="center">CRITICAL</td><td align="center">ELK\SENTRY</td></tr><tr><td align="center">数据库操作错误</td><td align="center">500</td><td align="center">CRITICAL</td><td align="center">ELK\SENTRY</td></tr><tr><td align="center">调用接口错误</td><td align="center">500</td><td align="center">ERROR</td><td align="center">ELK\SENTRY</td></tr><tr><td align="center">CELERY内部错误</td><td align="center"></td><td align="center">ERROR\CRITICAL</td><td align="center">ELK\SENTRY</td></tr><tr><td align="center">资源冲突</td><td align="center">409</td><td align="center">WARNING</td><td align="center">ELK</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aiohttp 模块详解</title>
    <link href="/2019/11/06/aiohttp%20%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3.md/"/>
    <url>/2019/11/06/aiohttp%20%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3.md/</url>
    
    <content type="html"><![CDATA[<h2 id="aiohttp-模块详解"><a href="#aiohttp-模块详解" class="headerlink" title="aiohttp 模块详解"></a>aiohttp 模块详解</h2><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a><strong>0. 前言</strong></h3><p>本文翻译自aiohttp的官方文档，如有纰漏，欢迎指出。</p><p>aiohttp分为服务器端和客户端，本文只介绍客户端。</p><p>另外我已经对 aiohttp 和 asyncio进行了封装，可以参考我的 github 地址：</p><p><a href="https://github.com/web-trump/ahttp">https://github.com/web-trump/ahttp</a></p><p>由于上下文的缘故，请求代码必须在一个异步的函数中进行：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>():<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h3 id="1-aiohttp安装"><a href="#1-aiohttp安装" class="headerlink" title="1. aiohttp安装"></a><strong>1. aiohttp安装</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip3 install aiohttp<br></code></pre></td></tr></table></figure><h4 id="1-1-基本请求用法"><a href="#1-1-基本请求用法" class="headerlink" title="1.1. 基本请求用法"></a><strong>1.1. 基本请求用法</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.get(<span class="hljs-string">&#x27;https://github.com&#x27;</span>) <span class="hljs-keyword">as</span> r:<br>    <span class="hljs-keyword">await</span> r.text()<br></code></pre></td></tr></table></figure><p>其中r.text(), 可以在括号中指定解码方式，编码方式，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">await</span> resp.text(encoding=<span class="hljs-string">&#x27;windows-1251&#x27;</span>)<br></code></pre></td></tr></table></figure><p>或者也可以选择不编码，适合读取图像等，是无法编码的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">await</span> resp.read()<br></code></pre></td></tr></table></figure><h3 id="2-发起一个session请求"><a href="#2-发起一个session请求" class="headerlink" title="2.发起一个session请求"></a><strong>2.发起一个session请求</strong></h3><p>首先是导入aiohttp模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiohttp<br></code></pre></td></tr></table></figure><p>然后我们试着获取一个web源码，这里以GitHub的公共Time-line页面为例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>        <span class="hljs-built_in">print</span>(resp.status)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure><p>上面的代码中，我们创建了一个 ClientSession 对象命名为session，然后通过session的get方法得到一个 ClientResponse 对象，命名为resp，get方法中传入了一个必须的参数url，就是要获得源码的http url。至此便通过协程完成了一个异步IO的get请求。</p><p>有get请求当然有post请求，并且post请求也是一个协程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=<span class="hljs-string">b&#x27;data&#x27;</span>)<br></code></pre></td></tr></table></figure><p>用法和get是一样的，区别是post需要一个额外的参数data，即是需要post的数据。</p><p>除了get和post请求外，其他http的操作方法也是一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">session.put(<span class="hljs-string">&#x27;http://httpbin.org/put&#x27;</span>, data=<span class="hljs-string">b&#x27;data&#x27;</span>)<br><br>session.delete(<span class="hljs-string">&#x27;http://httpbin.org/delete&#x27;</span>)<br><br>session.head(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>)<br><br>session.options(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>)<br><br>session.patch(<span class="hljs-string">&#x27;http://httpbin.org/patch&#x27;</span>, data=<span class="hljs-string">b&#x27;data&#x27;</span>)<br></code></pre></td></tr></table></figure><p>小记：</p><p>不要为每次的连接都创建一次session,一般情况下只需要创建一个session，然后使用这个session执行所有的请求。</p><p>每个session对象，内部包含了一个连接池，并且将会保持连接和连接复用（默认开启）可以加快整体的性能。</p><h3 id="3-在URL中传递参数"><a href="#3-在URL中传递参数" class="headerlink" title="3.在URL中传递参数"></a><strong>3.在URL中传递参数</strong></h3><p>我们经常需要通过 get 在url中传递一些参数，参数将会作为url问号后面的一部分发给服务器。在aiohttp的请求中，允许以dict的形式来表示问号后的参数。举个例子，如果你想传递 key1&#x3D;value1  key2&#x3D;value2 到 httpbin.org&#x2F;get 你可以使用下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">params = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>, params=params) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-keyword">assert</span> resp.url == <span class="hljs-string">&#x27;http://httpbin.org/get?key2=value2&amp;key1=value1&#x27;</span><br></code></pre></td></tr></table></figure><p>可以看到，代码正确的执行了，说明参数被正确的传递了进去。不管是一个参数两个参数，还是更多的参数，都可以通过这种方式来传递。除了这种方式之外，还有另外一个，使用一个 list 来传递（这种方式可以传递一些特殊的参数，例如下面两个key是相等的也可以正确传递）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">params = [(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>), (<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>)]<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>, params=params) <span class="hljs-keyword">as</span> r:<br>    <span class="hljs-keyword">assert</span> r.url == <span class="hljs-string">&#x27;http://httpbin.org/get?key=value2&amp;key=value1&#x27;</span><br></code></pre></td></tr></table></figure><p>除了上面两种，我们也可以直接通过传递字符串作为参数来传递，但是需要注意，通过字符串传递的特殊字符不会被编码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>, params=<span class="hljs-string">&#x27;key=value+1&#x27;</span>) <span class="hljs-keyword">as</span> r:<br>    <span class="hljs-keyword">assert</span> r.url == <span class="hljs-string">&#x27;http://httpbin.org/get?key=value+1&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="4-响应的内容"><a href="#4-响应的内容" class="headerlink" title="4.响应的内容"></a>4.响应的内容</h3><p>还是以GitHub的公共Time-line页面为例，我们可以获得页面响应的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure><p>运行之后，会打印出类似于如下的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;[&#123;&quot;created_at&quot;:&quot;2015-06-12T14:06:22Z&quot;,&quot;public&quot;:true,&quot;actor&quot;:&#123;...</span><br></code></pre></td></tr></table></figure><p>resp的text方法，会自动将服务器端返回的内容进行解码–decode，当然我们也可以自定义编码方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">await</span> resp.text(encoding=<span class="hljs-string">&#x27;gb2312&#x27;</span>)<br></code></pre></td></tr></table></figure><p>除了text方法可以返回解码后的内容外，我们也可以得到类型是字节的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.read())<br></code></pre></td></tr></table></figure><p>运行的结果是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">b&#x27;[&#123;&quot;created_at&quot;:&quot;2015-06-12T14:06:22Z&quot;,&quot;public&quot;:true,&quot;actor&quot;:&#123;...</span><br></code></pre></td></tr></table></figure><p>gzip和deflate转换编码已经为你自动解码。</p><p>小记：</p><p>text(),read()方法是把整个响应体读入内存，如果你是获取大量的数据，请考虑使用”字节流“（streaming response）</p><h3 id="5-特殊响应内容：json"><a href="#5-特殊响应内容：json" class="headerlink" title="5.特殊响应内容：json"></a><strong>5.特殊响应内容：json</strong></h3><p>如果我们获取的页面的响应内容是json，aiohttp内置了更好的方法来处理json:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.json())<br></code></pre></td></tr></table></figure><p>如果因为某种原因而导致resp.json()解析json失败，例如返回不是json字符串等等，那么resp.json()将抛出一个错误，也可以给json()方法指定一个解码方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.json(encoding=<span class="hljs-string">&#x27;gb2312&#x27;</span>))<br></code></pre></td></tr></table></figure><p>或者传递一个函数进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.json(<span class="hljs-keyword">lambda</span>(x:x.replace(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>))))<br></code></pre></td></tr></table></figure><h3 id="6-以字节流的方式读取响应内容"><a href="#6-以字节流的方式读取响应内容" class="headerlink" title="6.以字节流的方式读取响应内容"></a>6.以字节流的方式读取响应内容</h3><p>虽然json(),text(),read()很方便的能把响应的数据读入到内存，但是我们仍然应该谨慎的使用它们，因为它们是把整个的响应体全部读入了内存。即使你只是想下载几个字节大小的文件，但这些方法却将在内存中加载所有的数据。所以我们可以通过控制字节数来控制读入内存的响应内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-keyword">await</span> resp.content.read(<span class="hljs-number">10</span>) <span class="hljs-comment">#读取前10个字节</span><br></code></pre></td></tr></table></figure><p>一般地，我们应该使用以下的模式来把读取的字节流保存到文件中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fd:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        chunk = <span class="hljs-keyword">await</span> resp.content.read(chunk_size)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> chunk:<br>            <span class="hljs-keyword">break</span><br>        fd.write(chunk)<br></code></pre></td></tr></table></figure><h3 id="7-自定义请求头"><a href="#7-自定义请求头" class="headerlink" title="7.自定义请求头"></a><strong>7.自定义请求头</strong></h3><p>如果你想添加请求头，可以像get添加参数那样以dict的形式，作为get或者post的参数进行请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>url = <span class="hljs-string">&#x27;https://api.github.com/some/endpoint&#x27;</span><br>payload = &#123;<span class="hljs-string">&#x27;some&#x27;</span>: <span class="hljs-string">&#x27;data&#x27;</span>&#125;<br>headers = &#123;<span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;<br><span class="hljs-keyword">await</span> session.post(url, data=json.dumps(payload), headers=headers)<br></code></pre></td></tr></table></figure><h3 id="8-自定义Cookie"><a href="#8-自定义Cookie" class="headerlink" title="8.自定义Cookie"></a>8.自定义Cookie</h3><p>给服务器发送cookie，可以通过给 ClientSession 传递一个cookie参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://httpbin.org/cookies&#x27;</span><br>cookies = &#123;<span class="hljs-string">&#x27;cookies_are&#x27;</span>: <span class="hljs-string">&#x27;working&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> ClientSession(cookies=cookies) <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> resp:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">await</span> resp.json() == &#123;<span class="hljs-string">&quot;cookies&quot;</span>: &#123;<span class="hljs-string">&quot;cookies_are&quot;</span>: <span class="hljs-string">&quot;working&quot;</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p>可直接访问链接 “httpbin.org&#x2F;cookies”查看当前cookie，访问session中的cookie请见第10节。</p><h3 id="9-post数据的几种方式"><a href="#9-post数据的几种方式" class="headerlink" title="9.post数据的几种方式"></a><strong>9.post数据的几种方式</strong></h3><h4 id="（1）模拟表单post数据"><a href="#（1）模拟表单post数据" class="headerlink" title="（1）模拟表单post数据"></a>（1）模拟表单post数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=payload) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure><p>注意：data&#x3D;dict的方式post的数据将被转码，和form提交数据是一样的作用，如果你不想被转码，可以直接以字符串的形式 <strong>data&#x3D;str</strong> 提交，这样就不会被转码。</p><h4 id="（2）post-json"><a href="#（2）post-json" class="headerlink" title="（2）post json"></a>（2）post json</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>url = <span class="hljs-string">&#x27;https://api.github.com/some/endpoint&#x27;</span><br>payload = &#123;<span class="hljs-string">&#x27;some&#x27;</span>: <span class="hljs-string">&#x27;data&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(url, data=json.dumps(payload)) <span class="hljs-keyword">as</span> resp:<br>    ...<br></code></pre></td></tr></table></figure><p>其实json.dumps(payload)返回的也是一个字符串，只不过这个字符串可以被识别为json格式</p><h4 id="（3）post-小文件"><a href="#（3）post-小文件" class="headerlink" title="（3）post 小文件"></a>（3）post 小文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span><br>files = &#123;<span class="hljs-string">&#x27;file&#x27;</span>: <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;report.xls&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)&#125;<br><span class="hljs-keyword">await</span> session.post(url, data=files)<br></code></pre></td></tr></table></figure><p>可以设置好文件名和content-type:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span><br>data = FormData()<br>data.add_field(<span class="hljs-string">&#x27;file&#x27;</span>, <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;report.xls&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>), filename=<span class="hljs-string">&#x27;report.xls&#x27;</span>,<br>                content_type=<span class="hljs-string">&#x27;application/vnd.ms-excel&#x27;</span>)<br><span class="hljs-keyword">await</span> session.post(url, data=data)<br></code></pre></td></tr></table></figure><p>如果将文件对象设置为数据参数，aiohttp将自动以字节流的形式发送给服务器。</p><h4 id="（4）post-大文件"><a href="#（4）post-大文件" class="headerlink" title="（4）post 大文件"></a>（4）post 大文件</h4><p>aiohttp支持多种类型的文件以流媒体的形式上传，所以我们可以在文件未读入内存的情况下发送大文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@aiohttp.streamer</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">file_sender</span>(<span class="hljs-params">writer, file_name=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        chunk = f.read(<span class="hljs-number">2</span>**<span class="hljs-number">16</span>)<br>        <span class="hljs-keyword">while</span> chunk:<br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> writer.write(chunk)<br>            chunk = f.read(<span class="hljs-number">2</span>**<span class="hljs-number">16</span>)<br><span class="hljs-comment"># Then you can use `file_sender` as a data provider:</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=file_sender(file_name=<span class="hljs-string">&#x27;huge_file&#x27;</span>)) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure><p>同时我们可以从一个url获取文件后，直接post给另一个url，并计算hash值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">feed_stream</span>(<span class="hljs-params">resp, stream</span>):<br>    h = hashlib.sha256()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        chunk = <span class="hljs-keyword">await</span> resp.content.readany()<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> chunk:<br>            <span class="hljs-keyword">break</span><br>        h.update(chunk)<br>        stream.feed_data(chunk)<br>    <span class="hljs-keyword">return</span> h.hexdigest()<br>resp = session.get(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>)<br>stream = StreamReader()<br>loop.create_task(session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=stream))<br>file_hash = <span class="hljs-keyword">await</span> feed_stream(resp, stream)<br></code></pre></td></tr></table></figure><p>因为响应内容类型是StreamReader，所以可以把get和post连接起来，同时进行post和get：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">r = <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;http://python.org&#x27;</span>)<br><br><span class="hljs-keyword">await</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=r.content)<br></code></pre></td></tr></table></figure><h4 id="（5）post预压缩数据"><a href="#（5）post预压缩数据" class="headerlink" title="（5）post预压缩数据"></a>（5）post预压缩数据</h4><p>在通过aiohttp发送前就已经压缩的数据, 调用压缩函数的函数名（通常是deflate 或 zlib）作为content-encoding的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_coroutine</span>(<span class="hljs-params">session, headers, my_data</span>):<br>    data = zlib.compress(my_data)<br>    headers = &#123;<span class="hljs-string">&#x27;Content-Encoding&#x27;</span>: <span class="hljs-string">&#x27;deflate&#x27;</span>&#125;<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, data=data, headers=headers)<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>10.keep-alive, 连接池，共享cookie</p><p>ClientSession 用于在多个连接之间共享cookie：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/cookies/set?my_cookie=my_value&#x27;</span>)<br>    filtered = session.cookie_jar.filter_cookies(<span class="hljs-string">&#x27;http://httpbin.org&#x27;</span>)<br>    <span class="hljs-keyword">assert</span> filtered[<span class="hljs-string">&#x27;my_cookie&#x27;</span>].value == <span class="hljs-string">&#x27;my_value&#x27;</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/cookies&#x27;</span>) <span class="hljs-keyword">as</span> r:<br>        json_body = <span class="hljs-keyword">await</span> r.json()<br>        <span class="hljs-keyword">assert</span> json_body[<span class="hljs-string">&#x27;cookies&#x27;</span>][<span class="hljs-string">&#x27;my_cookie&#x27;</span>] == <span class="hljs-string">&#x27;my_value&#x27;</span><br></code></pre></td></tr></table></figure><p>也可以为所有的连接设置共同的请求头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession(<br>    headers=&#123;<span class="hljs-string">&quot;Authorization&quot;</span>: <span class="hljs-string">&quot;Basic bG9naW46cGFzcw==&quot;</span>&#125;) <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&quot;http://httpbin.org/headers&quot;</span>) <span class="hljs-keyword">as</span> r:<br>        json_body = <span class="hljs-keyword">await</span> r.json()<br>        <span class="hljs-keyword">assert</span> json_body[<span class="hljs-string">&#x27;headers&#x27;</span>][<span class="hljs-string">&#x27;Authorization&#x27;</span>] == <span class="hljs-string">&#x27;Basic bG9naW46cGFzcw==&#x27;</span><br></code></pre></td></tr></table></figure><p>ClientSession 还支持 keep-alive连接和连接池(connection pooling)</p><h3 id="11-cookie安全性"><a href="#11-cookie安全性" class="headerlink" title="11.cookie安全性"></a><strong>11.cookie安全性</strong></h3><p>默认ClientSession使用的是严格模式的 aiohttp.CookieJar. RFC 2109，明确的禁止接受url和ip地址产生的cookie，只能接受 DNS 解析IP产生的cookie。可以通过设置aiohttp.CookieJar 的 unsafe&#x3D;True 来配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">jar = aiohttp.CookieJar(unsafe=<span class="hljs-literal">True</span>)<br>session = aiohttp.ClientSession(cookie_jar=jar)<br></code></pre></td></tr></table></figure><h3 id="12-控制同时连接的数量（连接池）"><a href="#12-控制同时连接的数量（连接池）" class="headerlink" title="12.控制同时连接的数量（连接池）"></a>12.控制同时连接的数量（连接池）</h3><p>也可以理解为同时请求的数量，为了限制同时打开的连接数量，我们可以将限制参数传递给连接器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conn = aiohttp.TCPConnector(limit=<span class="hljs-number">30</span>) <span class="hljs-comment"># 同时最大进行连接的连接数为30，默认是100，limit=0的时候是无限制</span><br></code></pre></td></tr></table></figure><p>限制同时打开限制同时打开连接到同一端点的数量（(host, port, is_ssl) 三的倍数），可以通过设置 limit_per_host 参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conn = aiohttp.TCPConnector(limit_per_host=<span class="hljs-number">30</span>) <span class="hljs-comment"># 默认是0</span><br></code></pre></td></tr></table></figure><h3 id="13-自定义域名解析"><a href="#13-自定义域名解析" class="headerlink" title="13.自定义域名解析"></a>13.自定义域名解析</h3><p>我们可以指定域名服务器的 IP 对我们提供的get或post的url进行解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> aiohttp.resolver <span class="hljs-keyword">import</span> AsyncResolver<br>resolver = AsyncResolver(nameservers=[<span class="hljs-string">&quot;8.8.8.8&quot;</span>, <span class="hljs-string">&quot;8.8.4.4&quot;</span>])<br>conn = aiohttp.TCPConnector(resolver=resolver)<br></code></pre></td></tr></table></figure><h3 id="14-设置代理"><a href="#14-设置代理" class="headerlink" title="14.设置代理"></a><strong>14.设置代理</strong></h3><p>aiohttp支持使用代理来访问网页：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&quot;http://python.org&quot;</span>, proxy=<span class="hljs-string">&quot;http://some.proxy.com&quot;</span>) <span class="hljs-keyword">as</span> resp:<br>        <span class="hljs-built_in">print</span>(resp.status)<br></code></pre></td></tr></table></figure><p>当然也支持需要授权的页面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    proxy_auth = aiohttp.BasicAuth(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;pass&#x27;</span>)<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&quot;http://python.org&quot;</span>, proxy=<span class="hljs-string">&quot;http://some.proxy.com&quot;</span>, proxy_auth=proxy_auth) <span class="hljs-keyword">as</span> resp:<br>        <span class="hljs-built_in">print</span>(resp.status)<br></code></pre></td></tr></table></figure><p>或者通过这种方式来验证授权：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">session.get(<span class="hljs-string">&quot;http://python.org&quot;</span>, proxy=<span class="hljs-string">&quot;http://user:pass@some.proxy.com&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="15-响应状态码-response-status-code"><a href="#15-响应状态码-response-status-code" class="headerlink" title="15.响应状态码 response status code"></a>15.响应状态码 response status code</h3><p>可以通过 resp.status来检查状态码是不是200：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-keyword">assert</span> resp.status == <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h3 id="16-响应头"><a href="#16-响应头" class="headerlink" title="16.响应头"></a>16.响应头</h3><p>我们可以直接使用　resp.headers 来查看响应头，得到的值类型是一个dict：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>resp.headers<br>&#123;<span class="hljs-string">&#x27;ACCESS-CONTROL-ALLOW-ORIGIN&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br> <span class="hljs-string">&#x27;CONTENT-TYPE&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br> <span class="hljs-string">&#x27;DATE&#x27;</span>: <span class="hljs-string">&#x27;Tue, 15 Jul 2014 16:49:51 GMT&#x27;</span>,<br> <span class="hljs-string">&#x27;SERVER&#x27;</span>: <span class="hljs-string">&#x27;gunicorn/18.0&#x27;</span>,<br> <span class="hljs-string">&#x27;CONTENT-LENGTH&#x27;</span>: <span class="hljs-string">&#x27;331&#x27;</span>,<br> <span class="hljs-string">&#x27;CONNECTION&#x27;</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>或者我们可以查看原生的响应头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>resp.raw_headers<br>((<span class="hljs-string">b&#x27;SERVER&#x27;</span>, <span class="hljs-string">b&#x27;nginx&#x27;</span>),<br> (<span class="hljs-string">b&#x27;DATE&#x27;</span>, <span class="hljs-string">b&#x27;Sat, 09 Jan 2016 20:28:40 GMT&#x27;</span>),<br> (<span class="hljs-string">b&#x27;CONTENT-TYPE&#x27;</span>, <span class="hljs-string">b&#x27;text/html; charset=utf-8&#x27;</span>),<br> (<span class="hljs-string">b&#x27;CONTENT-LENGTH&#x27;</span>, <span class="hljs-string">b&#x27;12150&#x27;</span>),<br> (<span class="hljs-string">b&#x27;CONNECTION&#x27;</span>, <span class="hljs-string">b&#x27;keep-alive&#x27;</span>))<br></code></pre></td></tr></table></figure><h3 id="17-查看cookie"><a href="#17-查看cookie" class="headerlink" title="17.查看cookie"></a>17.查看cookie</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://example.com/some/cookie/setting/url&#x27;</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(resp.cookies)<br></code></pre></td></tr></table></figure><h3 id="18-重定向的响应头"><a href="#18-重定向的响应头" class="headerlink" title="18.重定向的响应头"></a><strong>18.重定向的响应头</strong></h3><p>如果一个请求被重定向了，我们依然可以查看被重定向之前的响应头信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>resp = <span class="hljs-keyword">await</span> session.get(<span class="hljs-string">&#x27;http://example.com/some/redirect/&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>resp<br>&lt;ClientResponse(http://example.com/some/other/url/) [<span class="hljs-number">200</span>]&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>resp.history<br>(&lt;ClientResponse(http://example.com/some/redirect/) [<span class="hljs-number">301</span>]&gt;,)<br></code></pre></td></tr></table></figure><h3 id="19-超时处理"><a href="#19-超时处理" class="headerlink" title="19.超时处理"></a>19.超时处理</h3><p>默认的IO操作都有<strong>5分钟的响应时间</strong> 我们可以通过 timeout 进行重写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;https://github.com&#x27;</span>, timeout=<span class="hljs-number">60</span>) <span class="hljs-keyword">as</span> r:<br>    ...<br></code></pre></td></tr></table></figure><p>如果 timeout&#x3D;None 或者 timeout&#x3D;0 将不进行超时检查，也就是不限时长</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aiohttp</tag>
      
      <tag>标准库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OAuth 简介</title>
    <link href="/2019/11/05/OAuth%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2019/11/05/OAuth%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="OAuth-简介"><a href="#OAuth-简介" class="headerlink" title="OAuth 简介"></a>OAuth 简介</h2><h3 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h3><p>​        OAuth2 是一个授权框架或者说是授权标准，它可以使第三方应用程序或者客户端获得对 HTTP服务上（例如 Google，GitHub 等）用户账户信息的有限访问权限。OAuth2 通过将用户身份验证委派给托管用户账户的服务以及授权客户端访问用户账户进行工作。综上，OAuth2 可以为 web 应用和桌面应用以及移动应用提供授权流程。</p><h3 id="2、角色"><a href="#2、角色" class="headerlink" title="2、角色"></a>2、角色</h3><p>​        首先介绍 OAuth2 协议中的角色，整个授权协议的流程都是围绕着这些角色：</p><ul><li><p>resource owner：资源所有者，能够允许访问瘦保护资源的实体，如果是个人则被称为 end-user</p></li><li><p>resource server：资源服务器，托管受保护资源的服务器</p></li><li><p>client：客户端，使用资源所有者的授权代表资源所有者发起对受保护资源的请求的应用程序。例如 web 应用及移动程序等</p></li><li><p>authorization server：授权服务器，能够向客户端颁发令牌</p></li><li><p>user-agent：用户代理，帮助资源所有者与客户端沟通的工具，一般为 web 浏览器、移动 APP 等</p></li></ul><p>举例说明：</p><p>我想在 CSDN网站看到一篇文章想进行评论和留言，但是评论的时候发现必须要登录以后才能留言。此时有两个选项，第一是在 CSDN注册一个新的账号然后登录去留言，第二是使用 GitHub 的账号登录然后评论留言。如果我们现在选择使用 GitHub 登录那么 OAuth2 的认证流程就开始了。此时 CSDN 相对于 GitHub 就是一个客户端，而我们使用的浏览器就是一个用户代理。当从 GitHub 授权服务器获得 token 后，CSDN 需要请求 GitHub 的张哈票信息，请求的地址就是 GitHub 的资源服务器</p><h3 id="3、授权流程"><a href="#3、授权流程" class="headerlink" title="3、授权流程"></a>3、授权流程</h3><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081120366.png" alt="img"></p><ol><li>Authrization Request<br>客户端向用户请求对资源服务器的<code>authorization grant</code>。</li><li>Authorization Grant（Get）<br>如果用户授权该次请求，客户端将收到一个<code>authorization grant</code>。</li><li>Authorization Grant（Post）<br>客户端向授权服务器发送它自己的客户端身份标识和上一步中的<code>authorization grant</code>，请求访问令牌。</li><li>Access Token（Get）<br>如果客户端身份被认证，并且<code>authorization grant</code>也被验证通过，授权服务器将为客户端派发<code>access token</code>。授权阶段至此全部结束。</li><li>Access Token（Post &amp;&amp; Validate）<br>客户端向资源服务器发送<code>access token</code>用于验证并请求资源信息。</li><li>Protected Resource（Get）<br>如果<code>access token</code>验证通过，资源服务器将向客户端返回资源信息。</li></ol><h3 id="4、客户端应用注册"><a href="#4、客户端应用注册" class="headerlink" title="4、客户端应用注册"></a>4、客户端应用注册</h3><p>在应用 OAuth 2 之前，你必须在授权方服务中注册你的应用。如 <a href="https://developers.google.com/identity/">Google Identity Platform</a> 或者 <a href="https://developer.github.com/apps/building-oauth-apps/creating-an-oauth-app/">Github OAuth Setting</a>，诸如此类 OAuth 实现平台中一般都要求开发者提供如下所示的授权设置项。</p><ul><li>应用名称</li><li>应用网站</li><li>重定向URI或回调URL</li></ul><p>重定向URI是授权方服务在用户授权（或拒绝）应用程序之后重定向供用户访问的地址，因此也是用于处理授权码或访问令牌的应用程序的一部分。</p><h4 id="4-1-Client-ID-和-Client-Secret"><a href="#4-1-Client-ID-和-Client-Secret" class="headerlink" title="4.1 Client ID 和 Client Secret"></a>4.1 Client ID 和 Client Secret</h4><p>一旦你的应用注册成功，授权方服务将以<code>client id</code>和<code>client secret</code>的形式为应用发布<code>client credentials</code>（客户端凭证）。<code>client id</code>是公开透明的字符串，授权方服务使用该字符串来标识应用程序，并且还用于构建呈现给用户的授权 url 。当应用请求访问用户的帐户时，<code>client secret</code>用于验证应用身份，并且必须在客户端和服务之间保持私有性。</p><h3 id="5、授权许可（Authorization-Grant）"><a href="#5、授权许可（Authorization-Grant）" class="headerlink" title="5、授权许可（Authorization Grant）"></a>5、授权许可（Authorization Grant）</h3><p>如上文的抽象授权流程图所示，前四个阶段包含了获取<code>authorization grant</code>和<code>access token</code>的动作。授权许可类型取决于应用请求授权的方式和授权方服务支持的 Grant Type。OAuth 2 定义了四种 Grant Type，每一种都有适用的应用场景。</p><ul><li>Authorization Code<br>结合普通服务器端应用使用。</li><li>Implicit<br>结合移动应用或 Web App 使用。</li><li>Resource Owner Password Credentials<br>适用于受信任客户端应用，例如同个组织的内部或外部应用。</li><li>Client Credentials<br>适用于客户端调用主服务API型应用（比如百度API Store）</li></ul><p>以下将分别介绍这四种许可类型的相关授权流程。</p><h4 id="5-1-授权码模式（Authorization-Code-Flow）"><a href="#5-1-授权码模式（Authorization-Code-Flow）" class="headerlink" title="5.1 授权码模式（Authorization Code Flow）"></a>5.1 授权码模式（Authorization Code Flow）</h4><p><code>Authorization Code</code> 是最常使用的一种授权许可类型，它适用于第三方应用类型为<code>server-side</code>型应用的场景。<code>Authorization Code</code>授权流程基于重定向跳转，客户端必须能够与<code>User-agent</code>（即用户的 Web 浏览器）交互并接收通过<code>User-agent</code>路由发送的实际<code>authorization code</code>值。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081121073.png" alt="img"></p><h4 id="1-User-Authorization-Request"><a href="#1-User-Authorization-Request" class="headerlink" title="1. User Authorization Request"></a>1. User Authorization Request</h4><p>首先，客户端构造了一个用于请求<code>authorization code</code>的URL并引导<code>User-agent</code>跳转访问。</p><figure class="highlight dts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//authorization-server.com/auth</span><br> ?response_<span class="hljs-attr">type</span><span class="hljs-operator">=</span>code<br> <span class="hljs-variable">&amp;client_id</span>=<span class="hljs-number">29352915982374239857</span><br> <span class="hljs-variable">&amp;redirect_uri</span>=https%<span class="hljs-number">3</span>A%<span class="hljs-number">2F</span>%<span class="hljs-number">2F</span>example-client.com%<span class="hljs-number">2F</span>callback<br> <span class="hljs-variable">&amp;scope</span>=create+delete<br> <span class="hljs-variable">&amp;state</span>=xcoiv98y2kd22vusuye3kch<br></code></pre></td></tr></table></figure><ul><li>response_type&#x3D;code<br>此参数和参数值用于提示授权服务器当前客户端正在进行<code>Authorization Code</code>授权流程。</li><li>client_id<br>客户端身份标识。</li><li>redirect_uri<br>标识授权服务器接收客户端请求后返回给<code>User-agent</code>的跳转访问地址。</li><li>scope<br>指定客户端请求的访问级别。</li><li>state<br>由客户端生成的随机字符串，步骤2中用户进行授权客户端的请求时也会携带此字符串用于比较，这是为了防止<code>CSRF</code>攻击。</li></ul><h4 id="2-User-Authorizes-Applcation"><a href="#2-User-Authorizes-Applcation" class="headerlink" title="2. User Authorizes Applcation"></a>2. User Authorizes Applcation</h4><p>当用户点击上文中的示例链接时，用户必须已经在授权服务中进行登录（否则将会跳转到登录界面，<strong>不过 OAuth 2 并不关心认证过程</strong>），然后授权服务会提示用户授权或拒绝应用程序访问其帐户。以下是授权应用程序的示例：</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081121100.png" alt="img"></p><h4 id="3-Authorization-Code-Grant"><a href="#3-Authorization-Code-Grant" class="headerlink" title="3. Authorization Code Grant"></a>3. Authorization Code Grant</h4><p>如果用户确认授权，授权服务器将重定向<code>User-agent</code>至之前客户端提供的指向客户端的<code>redirect_uri</code>地址，并附带<code>code</code>和<code>state</code>参数（由之前客户端提供），于是客户端便能直接读取到<code>authorization code</code>值。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">https://example-client.com/redirect<br> ?code=g0ZGZmNjVmOWIjNTk2NTk4ZTYyZGI3<br> &amp;<span class="hljs-keyword">state</span>=xcoiv98y2kd22vusuye3kch<br></code></pre></td></tr></table></figure><p><code>state</code>值将与客户端在请求中最初设置的值相同。客户端将检查重定向中的状态值是否与最初设置的状态值相匹配。这可以防止CSRF和其他相关攻击。</p><p><code>code</code>是授权服务器生成的<code>authorization code</code>值。<code>code</code>相对较短，通常持续1到10分钟，具体取决于授权服务器设置。</p><h4 id="4-Access-Token-Request"><a href="#4-Access-Token-Request" class="headerlink" title="4. Access Token Request"></a>4. Access Token Request</h4><p>现在客户端已经拥有了服务器派发的<code>authorization code</code>，接下来便可以使用<code>authorization code</code>和其他参数向服务器请求<code>access token</code>（POST方式）。其他相关参数如下：</p><ul><li>grant_type&#x3D;authorization_code - 这告诉服务器当前客户端正在使用<code>Authorization Code</code>授权流程。</li><li>code - 应用程序包含它在重定向中给出的授权码。</li><li>redirect_uri - 与请求<code>authorization code</code>时使用的<code>redirect_uri</code>相同。某些资源（API）不需要此参数。</li><li>client_id - 客户端标识。</li><li>client_secret - 应用程序的客户端密钥。这确保了获取<code>access token</code>的请求只能从客户端发出，而不能从可能截获<code>authorization code</code>的攻击者发出。</li></ul><h4 id="5-Access-Token-Grant"><a href="#5-Access-Token-Grant" class="headerlink" title="5. Access Token Grant"></a>5. Access Token Grant</h4><p>服务器将会验证第4步中的请求参数，当验证通过后（校验<code>authorization code</code>是否过期，<code>client id</code>和<code>client secret</code>是否匹配等），服务器将向客户端返回<code>access token</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;MTQ0NjJkZmQ5OTM2NDE1ZTZjNGZmZjI3&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bearer&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">3600</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;IwOGYzYTlmM2YxOTQ5MGE3YmNmMDFkNTVk&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;create delete&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>至此，授权流程全部结束。直到<code>access token</code> 过期或失效之前，客户端可以通过资源服务器API访问用户的帐户，并具备<code>scope</code>中给定的操作权限。</p><h4 id="5-2-Implicit-Flow"><a href="#5-2-Implicit-Flow" class="headerlink" title="5.2 Implicit Flow"></a>5.2 Implicit Flow</h4><p><code>Implicit</code>授权流程和<code>Authorization Code</code>基于重定向跳转的授权流程十分相似，但它适用于移动应用和 Web App，这些应用与普通服务器端应用相比有个特点，即<code>client secret</code>不能有效保存和信任。</p><p>相比<code>Authorization Code</code>授权流程，<code>Implicit</code>去除了请求和获得<code>authorization code</code>的过程，而用户点击授权后，授权服务器也会直接把<code>access token</code>放在<code>redirect_uri</code>中发送给<code>User-agent</code>（浏览器）。 同时第1步构造请求用户授权 url 中的<code>response_type</code>参数值也由 <em>code</em> 更改为 <em>token</em> 或 <em>id_token</em> 。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081122114.png" alt="img"></p><h4 id="1-User-Authorization-Request-1"><a href="#1-User-Authorization-Request-1" class="headerlink" title="1. User Authorization Request"></a>1. User Authorization Request</h4><p>客户端构造的URL如下所示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://&#123;yourOktaDomain&#125;.com/oauth2/default/v1/authorize?client_id=<span class="hljs-number">0</span>oabv6kx4qq6<br><span class="hljs-attribute">h1U5l0h7</span>&amp;response_type=token&amp;redirect_uri=http%<span class="hljs-number">3</span>A%<span class="hljs-number">2</span>F%<span class="hljs-number">2</span>Flocalhost%<span class="hljs-number">3</span><br><span class="hljs-attribute">A8080</span>&amp;state=state-<span class="hljs-number">296</span>bc9a0-a2a2-<span class="hljs-number">4</span>a57-be1a-d0e2fd9bb601&amp;nonce=foo&#x27;<br></code></pre></td></tr></table></figure><p><em>response_type</em>的<code>response_type</code>参数值为 <em>token</em> 或 <em>id_token</em> 。其他请求参数与<code>Authorization Code</code>授权流程相比没有并什么变化。</p><h4 id="2-User-Authorizes-Application（略）"><a href="#2-User-Authorizes-Application（略）" class="headerlink" title="2. User Authorizes Application（略）"></a>2. User Authorizes Application（略）</h4><h4 id="3-Redirect-URI-With-Access-Token-In-Fragment"><a href="#3-Redirect-URI-With-Access-Token-In-Fragment" class="headerlink" title="3. Redirect URI With Access Token In Fragment"></a>3. Redirect URI With Access Token In Fragment</h4><p>假设用户授予访问权限，授权服务器将<code>User-agent</code>（浏览器） 重定向回客户端使用之前提供的<code>redirect_uri</code>。并在 uri 的 #fragment 部分添加<code>access_token</code>键值对。如下所示：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://localhost:8080/#access_token=eyJhb</span>[<span class="hljs-string">...</span>]<span class="hljs-link">erw&amp;token_type=Bearer&amp;expires_in=3600&amp;scope=openid&amp;state=state-296bc9a0-a2a2-4a57-be1a-d0e2fd9bb601</span><br></code></pre></td></tr></table></figure><ul><li>token_type - 当且仅当<code>response_type</code>设置为 <em>token</em> 时返回，值恒为 <em>Bearer</em>。</li></ul><blockquote><p>注意在<code>Implicit</code>流程中，<code>access_token</code>值放在了 URI 的 #fragment 部分，而不是作为 ?query 参数。</p></blockquote><h4 id="4-User-agent-Follows-the-Redirect-URI"><a href="#4-User-agent-Follows-the-Redirect-URI" class="headerlink" title="4. User-agent Follows the Redirect URI"></a>4. User-agent Follows the Redirect URI</h4><p><code>User-agent</code>（浏览器）遵循重定向指令，请求<code>redirect_uri</code>标识的客户端地址，<strong>并在本地保留 uri 的 #fragment 部分的<code>access_token</code>信息</strong>。</p><h4 id="5-Application-Sends-Access-Token-Extraction-Script"><a href="#5-Application-Sends-Access-Token-Extraction-Script" class="headerlink" title="5. Application Sends Access Token Extraction Script"></a>5. Application Sends Access Token Extraction Script</h4><p>客户端生成一个包含 token 解构脚本的 Html 页面，这个页面被发送给<code>User-agent</code>（浏览器），执行脚本解构完整的<code>redirect_uri</code>并提取其中的<code>access_token</code>（<code>access token</code>信息在第4步中已经被<code>User-agent</code>保存）。</p><h4 id="6-Access-Token-Passed-to-Application"><a href="#6-Access-Token-Passed-to-Application" class="headerlink" title="6. Access Token Passed to Application"></a>6. Access Token Passed to Application</h4><p><code>User-agent</code>（浏览器）向客户端发送解构提取的<code>access token</code>。</p><p>至此，授权流程全部结束。直到<code>access token</code> 过期或失效之前，客户端可以通过资源服务器API访问用户的帐户，并具备<code>scope</code>中给定的操作权限。</p><h4 id="5-3-Resource-Owner-Password-Credentials-Flow"><a href="#5-3-Resource-Owner-Password-Credentials-Flow" class="headerlink" title="5.3 Resource Owner Password Credentials Flow"></a>5.3 Resource Owner Password Credentials Flow</h4><p><code>Resource Owner Password Credentials</code>授权流程适用于用户与客户端具有信任关系的情况，例如设备操作系统或同一组织的内部及外部应用。用户与应用交互表现形式往往体现为客户端能够直接获取用户凭据（用户名和密码，通常使用交互表单）。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081122619.png" alt="img"></p><h4 id="1-Resource-Owner-Password-Credentials-From-User-Input"><a href="#1-Resource-Owner-Password-Credentials-From-User-Input" class="headerlink" title="1. Resource Owner Password Credentials From User Input"></a>1. Resource Owner Password Credentials From User Input</h4><p>用户向客户端提供用户名与密码作为授权凭据。</p><h4 id="2-Resource-Owner-Password-Credentials-From-Client-To-Server"><a href="#2-Resource-Owner-Password-Credentials-From-Client-To-Server" class="headerlink" title="2. Resource Owner Password Credentials From Client To Server"></a>2. Resource Owner Password Credentials From Client To Server</h4><p>客户端向授权服务器发送用户输入的授权凭据以请求 <code>access token</code>。客户端必须已经在服务器端进行注册。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/token</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>server.example.com<br><span class="hljs-attribute">Authorization</span><span class="hljs-punctuation">: </span>Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><br><span class="language-dts">grant_<span class="hljs-attr">type</span><span class="hljs-operator">=</span>password<span class="hljs-variable">&amp;username</span>=johndoe<span class="hljs-variable">&amp;password</span>=A3ddj3w</span><br></code></pre></td></tr></table></figure><ul><li>grant_type - 必选项，值恒为 <em>password</em></li></ul><h4 id="3-Access-Token-Passed-to-Application"><a href="#3-Access-Token-Passed-to-Application" class="headerlink" title="3. Access Token Passed to Application"></a>3. Access Token Passed to Application</h4><p>授权服务器对客户端进行认证并检验用户凭据的合法性，如果检验通过，将向客户端派发 <code>access token</code>&gt;</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2YotnFZFEjr1zCsicMWpAA&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;example&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">3600</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;example_parameter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;example_value&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="5-4-Client-Credentials-Flow"><a href="#5-4-Client-Credentials-Flow" class="headerlink" title="5.4 Client Credentials Flow"></a>5.4 Client Credentials Flow</h4><p><code>Client Credential</code>是最简单的一种授权流程。客户端可以直接使用它的<code>client credentials</code>或其他有效认证信息向授权服务器发起获取<code>access token</code>的请求。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081122939.png" alt="img"></p><p>两步中的请求体和返回体分别如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/token</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>server.example.com<br><span class="hljs-attribute">Authorization</span><span class="hljs-punctuation">: </span>Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><br><span class="language-ini"><span class="hljs-attr">grant_type</span>=client_credentials</span><br></code></pre></td></tr></table></figure><ul><li>grant_type - 必选项，值恒为 <em>client_credentials</em></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>       <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2YotnFZFEjr1zCsicMWpAA&quot;</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;example&quot;</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">3600</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-attr">&quot;example_parameter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;example_value&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>首先我们需要明确的是，即使用户刚登录过 GitHub，CSDN 也不可能向 GitHub 随便发一个请求就能拿到访客信息，这显然是不安全的。就算用户允许你获取他在 GitHub 上的信息，但是 GitHub 为了保护用户的信息安全，也不会让你随意获取。所以在操作之前，CSDN 与 GitHub 之间需要有一个协商。</p><p>####3.1 网站和 GitHub 之间的协商</p><p>GitHub 会对用户的权限进行分类，比如读取仓库信息的权限，写入仓库的权限，读取用户信息的权限，修改用户信息的权限等。如果我想获取用户的信息，GitHub 会要求我现在他的平台上注册一个应用，在申请的时候标明需要获取用户的哪些权限，用多少就申请多少，并且在申请的时候填写你的网站域名，GitHub 只会允许在这个域名中获取用户信息。</p><p>此时 CSDN 已经和 GitHub 之间达成了共识，GitHub 也会发给 CSDN 两张门票，一张是clientID，另一张是clientSecrect</p><h4 id="3-2-用户与-GitHub-之间的协商"><a href="#3-2-用户与-GitHub-之间的协商" class="headerlink" title="3.2 用户与 GitHub 之间的协商"></a>3.2 用户与 GitHub 之间的协商</h4><p>用户进入网站后，点击 GitHub 登录按钮的时候，CSDN 会将第一步拿到的 clientID 交给用户，让他进入到 GitHub 的授权页面，GitHub 看到用户手中的 clientID 会知道CSDN 是被允许获取信息的，于是 GitHub 将 CSDN 想要获取的权限罗列出来，并询问用户是否允许 CSDN 获取这些权限</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 用户登录 github，协商<br>GET https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/login/</span>oauth/authorize<br><br><span class="hljs-regexp">//</span> 协商凭证<br>params = &#123;<br>  client_id: <span class="hljs-string">&quot;xxxx&quot;</span>,<br>  redirect_uri: <span class="hljs-string">&quot;http://my-website.com&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果用户觉得 CSDN 网站想要的权限太多了，或者用户压根就不想让 CSDN 获取信息，选择了拒绝的话，整个 OAuth2的认证就结束了，认证也以失败告终。如果用户觉得 OK 的话，在授权页面点击确认授权后，页面就会跳转到我预先设定的’redirect_url’并附带一个盖了章的门票 code</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 协商成功后带着盖了章的 code<br>Location: http:<span class="hljs-regexp">//my</span>-website.com?code=xxx<br></code></pre></td></tr></table></figure><p>这个时候用户和 GitHub 之间的协商也就完成了，GitHub 会在自己的系统中记录此次协商，标识该用户已经允许在GitHub 进行访问、操作和使用关于用户的部分资源</p><h4 id="3-3-告诉-GitHub，CSDN-要来拜访了"><a href="#3-3-告诉-GitHub，CSDN-要来拜访了" class="headerlink" title="3.3 告诉 GitHub，CSDN 要来拜访了"></a>3.3 告诉 GitHub，CSDN 要来拜访了</h4><p>在第二步中，CSDN 已经拿到了盖过章的门票code，但是这个 code 只能表明，用户允许 CSDN 从 GitHub 上获取用户的数据，如果我直接拿这个 code 去 GitHub 访问数据一定会被拒绝，因为任何人都可以持有 code，GitHub 不知道 code 持有方就是 CSDN</p><p>还记得之前申请应用的时候 GitHub给的两张门票，clientID 已经使用过了，接下来就轮到 clientSecrect</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 网站和 github 之间的协商<br>POST https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/login/</span>oauth/access_token<br><br><span class="hljs-regexp">//</span> 协商凭证包括 github 给用户盖的章和 github 发给我的门票<br>params = &#123;<br>  code: <span class="hljs-string">&quot;xxx&quot;</span>,<br>  client_id: <span class="hljs-string">&quot;xxx&quot;</span>,<br>  client_secret: <span class="hljs-string">&quot;xxx&quot;</span>,<br>  redirect_uri: <span class="hljs-string">&quot;http://my-website.com&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>拿着用户盖过章的 code 和能够标识个人身份的 clientID、clientSecrect 去拜访 GitHub，拿到最后的绿卡 access_token</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// 拿到最后的绿卡</span><br><span class="hljs-attr">response</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  access_token:</span> <span class="hljs-string">&quot;e72e16c7e42f292c6912e7710c838347ae178b4a&quot;</span><br><span class="hljs-symbol">  scope:</span> <span class="hljs-string">&quot;user,gist&quot;</span><br><span class="hljs-symbol">  token_type:</span> <span class="hljs-string">&quot;bearer&quot;</span>,<br><span class="hljs-symbol">  refresh_token:</span> <span class="hljs-string">&quot;xxxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-4-用户使用-GitHub-在-CSDN-留言"><a href="#3-4-用户使用-GitHub-在-CSDN-留言" class="headerlink" title="3.4 用户使用 GitHub 在 CSDN 留言"></a>3.4 用户使用 GitHub 在 CSDN 留言</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 访问用户数据<br>GET https:<span class="hljs-regexp">//</span>api.github.com/user<br>?access_token=e72e16c7e42f292c6912e7710c838347ae178b4a<br></code></pre></td></tr></table></figure><p>上一步 github 已经把最后的绿卡 access_token 给我了，通过 github 提供的 API 加绿卡就能够访问用户的信息了，能获取用户的哪些权限在 response 中也给了明确的说明，scope 为 user 和 gist，也就是只能获取 user 组和 gist 组两个小组的权限，user 组中就包含了用户的名字和邮箱等信息了。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// 告诉我用户的名字和邮箱</span><br><span class="hljs-attr">response</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  username:</span> <span class="hljs-string">&quot;barretlee&quot;</span>,<br><span class="hljs-symbol">  email:</span> <span class="hljs-string">&quot;barret.china@gmail.com&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>值得一看的文章：</p><p><a href="https://learnku.com/articles/20082">https://learnku.com/articles/20082</a></p><p><a href="https://learnku.com/articles/20031">https://learnku.com/articles/20031</a></p>]]></content>
    
    
    <categories>
      
      <category>认证授权</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OAuth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集中日志处理</title>
    <link href="/2019/10/24/%E9%9B%86%E4%B8%AD%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86/"/>
    <url>/2019/10/24/%E9%9B%86%E4%B8%AD%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="一、logging-模块"><a href="#一、logging-模块" class="headerlink" title="一、logging 模块"></a>一、logging 模块</h3><p>logging模块是Python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、日志保存路径、日志文件回滚等；相比print，具备如下优点：</p><ol><li>可以通过设置不同的日志等级，在release版本中只输出重要信息，而不必显示大量的调试信息；</li><li>print将所有信息都输出到标准输出中，严重影响开发者从标准输出中查看其它数据；logging则可以由开发者决定将信息输出到什么地方，以及怎么输出；</li></ol><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span><span class="hljs-selector-class">.Logger</span>     记录器：暴露了应用程序代码能直接使用的接口。<br><span class="hljs-number">2</span><span class="hljs-selector-class">.Handler</span>    处理器：将（记录器产生的）日志记录发送至合适的目的地。<br><span class="hljs-number">3</span><span class="hljs-selector-class">.Filter</span>     过滤器：提供了更好的粒度控制，它可以决定输出哪些日志记录。<br><span class="hljs-number">4</span><span class="hljs-selector-class">.Formatter</span>  格式化器：指明了最终输出中日志记录的布局。<br></code></pre></td></tr></table></figure><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202203022140562.png" alt="image-20220302214003021"></p><ul><li>1）（在用户代码中进行）日志记录函数调用，如：logger.info(…)，logger.debug(…)等；</li><li>2）判断要记录的日志级别是否满足日志器设置的级别要求（要记录的日志级别要大于或等于日志器设置的级别才算满足要求），如果不满足则该日志记录会被丢弃并终止后续的操作，如果满足则继续下一步操作；</li><li>3）根据日志记录函数调用时掺入的参数，创建一个日志记录（LogRecord类）对象；</li><li>4）判断日志记录器上设置的过滤器是否拒绝这条日志记录，如果日志记录器上的某个过滤器拒绝，则该日志记录会被丢弃并终止后续的操作，如果日志记录器上设置的过滤器不拒绝这条日志记录或者日志记录器上没有设置过滤器则继续下一步操作–将日志记录分别交给该日志器上添加的各个处理器；</li><li>5）判断要记录的日志级别是否满足处理器设置的级别要求（要记录的日志级别要大于或等于该处理器设置的日志级别才算满足要求），如果不满足记录将会被该处理器丢弃并终止后续的操作，如果满足则继续下一步操作；</li><li>6）判断该处理器上设置的过滤器是否拒绝这条日志记录，如果该处理器上的某个过滤器拒绝，则该日志记录会被当前处理器丢弃并终止后续的操作，如果当前处理器上设置的过滤器不拒绝这条日志记录或当前处理器上没有设置过滤器测继续下一步操作；</li><li>7）如果能到这一步，说明这条日志记录经过了层层关卡允许被输出了，此时当前处理器会根据自身被设置的格式器（如果没有设置则使用默认格式）将这条日志记录进行格式化，最后将格式化后的结果输出到指定位置（文件、网络、类文件的Stream等）；</li><li>8）如果日志器被设置了多个处理器的话，上面的第5-8步会执行多次；</li><li>9）这里才是完整流程的最后一步：判断该日志器输出的日志消息是否需要传递给上一级logger（之前提到过，日志器是有层级关系的）的处理器，如果propagate属性值为1则表示日志消息将会被输出到处理器指定的位置，同时还会被传递给parent日志器的handlers进行处理直到当前日志器的propagate属性为0停止，如果propagate值为0则表示不向parent日志器的handlers传递该消息，到此结束。</li></ul><p>可见，一条日志信息要想被最终输出需要依次经过以下几次过滤：</p><ul><li><p>日志器等级过滤；</p></li><li><p>日志器的过滤器过滤；</p></li><li><p>日志器的处理器等级过滤；</p></li><li><p>日志器的处理器的过滤器过滤；</p></li><li><p>&#96;&#96;&#96;</p><h1 id="services-x2F-bs-whatweb-x2F-gunicorn-logging-conf"><a href="#services-x2F-bs-whatweb-x2F-gunicorn-logging-conf" class="headerlink" title="services&#x2F;bs-whatweb&#x2F;gunicorn_logging.conf"></a>services&#x2F;bs-whatweb&#x2F;gunicorn_logging.conf</h1><p>[loggers]<br>keys &#x3D; root</p><p>[handlers]<br>keys &#x3D; access</p><p>[formatters]<br>keys &#x3D; generic</p><p>[handler_access]<br>class &#x3D; StreamHandler<br>formatter &#x3D; generic<br>args &#x3D; (sys.stdout,)</p><p>[formatter_generic]<br>format &#x3D; [whatweb][%(levelname)s] [%(name)s]: %(message)s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>  <br><br><span class="hljs-section">### 二、gunicorn</span><br><br><span class="hljs-bullet">1.</span> 简单介绍<br><br>   Gunicorn“绿色独角兽”是一个被广泛使用的高性能的Python WSGI UNIX HTTP服务器，移植自Ruby的独角兽（Unicorn ）项目,使用pre-fork worker模式，具有使用非常简单，轻量级的资源消耗，以及高性能等特点。<br><br><span class="hljs-bullet">2.</span> 特点<br><br><span class="hljs-bullet">   -</span> 采用epoll (Linux下) 非阻塞网络I/O 模型<br><br><span class="hljs-bullet">   -</span> 自动化worker进程管理<br><br><span class="hljs-bullet">   -</span> 简单的Python配置<br><br><span class="hljs-bullet">   -</span> 多种Worker类型可以选择 同步的，基于事件的（gevent tornado等），基于多线程的<br><br><span class="hljs-bullet">   -</span> 各种服务器钩子，扩展性极强<br><span class="hljs-bullet">   -</span> 支持 Python 2.x &gt;= 2.6 or Python 3.x &gt;= 3.2<br><br>   服务模型(Server Model)<br><br>   Gunicorn是基于 pre-fork 模型的。也就意味着有一个中心管理进程( master process )用来管理 worker 进程集合。Master从不知道任何关于客户端的信息。所有的请求和响应处理都是由 worker 进程来处理的。<br><br>   Master(管理者)<br><br>   主程序是一个简单的循环,监听各种信号以及相应的响应进程。master管理着正在运行的worker集合,通过监听各种信号比如TTIN, TTOU, and CHLD. TTIN and TTOU响应的增加和减少worker的数目。CHLD信号表明一个子进程已经结束了,在这种情况下master会自动的重启失败的worker<br><br></code></pre></td></tr></table></figure></li></ul><h1 id="services-x2F-bs-whatweb-x2F-gunicorn-config-py"><a href="#services-x2F-bs-whatweb-x2F-gunicorn-config-py" class="headerlink" title="services&#x2F;bs-whatweb&#x2F;gunicorn_config.py"></a>services&#x2F;bs-whatweb&#x2F;gunicorn_config.py</h1><p>address &#x3D; “0.0.0.0”<br>port &#x3D; “5000”<br>bind &#x3D; “{0}:{1}”.format(address, port)  # 监听地址及端口<br>backlog &#x3D; 2048  # 服务器在 pending 状态的最大连接数<br>workers &#x3D; 2  # worker 进程数量<br>worker_class &#x3D; ‘gevent’  # worker进程的工作方式，sync, eventlet, gevent, tornado, gthread, 缺省值sync<br>worker_connections &#x3D; 1000  # 客户端最大同时连接数，只适用于 eventlet，gevent工作方式<br>timeout &#x3D; 30  # 最大连接时间<br>keepalive &#x3D; 2  # server 端保持连接时间<br>errorlog &#x3D; ‘-‘  # 错误日志路径<br>loglevel &#x3D; ‘error’  # 日志级别，debug，info，warning，error，critical<br>accesslog &#x3D; ‘-‘  # 访问日志路径<br>access_log_format &#x3D; ‘{“request_address”: “%(h)s”, ‘ <br>                    ‘“request_time”: “%(t)s”, ‘ <br>                    ‘“request”: “%(r)s”, ‘ <br>                    ‘“http_status_code”: “%(s)s”, ‘ <br>                    ‘“http_request_url”: “%(U)s”, ‘ <br>                    ‘“http_query_string”: “%(q)s”, ‘ <br>                    ‘“request_headers”: {‘ <br>                    ‘“content-type”: “%({content-type}i)s”, ‘ <br>                    ‘“content-length”: “%({content-length}i)s”, ‘ <br>                    ‘“user-agent”: “%(a)s”‘ <br>                    ‘}}’</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h1 id="services-x2F-bs-whatweb-x2F-gunicorn-logging-conf-1"><a href="#services-x2F-bs-whatweb-x2F-gunicorn-logging-conf-1" class="headerlink" title="services&#x2F;bs-whatweb&#x2F;gunicorn_logging.conf"></a>services&#x2F;bs-whatweb&#x2F;gunicorn_logging.conf</h1><h1 id="Logging-configuration"><a href="#Logging-configuration" class="headerlink" title="Logging configuration"></a>Logging configuration</h1><p>[loggers]<br>keys &#x3D; root, gunicorn.access, gunicorn.error</p><p>[handlers]<br>keys &#x3D; access, error</p><p>[formatters]<br>keys &#x3D; json, generic</p><h1 id="Root-logger"><a href="#Root-logger" class="headerlink" title="Root logger"></a>Root logger</h1><h1 id="The-root-logger-sends-messages-to-the-console-and-to-Sentry"><a href="#The-root-logger-sends-messages-to-the-console-and-to-Sentry" class="headerlink" title="The root logger sends messages to the console and to Sentry."></a>The root logger sends messages to the console and to Sentry.</h1><p>[logger_root]<br>handlers &#x3D; error</p><h1 id="Gunicorn-loggers"><a href="#Gunicorn-loggers" class="headerlink" title="Gunicorn loggers"></a>Gunicorn loggers</h1><h1 id="Gunicorn-logging-is-configured-with-two-loggers-‘gunicorn-access’-and-‘gunicorn-error’"><a href="#Gunicorn-logging-is-configured-with-two-loggers-‘gunicorn-access’-and-‘gunicorn-error’" class="headerlink" title="Gunicorn logging is configured with two loggers: ‘gunicorn.access’ and ‘gunicorn.error’."></a>Gunicorn logging is configured with two loggers: ‘gunicorn.access’ and ‘gunicorn.error’.</h1><h1 id="The-access-log-is-sent-to-stdout-and-the-error-log-is-sent-to-stderr-both-without-propagation"><a href="#The-access-log-is-sent-to-stdout-and-the-error-log-is-sent-to-stderr-both-without-propagation" class="headerlink" title="The access log is sent to stdout and the error log is sent to stderr, both without propagation."></a>The access log is sent to stdout and the error log is sent to stderr, both without propagation.</h1><h1 id="Only-the-critical-logger-has-a-handler-to-send-messages-to-Sentry"><a href="#Only-the-critical-logger-has-a-handler-to-send-messages-to-Sentry" class="headerlink" title="Only the critical logger has a handler to send messages to Sentry."></a>Only the critical logger has a handler to send messages to Sentry.</h1><p>[logger_gunicorn.access]<br>handlers &#x3D; access<br>qualname &#x3D; gunicorn.access<br>level &#x3D; INFO<br>propagate &#x3D; 0</p><p>[logger_gunicorn.error]<br>handlers &#x3D; error<br>qualname &#x3D; gunicorn.error<br>level &#x3D; ERROR<br>propagate &#x3D; 0</p><h1 id="Handlers"><a href="#Handlers" class="headerlink" title="Handlers"></a>Handlers</h1><p>[handler_access]<br>class &#x3D; StreamHandler<br>formatter &#x3D; json<br>args &#x3D; (sys.stdout,)</p><p>[handler_error]<br>class &#x3D; StreamHandler<br>formatter &#x3D; json<br>args &#x3D; (sys.stderr,)</p><p>[formatter_generic]<br>format &#x3D; [bs-whatweb][%(levelname)s] [%(name)s]: %(message)s<br>[formatter_json]<br>class &#x3D; project.api.utils.logger.JSONFormatter</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><span class="hljs-comment">### 三、ELK</span><br><br><span class="hljs-number">1</span>. 简单介绍<br><br>   [ELK]由Elasticsearch、Logstash和Kibana三部分组件组成；<br><br>   Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。<br><br>   Logstash是一个完全开源的工具，它可以对你的日志进行收集、分析，并将其存储供以后使用<br><br>   kibana 是一个开源和免费的工具，它可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志<br><br>   <br><br><span class="hljs-number">2</span>. 工作流程<br><br>   将服务的日志全部发送到远程 syslog 服务器存储，然后 filebeat 进行读取，在需要收集日志的所有服务上部署logstash，logstash agent 用于监控并过滤收集日志，将过滤后的内容发送到Redis/KAFKA，然后logstash indexer将日志收集在一起交给全文搜索服务ElasticSearch，可以用ElasticSearch进行自定义搜索通过Kibana 来结合自定义搜索进行页面展示。<br><br>   ![image-<span class="hljs-number">20191024180026108</span>](https:<span class="hljs-regexp">//</span>zwj-typora-ipic.oss-cn-beijing.aliyuncs.com<span class="hljs-regexp">/img/</span><span class="hljs-number">202112081054849</span>.png)<br><br>   <br><br></code></pre></td></tr></table></figure><p>bs-whatweb:<br>    image: bs-whatweb:v0.0.2<br>    build:<br>      context: .&#x2F;services&#x2F;bs-whatweb<br>      dockerfile: Dockerfile-staging<br>    volumes:<br>      - ‘.&#x2F;services&#x2F;bs-whatweb:&#x2F;usr&#x2F;src&#x2F;app’<br>    restart: always<br>    ######### 新增 ########<br>    logging:<br>      driver: “syslog”<br>      options:<br>        syslog-address: “tcp:&#x2F;&#x2F;192.168.199.142:514”<br>        tag: whatweb-server-staging<br>    #######################<br>    ports:<br>      - 5007:5000<br>    env_file:<br>      - bs-whatweb-staging.env<br>    networks:<br>      - defnet</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section">#### 四、Sentry</span><br><br><span class="hljs-bullet">1.</span> 基本介绍<br><br>   Sentry 是一个现代化的错误日志记录以及聚合平台。支持几乎所有的主流开发语言及平台，并提供现代化 UI。<br><br>   ![<span class="hljs-string">image-20191017165847184</span>](<span class="hljs-link">https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081054208.png</span>)<br><br>   场景介绍：<br><br>   接入 Sentry 前；<br><br><span class="hljs-bullet">   -</span> 用户A: 发布功能用不了<br><span class="hljs-bullet">   -</span> 开发者A: 哪个页面? 截个图<br><span class="hljs-bullet">   -</span> 用户A: (发截图)<br><span class="hljs-bullet">   -</span> 开发者A发现bug可以重现, 登录服务器查看错误日志, 确认程序逻辑无问题, 查看数据库数据, 发现有脏数据. 联系开发者B检查负责更新数据的python脚本C.py.<br><span class="hljs-bullet">   -</span> 开发者B登录服务器查看错误日志, 发现一个逻辑错误导致脚本罢工, 已持续了一个小时. 影响了数千条数据<br><br>   接入 Sentry 后：<br><br><span class="hljs-bullet">   -</span> 开发者A,B同时收到邮件告警, 一分钟前脚本C.py异常退出.<br><span class="hljs-bullet">   -</span> 开发者B进入sentry后台查看错误信息, 定位问题并将其修复, 再清理受影响的数十条数据.<br><span class="hljs-bullet">   -</span> 在此过程中没有用户受到影响, 无需开发者A介入<br><br><span class="hljs-bullet">2.</span> 基本概念<br><br><span class="hljs-bullet">   -</span> event<br><br><span class="hljs-code">     可操作数据的基本单位，每一次日志输出就会产生一个 event。event并不一定是错误，如果日志级别设置的很低，那么后台就会产生非常多的 event，所以正确的设置日志的级别 非常的重要。</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">   -</span> issue<br><br><span class="hljs-code">     同一类 event 的聚合，某一个错误可能因为重复执行而被记录多次，在 sentry系统会自动聚合到一起，方便处理，通常我们操作的对象也就是 issue。</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">   -</span> DNS<br><br><span class="hljs-code">     DNS 及时客户端密匙，用来进行客户端和服务端的通信。DNS 是一个 URL，包含一个公匙，一个私匙，项目标记及服务器地址（https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7）</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">   -</span> raven<br><br><span class="hljs-code">     整个错误日志监控系统包含客户端和服务端，Sentry 是服务端的名称，客户端名称为 Raven，需要两者配合才能工作</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">3.</span> 项目流程<br><br><span class="hljs-bullet">   -</span> 登录 Sentry 系统<br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081054669.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;image-20191024093908660&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;zoom:50%;&quot;</span> /&gt;</span></span><br><br><span class="hljs-bullet">   -</span> 点击创建项目<br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081054727.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;image-20191024094042431&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;zoom:50%;&quot;</span> /&gt;</span></span><br><br><span class="hljs-bullet">   -</span> 选择框架<br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081055103.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;image-20191024094257179&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;zoom:50%;&quot;</span> /&gt;</span></span><br><br><span class="hljs-bullet">   -</span> 根据指示下载安装包并进行配置<br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081055166.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;image-20191024095325581&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;zoom:50%;&quot;</span> /&gt;</span></span><br><br>   在 flask 中的配置有两种方式，可以自由选择<br><br>   第一种：<br><br></code></pre></td></tr></table></figure><p>   from raven.contrib.flask import Sentry<br>   sentry &#x3D; Sentry()<br>   sentry.init_app(app,dsn&#x3D;”<a href="https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7&quot;,logging=True">https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7&quot;,logging=True</a>, level&#x3D;logging.ERROR)<br>   <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>第二种：<br><br></code></pre></td></tr></table></figure><br>   import sentry_sdk<br>   from sentry_sdk.integrations.flask import FlaskIntegration<br>   sentry_sdk.init(dsn&#x3D;”<a href="https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7&quot;">https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7&quot;</a>,<br>   integrations&#x3D;[FlaskIntegration()])<br>   <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### gunicorn 与 Sentry 结合配置<br><br>使用 yaml 文件进行 logging 配置<br><br></code></pre></td></tr></table></figure></p><h1 id="Logging-configuration-1"><a href="#Logging-configuration-1" class="headerlink" title="Logging configuration"></a>Logging configuration</h1><p>   [loggers]<br>   keys &#x3D; root, gunicorn.access, gunicorn.error</p><p>   [handlers]<br>   keys &#x3D; access, error, sentry</p><p>   [formatters]<br>   keys &#x3D; json, generic</p><h1 id="Root-logger-1"><a href="#Root-logger-1" class="headerlink" title="Root logger"></a>Root logger</h1><h1 id="The-root-logger-sends-messages-to-the-console-and-to-Sentry-1"><a href="#The-root-logger-sends-messages-to-the-console-and-to-Sentry-1" class="headerlink" title="The root logger sends messages to the console and to Sentry."></a>The root logger sends messages to the console and to Sentry.</h1><p>   [logger_root]<br>   handlers &#x3D; error, sentry</p><h1 id="Gunicorn-loggers-1"><a href="#Gunicorn-loggers-1" class="headerlink" title="Gunicorn loggers"></a>Gunicorn loggers</h1><h1 id="Gunicorn-logging-is-configured-with-two-loggers-‘gunicorn-access’-and-‘gunicorn-error’-1"><a href="#Gunicorn-logging-is-configured-with-two-loggers-‘gunicorn-access’-and-‘gunicorn-error’-1" class="headerlink" title="Gunicorn logging is configured with two loggers: ‘gunicorn.access’ and ‘gunicorn.error’."></a>Gunicorn logging is configured with two loggers: ‘gunicorn.access’ and ‘gunicorn.error’.</h1><h1 id="The-access-log-is-sent-to-stdout-and-the-error-log-is-sent-to-stderr-both-without-propagation-1"><a href="#The-access-log-is-sent-to-stdout-and-the-error-log-is-sent-to-stderr-both-without-propagation-1" class="headerlink" title="The access log is sent to stdout and the error log is sent to stderr, both without propagation."></a>The access log is sent to stdout and the error log is sent to stderr, both without propagation.</h1><h1 id="Only-the-critical-logger-has-a-handler-to-send-messages-to-Sentry-1"><a href="#Only-the-critical-logger-has-a-handler-to-send-messages-to-Sentry-1" class="headerlink" title="Only the critical logger has a handler to send messages to Sentry."></a>Only the critical logger has a handler to send messages to Sentry.</h1><p>   [logger_gunicorn.access]<br>   handlers &#x3D; access<br>   qualname &#x3D; gunicorn.access<br>   level &#x3D; INFO<br>   propagate &#x3D; 0</p><p>   [logger_gunicorn.error]<br>   handlers &#x3D; error, sentry<br>   qualname &#x3D; gunicorn.error<br>   level &#x3D; ERROR<br>   propagate &#x3D; 0</p><p>   [handler_access]<br>   class &#x3D; StreamHandler<br>   formatter &#x3D; json<br>   args &#x3D; (sys.stdout,)</p><p>   [handler_error]<br>   class &#x3D; StreamHandler<br>   formatter &#x3D; json<br>   args &#x3D; (sys.stderr,)</p><p>   [handler_sentry]<br>   class &#x3D; raven.handlers.logging.SentryHandler<br>   level &#x3D; CRITICAL<br>   formatter &#x3D; generic<br>   args &#x3D; (“<a href="https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7&quot;">https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7&quot;</a>,)</p><p>   [formatter_generic]<br>   format &#x3D; [bs-whatweb][%(levelname)s] [%(name)s]: %(message)s<br>   [formatter_json]<br>   class &#x3D; project.api.utils.logger.JSONFormatter<br>   &#96;&#96;&#96;</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是日志</title>
    <link href="/2019/10/24/%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A5%E5%BF%97/"/>
    <url>/2019/10/24/%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h3 id="一、什么是日志"><a href="#一、什么是日志" class="headerlink" title="一、什么是日志"></a>一、什么是日志</h3><p>日志用来记录用户操作、系统运行状态等，是一个系统的重要组成部分。然而，由于日志通常不属于系统的核心功能，所以常常不被团队成员所重视。对于一些简单的小程序，可能并不需要在如何记录日志的问题上花费太多精力。但是对于作为基础平台为很多产品提供服务的后端程序，就必须要考虑如何依靠良好的日志来保证系统可靠的运行了。</p><p>好的日志可以帮助系统的开发和运维人员：</p><ol><li>了解线上系统的运行状态</li><li>快速准确定位线上问题</li><li>发现系统瓶颈</li><li>预警系统潜在风险</li><li>挖掘产品最大价值</li></ol><p>不好的日志导致：</p><ol><li>对系统的运行状态一知半解，甚至一无所知</li><li>系统出现问题无法定位，或者需要花费巨大的时间和精力</li><li>无法发现系统瓶颈，不知优化从何做起</li><li>无法基于日志对系统运行过程中的错误和潜在风险进行监控和报警</li><li>对挖掘用户行为和提升产品价值毫无帮助</li></ol><h3 id="二、日志分类"><a href="#二、日志分类" class="headerlink" title="二、日志分类"></a>二、日志分类</h3><p>日志从功能来说，可分为诊断日志、统计日志、审计日志。</p><p>诊断日志， 典型的有：</p><ul><li>请求入口和出口</li><li>外部服务调用和返回</li><li>资源消耗操作: 如读写文件等</li><li>容错行为： 如云硬盘的副本修复操作</li><li>程序异常： 如数据库无法连接</li><li>后台操作：定期执行删除的线程</li><li>启动、关闭、配置加载</li></ul><p>统计日志：</p><ul><li>用户访问统计：用户IP、上传下载的数据量，请求耗时等</li><li>计费日志（如记录用户使用的网络资源或磁盘占用，格式较为严格，便于统计）</li></ul><p>审计日志：</p><ul><li>管理操作</li></ul><p>对于简单的系统，可以将所有的日志输出到同一个日志文件中，并通过不同的关键字进行区分。而对于复杂的系统，将不同需求的日志输出到不同的日志文件中是必要的，通过对不同类型的文件采用不同的日志格式（例如对于计费日志可以直接输出为Json格式），可以方便接入其他的子系统。</p><h3 id="三、日志中记录什么"><a href="#三、日志中记录什么" class="headerlink" title="三、日志中记录什么"></a>三、日志中记录什么</h3><p>理想的日志中应该记录<strong>不多不少</strong>的信息。</p><p>所谓不多，是指不要在日志中记录无用的信息。实践中常见到的无用的日志有：1）能够放在一条日志里的东西，放在多条日志中输出；2）预期会发生且能够被正常处理的异常，打印出一堆无用的堆栈；3）开发人员在开发过程中为了调试方便而加入的“临时”日志</p><p>所谓不少，是指对于日志的使用者，能够从日志中得到所有需要的信息。在实践中经常发生日志不够的情况，例如：1）请求出错时不能通过日志直接来定位问题，而需要开发人员再临时增加日志并要求请求的发送者重新发送同样的请求才能定位问题；2）无法确定服务中的后台任务是否按照期望执行；3）无法确定服务的内存数据结构的状态；4）无法确定服务的异常处理逻辑（如重试）是否正确执行；5）无法确定服务启动时配置是否正确加载；</p><h3 id="四、关于日志级别"><a href="#四、关于日志级别" class="headerlink" title="四、关于日志级别"></a>四、关于日志级别</h3><p>我们通常使用的日志库，将日志基本分为以下几类（从低到高）：<br><strong>TRACE</strong> – The TRACE Level designates finer-grained informational events than the DEBUG<br><strong>DEBUG</strong> – The DEBUG Level designates fine-grained informational events that are most useful to debug an application.<br><strong>INFO</strong> – The INFO level designates informational messages that highlight the progress of the application at coarse-grained level.<br><strong>WARN</strong> – The WARN level designates potentially harmful situations.<br><strong>ERROR</strong> – The ERROR level designates error events that might still allow the application to continue running.<br><strong>CRITICAL</strong> – The FATAL level designates very severe error events that will presumably lead the application to abort.</p><p>开发人员对于何种日志输出为何种级别通常有自己的理解，那在实践中，是否所有的日志级别都有必要存在，哪些操作需要记入日志，哪种错误应该记为WARN级别，而哪种错误又为ERROR级别呢？</p><ul><li>一个项目各个日志级别的定义应该是清楚明确的，需要团队的每个开发人员共同遵守；</li><li>即使是TRACE或者DEBUG级别的日志，也应该有一定的规范，要保证除了开发人员自己以外，包括测试人员和运维人员都可以方便地通过日志定位问题；</li><li>对于日志级别的分类，有以下参考：<br><strong>CIRTICAL</strong> — 表示需要立即被处理的系统级错误。当该错误发生时，表示服务已经出现了某种程度的不可用，系统管理员需要立即介入。这属于最严重的日志级别，因此该日志级别必须慎用，如果这种级别的日志经常出现，则该日志也失去了意义。通常情况下，一个进程的生命周期中应该只记录一次FATAL级别的日志，即该进程遇到无法恢复的错误而退出时。当然，如果某个系统的子系统遇到了不可恢复的错误，那该子系统的调用方也可以记入FATAL级别日志，以便通过日志报警提醒系统管理员修复；<br><strong>ERROR</strong> — 该级别的错误也需要马上被处理，但是紧急程度要低于CRITICAL级别。当ERROR错误发生时，已经影响了用户的正常访问。从该意义上来说，实际上ERROR错误和CRITICAL错误对用户的影响是相当的。CRITICAL相当于服务已经挂了，而ERROR相当于好死不如赖活着，然而活着却无法提供正常的服务，只能不断地打印ERROR日志。特别需要注意的是，ERROR和CRITICAL都属于服务器自己的异常，是需要马上得到人工介入并处理的。而对于用户自己操作不当，如请求参数错误等等，是绝对不应该记为ERROR日志的；<br><strong>WARNING</strong> — 该日志表示系统可能出现问题，也可能没有，这种情况如网络的波动等。对于那些目前还不是错误，然而不及时处理也会变为错误的情况，也可以记为WARN日志，例如一个存储系统的磁盘使用量超过阈值，或者系统中某个用户的存储配额快用完等等。对于WARN级别的日志，虽然不需要系统管理员马上处理，也是需要及时查看并处理的。因此此种级别的日志也不应太多，能不打WARN级别的日志，就尽量不要打；<br><strong>INFO</strong> — 该种日志记录系统的正常运行状态，例如某个子系统的初始化，某个请求的成功执行等等。通过查看INFO级别的日志，可以很快地对系统中出现的 WARN,ERROR,FATAL错误进行定位。INFO日志不宜过多，通常情况下，INFO级别的日志应该不大于TRACE日志的10%；<br><strong>DEBUG</strong> or <strong>TRACE</strong> — 这两种日志具体的规范应该由项目组自己定义，该级别日志的主要作用是对系统每一步的运行状态进行精确的记录。通过该种日志，可以查看某一个操作每一步的执 行过程，可以准确定位是何种操作，何种参数，何种顺序导致了某种错误的发生。可以保证在不重现错误的情况下，也可以通过DEBUG（或TRACE）级别的日志对问题进行诊断。需要注意的是，DEBUG日志也需要规范日志格式，应该保证除了记录日志的开发人员自己外，其他的如运维，测试人员等也可以通过 DEBUG（或TRACE）日志来定位问题；</li></ul>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentry 入门</title>
    <link href="/2019/10/18/Sentry%20%E5%85%A5%E9%97%A8/"/>
    <url>/2019/10/18/Sentry%20%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Sentry-入门"><a href="#Sentry-入门" class="headerlink" title="Sentry 入门"></a>Sentry 入门</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        错误日志监控也可称为业务逻辑监控，旨在对业务系统运行过程中产生的错误日志进行收集收纳和监控告警。Sentry 所做的就是收集应用底层代码的崩溃信息，便于我们排除代码异常。</p><h3 id="既有方案"><a href="#既有方案" class="headerlink" title="既有方案"></a>既有方案</h3><ol><li>单台服务器上每个系统服务自己维护自己的日志，方便自己查看</li><li>同台服务器上多个日志集中存放到同个目录，方便集中管理</li><li>使用 ELK 系统，将所有日志输出到 ELK 系统，使用 GUI 进行管理展示</li></ol><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ol><li><p>无法第一时间感知错误</p><p>脚本日志的拉取不是实时的，web端用户的反馈也存在滞后的问题，从出现问题到解决问题周期会很长，容易是工作陷入被动</p></li><li><p>错误信息的获取比较低效</p><p>用户反馈的信息及可能有的邮件报警信息都非常有限且不够准确，最终开发人员还是得在日志文件中大量的翻看上下文查看关联信息。更困难的是错误不能重现的话，还需要不断埋点测试去获取变量数据，十分难以定位问题。</p></li><li><p>日志处理方式不够灵活</p><p>通常来说，除了程序运行出错，我们也比较关心其他异常情况，比如数据污染，非法请求，第三方 API 调用异常等等。如果将辞了等同错误全部记录下来，很容易就会使告警信息泛滥，无法及时获得有效信息。但是如果不处理此类异常，迟早会导致严重问题。所以我们需要对不同的日志内容有不同的处理方式，相同的日志内容也可以根据不同的业务场景进行不同的处理。</p></li><li><p>监控覆盖面有限</p><p>完整的监控应该是包含脚本，前端以及后端的，但是当前后端分离以后，很多前端的问题无法被统一记录下来</p></li></ol><h3 id="Sentry-基本介绍"><a href="#Sentry-基本介绍" class="headerlink" title="Sentry 基本介绍"></a>Sentry 基本介绍</h3><p>Sentry 是一个现代化的错误日志记录以及聚合平台。支持几乎所有的主流开发语言及平台，并提供现代化 UI。</p><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129977.png" alt="image-20191017165847184"></p><ol><li><p>优势</p><p>接入 Sentry 前；</p><ul><li>用户A: 发布功能用不了</li><li>开发者A: 哪个页面? 截个图</li><li>用户A: (发截图)</li><li>开发者A发现bug可以重现, 登录服务器查看错误日志, 确认程序逻辑无问题, 查看数据库数据, 发现有脏数据. 联系开发者B检查负责更新数据的python脚本C.py.</li><li>开发者B登录服务器查看错误日志, 发现一个逻辑错误导致脚本罢工, 已持续了一个小时. 影响了数千条数据</li></ul><p>接入 Sentry 后：</p><ul><li>开发者A,B同时收到邮件告警, 一分钟前脚本C.py异常退出.</li><li>开发者B进入sentry后台查看错误信息, 定位问题并将其修复, 再清理受影响的数十条数据.</li><li>在此过程中没有用户受到影响, 无需开发者A介入</li></ul></li><li><p>概念</p><ul><li><p>event</p><p>可操作数据的基本单位，每一次日志输出就会产生一个 event。event并不一定是错误，如果日志级别设置的很低，那么后台就会产生非常多的 event，所以正确的设置日志的级别 非常的重要。</p></li><li><p>issue</p><p>同意类 event 的聚合，某一个错误可能因为重复执行而被记录多次，在 sentry系统会自动聚合到一起，方便处理，通常我们操作的对象也就是 issue。</p></li><li><p>DNS</p><p>DNS 及时客户端密匙，用来进行客户端和服务端的通信。DNS 是一个 URL，包含一个公匙，一个私匙，项目标记及服务器地址（<a href="https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7%EF%BC%89">https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7）</a></p></li><li><p>raven</p><p>整个错误日志监控系统包含客户端和服务端，Sentry 是服务端的名称，客户端名称为 Raven，需要两者配合才能工作。</p></li></ul></li><li><p>创建项目流程</p><ol><li><p>登录 Sentry 系统</p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129682.png" alt="image-20191024093908660" style="zoom:50%;" /></li><li><p>点击创建项目</p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129297.png" alt="image-20191024094042431" style="zoom:50%;" /></li><li><p>选择框架</p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129370.png" alt="image-20191024094257179" style="zoom:50%;" /></li><li><p>根据指示下载安装包并进行配置</p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129961.png" alt="image-20191024095325581" style="zoom:50%;" /></li></ol><p>在 flask 中的配置有两种方式，可以自由选择</p><p>第一种：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">from raven.contrib.flask import Sentry<br>sentry = <span class="hljs-constructor">Sentry()</span><br>sentry.init<span class="hljs-constructor">_app(<span class="hljs-params">app</span>,<span class="hljs-params">dsn</span>=<span class="hljs-string">&quot;https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7&quot;</span>,<span class="hljs-params">logging</span>=True, <span class="hljs-params">level</span>=<span class="hljs-params">logging</span>.ERROR)</span><br></code></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> sentry_sdk<br><span class="hljs-keyword">from</span> sentry_sdk.<span class="hljs-built_in">int</span>egrations.flask <span class="hljs-keyword">import</span> FlaskIntegration<br>sentry_sdk.init(dsn=<span class="hljs-string">&quot;https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7&quot;</span>,<br><span class="hljs-built_in">int</span>egrations=[FlaskIntegration()])<br></code></pre></td></tr></table></figure><h3 id="gunicorn-与-Sentry-结合配置"><a href="#gunicorn-与-Sentry-结合配置" class="headerlink" title="gunicorn 与 Sentry 结合配置"></a>gunicorn 与 Sentry 结合配置</h3><p>使用 yaml 文件进行 logging 配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Logging configuration</span><br><br><span class="hljs-section">[loggers]</span><br><span class="hljs-attr">keys</span> = root, gunicorn.access, gunicorn.error<br><br><span class="hljs-section">[handlers]</span><br><span class="hljs-attr">keys</span> = access, error, sentry<br><br><span class="hljs-section">[formatters]</span><br><span class="hljs-attr">keys</span> = json, generic<br><br><span class="hljs-comment"># Root logger</span><br><span class="hljs-comment"># The root logger sends messages to the console and to Sentry.</span><br><span class="hljs-section">[logger_root]</span><br><span class="hljs-attr">handlers</span> = error, sentry<br><br><span class="hljs-comment"># Gunicorn loggers</span><br><span class="hljs-comment"># Gunicorn logging is configured with two loggers: &#x27;gunicorn.access&#x27; and &#x27;gunicorn.error&#x27;.</span><br><span class="hljs-comment"># The access log is sent to stdout and the error log is sent to stderr, both without propagation.</span><br><span class="hljs-comment"># Only the critical logger has a handler to send messages to Sentry.</span><br><br><span class="hljs-section">[logger_gunicorn.access]</span><br><span class="hljs-attr">handlers</span> = access<br><span class="hljs-attr">qualname</span> = gunicorn.access<br><span class="hljs-attr">level</span> = INFO<br><span class="hljs-attr">propagate</span> = <span class="hljs-number">0</span><br><br><span class="hljs-section">[logger_gunicorn.error]</span><br><span class="hljs-attr">handlers</span> = error, sentry<br><span class="hljs-attr">qualname</span> = gunicorn.error<br><span class="hljs-attr">level</span> = ERROR<br><span class="hljs-attr">propagate</span> = <span class="hljs-number">0</span><br><br><span class="hljs-section">[handler_access]</span><br><span class="hljs-attr">class</span> = StreamHandler<br><span class="hljs-attr">formatter</span> = json<br><span class="hljs-attr">args</span> = (sys.stdout,)<br><br><span class="hljs-section">[handler_error]</span><br><span class="hljs-attr">class</span> = StreamHandler<br><span class="hljs-attr">formatter</span> = json<br><span class="hljs-attr">args</span> = (sys.stderr,)<br><br><span class="hljs-section">[handler_sentry]</span><br><span class="hljs-attr">class</span> = raven.handlers.logging.SentryHandler<br><span class="hljs-attr">level</span> = CRITICAL<br><span class="hljs-attr">formatter</span> = generic<br><span class="hljs-attr">args</span> = (<span class="hljs-string">&quot;https://facc2ededdfa45ba955dca1eb485915a@sentry.socmap.org/7&quot;</span>,)<br><br><span class="hljs-section">[formatter_generic]</span><br><span class="hljs-attr">format</span> = [bs-whatweb][%(levelname)s] [%(name)s]: %(message)s<br><span class="hljs-section">[formatter_json]</span><br><span class="hljs-attr">class</span> = project.api.utils.logger.JSONFormatter<br></code></pre></td></tr></table></figure></li></ol><h3 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h3><p>Sentry 官方还提供了 Docker 镜像以及<a href="https://github.com/docker-library/docs/blob/master/sentry/variant-onbuild.md">部署方案</a>，用起来非常方便。</p><ol><li>首先安装并启动 Docker 服务，然后拉取最新的 Sentry 镜像：<code>docker pull sentry</code>。</li><li>启动一个 redis 服务作为消息 broker：<code>docker run -d --name sentry-redis redis</code></li><li>设置数据库密码作为环境变量，之后的命令都会用到：<code>export DBPW=&#39;&lt;your-postgres-db-password&gt;&#39;</code></li><li>启动一个 Postgres 数据库服务作为存储数据库：<code>docker run -d --name sentry-postgres -e POSTGRES_PASSWORD=&#39;$(DBPW)&#39; -e POSTGRES_USER=sentry postgres</code>，这里推荐使用 Volume 将数据库文件单独挂载出来。</li><li>migrate 数据库结构至最新：<code>docker run -it --rm -e SENTRY_SECRET_KEY=&#39;$(DBPW)&#39; --link sentry-postgres:postgres --link sentry-redis:redis sentry upgrade</code></li><li>启动 Sentry 服务并链接以上服务: <code>docker run -d --name sentry-app -e SENTRY_SECRET_KEY=&#39;$(DBPW)&#39; --link sentry-redis:redis --link sentry-postgres:postgres -p 8080:9000 sentry</code></li><li>运行一个 cron 容器用于定时任务：<code>docker run -d --name sentry-cron -e SENTRY_SECRET_KEY=&#39;$(DBPW)&#39; --link sentry-postgres:postgres --link sentry-redis:redis sentry run cron</code></li><li>运行一个 worker 容器用于后台任务：<code>docker run -d --name sentry-worker-1 -e SENTRY_SECRET_KEY=&#39;$(DBPW)&#39; --link sentry-postgres:postgres --link sentry-redis:redis sentry run worker</code></li></ol><p>如果没有什么错误发生，使用 <code>docker ps</code> 命令将会得到 <code>sentry-app</code>、<code>sentry-posgres</code>、<code>sentry-redis</code>、<code>sentry-cron</code>、<code>sentry-worker-1</code> 5 个正在运行的容器。</p>]]></content>
    
    
    <categories>
      
      <category>监控预警</category>
      
      <category>Sentry</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sentry</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda 安装</title>
    <link href="/2019/07/31/Anaconda/"/>
    <url>/2019/07/31/Anaconda/</url>
    
    <content type="html"><![CDATA[<h3 id="Anaconda-安装"><a href="#Anaconda-安装" class="headerlink" title="Anaconda 安装"></a>Anaconda 安装</h3><ul><li>下载安装包: 官网, 清华源等</li><li>推荐下载python3 (Anaconda3) 版本</li><li>按照安装程序提示一步步安装就好了, 安装完成之后会多几个应用<ul><li><p><strong>Anaconda Navigtor</strong> ：用于管理工具包和环境的图形用户界面，后续涉及的众多管理命令也可以在 Navigator 中手工实现。</p></li><li><p><strong>Jupyter notebook</strong> ：基于web的交互式计算环境，可以编辑易于人们阅读的文档，用于展示数据分析的过程。</p></li><li><p><strong>qtconsole</strong> ：一个可执行 IPython 的仿终端图形界面程序，相比 Python Shell 界面，qtconsole 可以直接显示代码生成的图形，实现多行代码输入执行，以及内置许多有用的功能和函数。</p></li><li><p><strong>spyder</strong> ：(可选) 一个使用Python语言、跨平台的、科学运算集成开发环境。</p></li></ul></li></ul><h3 id="更改conda默认的下载源"><a href="#更改conda默认的下载源" class="headerlink" title="更改conda默认的下载源"></a>更改conda默认的下载源</h3><ul><li>更改为清华源 <figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/<br>conda config --<span class="hljs-built_in">set</span> show_channel_urls <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><h5 id="Conda-三方源"><a href="#Conda-三方源" class="headerlink" title="Conda 三方源"></a>Conda 三方源</h5></li><li>Conda Forge<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/<br></code></pre></td></tr></table></figure></li><li>msys2<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/<br></code></pre></td></tr></table></figure></li><li>bioconda<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/<br></code></pre></td></tr></table></figure></li><li>menpo<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/<br></code></pre></td></tr></table></figure></li><li>pytorch <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/<br><br><span class="hljs-comment"># for legacy win-64</span><br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/peterjc123/<br></code></pre></td></tr></table></figure></li></ul><h3 id="管理虚拟环境"><a href="#管理虚拟环境" class="headerlink" title="管理虚拟环境"></a>管理虚拟环境</h3><p>   接下来我们就可以用anaconda来创建我们一个个独立的python环境了.接下来的例子都是在命令行操作的,请打开你的命令行吧.</p><ul><li><p><strong>activate</strong></p><ul><li>activate 能将我们引入anaconda设定的虚拟环境中, 如果你后面什么参数都不加那么会进入anaconda自带的base环境</li><li>你可以输入python试试, 这样会进入base环境的python解释器, 如果你把原来环境中的python环境去除掉会更能体会到, 这个时候在命令行中使用的已经不是你原来的python而是base环境下的python.而命令行前面也会多一个(base) 说明当前我们处于的是base环境下.</li></ul></li><li><p><strong>创建自己的虚拟环境</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda create -n virtual_name python=3<br></code></pre></td></tr></table></figure></li><li><p><strong>查看所有的虚拟环境</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> list<br></code></pre></td></tr></table></figure></li><li><p><strong>激活虚拟环境</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda activate virtual_name<br></code></pre></td></tr></table></figure></li><li><p><strong>切回默认环境 &#x2F; 反激活虚拟环境</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda deactivate<br></code></pre></td></tr></table></figure></li><li><p><strong>查看当前环境模块&#x2F;包</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda list<br></code></pre></td></tr></table></figure></li><li><p><strong>安装一个模块&#x2F;包</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda instal numpy<br></code></pre></td></tr></table></figure></li><li><p><strong>卸载一个模块&#x2F;包</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda remove numpy<br></code></pre></td></tr></table></figure></li><li><p><strong>更新一个模块&#x2F;包</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda update numpy<br></code></pre></td></tr></table></figure></li><li><p><strong>删除一个环境及其下所有包</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda remove -n virtual_name --all<br></code></pre></td></tr></table></figure></li><li><p><strong>导出当前环境的包信息</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> <span class="hljs-built_in">export</span> &gt; environment.yaml<br></code></pre></td></tr></table></figure></li><li><p><strong>用配置文件创建新的虚拟环境</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> create -f environment.yaml<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
      <category>Anaconda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Anaconda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac 安装 ruby</title>
    <link href="/2019/06/25/Mac%20osx%20%E5%AE%89%E8%A3%85%20ruby/"/>
    <url>/2019/06/25/Mac%20osx%20%E5%AE%89%E8%A3%85%20ruby/</url>
    
    <content type="html"><![CDATA[<h3 id="安装CocoaPods第一步"><a href="#安装CocoaPods第一步" class="headerlink" title="安装CocoaPods第一步"></a>安装CocoaPods第一步</h3><p><strong>起因:重装系统后需要重新安装CocoaPods网上搜了下发现很多都过时了，已经不能用了。而且taobao Gems源已经停止服务，现在有ruby-china提供服务PS：”$”开头表示需要在终端下执行</strong></p><h3 id="1-安装RVM"><a href="#1-安装RVM" class="headerlink" title="1.安装RVM"></a>1.安装RVM</h3><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">curl -L https://get.rvm.io | bash -s stable</span><br></code></pre></td></tr></table></figure><p><strong>期间可能需要输入密码(我安装时没有提示，密码就是开机密码输入时密码不会显示直接输入完成就可以)，等待一段时间将安装好(大概五六分钟)。</strong><br><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081128066.png" alt="安装RVM"></p><h3 id="2-载入RVM环境"><a href="#2-载入RVM环境" class="headerlink" title="2.载入RVM环境"></a>2.载入RVM环境</h3><p><strong>若打开新终端窗口则不用执行</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ <span class="hljs-keyword">source</span> ~<span class="hljs-regexp">/.rvm/</span>scripts/rvm<br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081128763.png" alt="载入RVM环境"></p><h3 id="3-检查RVM是否安装好"><a href="#3-检查RVM是否安装好" class="headerlink" title="3.检查RVM是否安装好"></a>3.检查RVM是否安装好</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm -v</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081128518.png" alt="img"></p><h3 id="4-安装Ruby"><a href="#4-安装Ruby" class="headerlink" title="4.安装Ruby"></a>4.安装Ruby</h3><p>##### 1&gt;列出已知的ruby版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm list known</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081128428.png" alt="列出已知的ruby版本"></p><h5 id="2-gt-选择2-0-0版本进行安装-其他版本也可以"><a href="#2-gt-选择2-0-0版本进行安装-其他版本也可以" class="headerlink" title="2&gt;选择2.0.0版本进行安装(其他版本也可以)"></a>2&gt;选择2.0.0版本进行安装(其他版本也可以)</h5><p><strong>等待下载(途中需要按回车确定安装路径、还要输入密码)、编译。完成之后Ruby、Ruby Gems就安装好了</strong><br><code>$ rvm install 2.6</code><br><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081128625.png" alt="选择2.0.0版本进行安装"></p><h5 id="3-gt-查询已安装的ruby"><a href="#3-gt-查询已安装的ruby" class="headerlink" title="3&gt;查询已安装的ruby"></a>3&gt;查询已安装的ruby</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm list</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129344.png" alt="查询已安装的ruby"></p><h5 id="4-gt-卸载已安装的版本-若已经安装过ruby）"><a href="#4-gt-卸载已安装的版本-若已经安装过ruby）" class="headerlink" title="4&gt;卸载已安装的版本(若已经安装过ruby）"></a>4&gt;卸载已安装的版本(若已经安装过ruby）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm remove [版本号]</span><br></code></pre></td></tr></table></figure><h3 id="4-设置Ruby版本"><a href="#4-设置Ruby版本" class="headerlink" title="4.设置Ruby版本"></a>4.设置Ruby版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm 2.6 —default</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129237.png" alt="设置Ruby版本"><br><strong>检查是否安装好了</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">rvm -v</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129101.png" alt="检查"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">gem -v</span><br></code></pre></td></tr></table></figure><p><img src="https://zwj-typora-ipic.oss-cn-beijing.aliyuncs.com/img/202112081129235.png" alt="检查"></p><h3 id="5-更换Ruby源"><a href="#5-更换Ruby源" class="headerlink" title="5.更换Ruby源"></a>5.更换Ruby源</h3><p><strong>我们需要来修改更换Ruby源，国内镜像源 taobao 源 已经停止维护了（由于国内被墙）所以要把源切换至ruby-china</strong></p><h5 id="1-gt-检测Ruby源"><a href="#1-gt-检测Ruby源" class="headerlink" title="1&gt;检测Ruby源"></a>1&gt;检测Ruby源</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">gem sources -l</span><br></code></pre></td></tr></table></figure><p><strong>检查结果：（ 如果电脑没安装过 CocoaPods，此时应该是默认 ruby 源 ）</strong><br><code>huanghaipoMacBook-Pro:~ jijiucheng$ gem sources -l *** CURRENT SOURCES *** https://rubygems.org/</code></p><h4 id="2-gt-移除-ruby-源"><a href="#2-gt-移除-ruby-源" class="headerlink" title="2&gt;移除 ruby 源"></a>2&gt;移除 ruby 源</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">gem sources --remove https://rubygems.org/</span><br></code></pre></td></tr></table></figure><h4 id="3-gt-移除结果："><a href="#3-gt-移除结果：" class="headerlink" title="3&gt;移除结果："></a>3&gt;移除结果：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">huanghaipoMacBook-Pro:local jijiucheng$ gem sources --remove https://rubygems.org/<br>https://rubygems.org/ removed from sources<br></code></pre></td></tr></table></figure><p><strong>替换添加国内镜像源 ruby-china 源，因为上面已经提到国内镜像源 taobao 源 已经停止维护了，所以此处替换的是 ruby-china 源，且尽量确保只有一个 ruby-china 源</strong><br><code>$ gem sources --add https://gems.ruby-china.org</code></p><h4 id="4-gt-替换结果："><a href="#4-gt-替换结果：" class="headerlink" title="4&gt;替换结果："></a>4&gt;替换结果：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">huanghaipoMacBook-Pro:local jijiucheng$ gem sources --add https://gems.ruby-china.com<br>https://gems.ruby-china.org added to sources<br></code></pre></td></tr></table></figure><h4 id="5-gt-再次检查此时的-ruby-源：（-已经变成了-ruby-china-源-）"><a href="#5-gt-再次检查此时的-ruby-源：（-已经变成了-ruby-china-源-）" class="headerlink" title="5&gt;再次检查此时的 ruby 源：（ 已经变成了 ruby-china 源 ）"></a>5&gt;再次检查此时的 ruby 源：（ 已经变成了 ruby-china 源 ）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">huanghaipoMacBook-Pro:local jijiucheng$ gem sources -l<br>*** CURRENT SOURCES ***<br>https://gems.ruby-china.com<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>ruby</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ruby</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web 指纹识别杂论</title>
    <link href="/2019/06/24/web%20%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E6%9D%82%E8%AE%BA/"/>
    <url>/2019/06/24/web%20%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E6%9D%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>##前言</p><p>在 web 渗透过程中，对目标网站的指纹识别非常关键，通过工具或者手工识别 CMS系统是自建的还是二次开发，还是直接使用公开的CMS 程序至关重要。通过获取的这些信息来决定后续渗透的思路和策略。CMS 指纹识别是渗透测试环节的一个非常重要的阶段，是信息收集的中的一个关键环节。</p><h2 id="1-指纹识别技术简介及思路"><a href="#1-指纹识别技术简介及思路" class="headerlink" title="1. 指纹识别技术简介及思路"></a>1. 指纹识别技术简介及思路</h2><h3 id="1-1-指纹识别技术"><a href="#1-1-指纹识别技术" class="headerlink" title="1.1 指纹识别技术"></a>1.1 指纹识别技术</h3><p>组件是网络空间最小的单元，Web应用程序、数据库、中间件等都属于组件。指纹是组件上能标识对象类型的一段特征信息，用来在渗透测试信息收集环节中快熟识别目标服务。互联网随时代的发展逐渐成熟，大批应用组件存在足以说明当前服务名称和版本的特征，识别这些特征获取当前服务信息，也表明该系统采用那个公司的产品，例如论坛常用 Discuz!来搭建，通过其 robots.txt 等可以识别网站程序是采用 Discuz！</p><h3 id="1-2-指纹识别思路"><a href="#1-2-指纹识别思路" class="headerlink" title="1.2 指纹识别思路"></a>1.2 指纹识别思路</h3><p>指纹识别可以铜鼓哦一些开源程序和小工具来进行扫描，也有可以结合文件头和反馈信息进行手工判断，指纹识别主要思路：</p><p>（1）使用工具自动判断</p><p>（2）手工对网站的关键字、版权信息、后台登录、程序版本、robots.txt 等常见固有文件进行识别、查找和比对，相同文件具有相同的 MD5 值和相同的属性。</p><h2 id="2-指纹识别方式"><a href="#2-指纹识别方式" class="headerlink" title="2.  指纹识别方式"></a>2.  指纹识别方式</h2><p>基于对指纹识别方式的各种套路和分析，可以分为以下几个类别：</p><h3 id="2-1-基于特殊文件的-MD5-值匹配"><a href="#2-1-基于特殊文件的-MD5-值匹配" class="headerlink" title="2.1 基于特殊文件的 MD5 值匹配"></a>2.1 基于特殊文件的 MD5 值匹配</h3><p>基于web网站独有的favicon.ico、css、logo.ico、js等文件的md5 比对网站类型，通过收集CMS公开代码中的独有文件，这些文件一般轻易不会更改，通过爬虫对这些文件进行抓取并比对md5值，如果一样，则认为该系统匹配。这种识别速度最快，但可能不准确，因为这些独有文件可能在部署到真实系统中会进行更改，那么就会造成很大的误差。</p><p>（1）robots.txt文件识别</p><p>相关厂商下的cms（内容管理系统）程序文件包含说明当前cms名称及版本的特征码，其中一些独有的文件夹以及名称都是识别cms的好方法，如Discuz官网下robots.txt文件。dedecms官网<a href="http://www.dedecms.com/robots.txt%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%EF%BC%9A">http://www.dedecms.com/robots.txt文件内容：</a></p><p>Disallow: &#x2F;plus&#x2F;feedback_js.php</p><p>Disallow: &#x2F;plus&#x2F;mytag_js.php</p><p>Disallow: &#x2F;plus&#x2F;rss.php</p><p>Disallow: &#x2F;plus&#x2F;search.php</p><p>Disallow: &#x2F;plus&#x2F;recommend.php</p><p>Disallow: &#x2F;plus&#x2F;stow.php</p><p>Disallow: &#x2F;plus&#x2F;count.php</p><p>看到这个基本可以判断为dedecms。</p><p>2）计算机md5值</p><p>计算网站所使中间件或cms目录下静态文件的md5值，md5码可以唯一地代表原信息的特征。静态文件包括html、js、css、image等，建立在站点静态文件存在的情况下访问，如 Dedecms 官网下网站根目录<a href="http://www.dedecms.com/img/buttom_logo.gif%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%9C%89%E4%B8%80%E4%BA%9B%E5%85%AC%E5%BC%80%E7%A8%8B%E5%BA%8F%EF%BC%8C%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AEcms.txt%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%BA%94%E5%80%BC%E8%BF%9B%E8%A1%8C%E8%AF%86%E5%88%AB%EF%BC%8C%E5%A6%82%E5%9B%BE1%E6%89%80%E7%A4%BA%E3%80%82">http://www.dedecms.com/img/buttom_logo.gif图片文件，目前有一些公开程序，通过配置cms.txt文件中的相应值进行识别，如图1所示。</a></p><h3 id="2-2-请求相应主体内容或头信息的关键字匹配"><a href="#2-2-请求相应主体内容或头信息的关键字匹配" class="headerlink" title="2.2 请求相应主体内容或头信息的关键字匹配"></a>2.2 请求相应主体内容或头信息的关键字匹配</h3><p>请求响应主体内容或头信息的关键字匹配方法可以寻找网站的css 、js代码的命名规则，也可以找关键字，以及head cookie等等，但是弊端是收集这些规则会耗费很久的时间。</p><h3 id="2-3-基于-URL-关键字识别"><a href="#2-3-基于-URL-关键字识别" class="headerlink" title="2.3 基于 URL 关键字识别"></a>2.3 基于 URL 关键字识别</h3><p>基于爬虫爬出来的网站目录比对web信息，准确性比较高，但是如果改了目录结构就会造成问题，而且一部分网站有反爬虫机制，会造成一些困扰</p><h3 id="2-4-基于-TCP-x2F-IP-请求协议识别服务指纹"><a href="#2-4-基于-TCP-x2F-IP-请求协议识别服务指纹" class="headerlink" title="2.4 基于 TCP&#x2F;IP 请求协议识别服务指纹"></a>2.4 基于 TCP&#x2F;IP 请求协议识别服务指纹</h3><p> 一些应用程序、组建和数据库服务会有一些特殊的指纹，一般情况下不会进行更改。网络上的通信交互均通过TCP&#x2F;TP协议簇进行，操作系统也必须实现该协议。操作系统根据不同数据包做出不同反应。如Nmap检测操作系统工具通过向目标主机发送协议数据包并分析其响应信息进行操作系统指纹识别工作，其扫描命令为“nmap –O 192.168.1.1”。</p><h3 id="2-5-在owasp中识别Web应用框架测试方法"><a href="#2-5-在owasp中识别Web应用框架测试方法" class="headerlink" title="2.5 在owasp中识别Web应用框架测试方法"></a>2.5 在owasp中识别Web应用框架测试方法</h3><p>（1）http头。查看http响应报头的X-Powered-By字段来识别，可以通过netcat来识别，使用netcat 127.0.0.1 80对127.0.0.1主机的80端口web服务器框架进行识别。</p><p>（2）Cookies。一些框架有固定的Cookies名称，这些名称一般情况都不会更改，例如zope3、cakephp、kohanasesson、laravel_session。</p><p>（3）Html源代码。html源代码中包含注释、js、css等信息，通过访问这些信息来判断和确认cms系统框架。在源代码中常常会包含powered by、bulit upon、running等特征。</p><p>（4）特殊文件和文件夹</p>]]></content>
    
    
    <categories>
      
      <category>安全研究</category>
      
      <category>指纹识别</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指纹识别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker-Compose 简介及常用命令</title>
    <link href="/2019/04/25/Docker-Compose%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2019/04/25/Docker-Compose%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker-Compose-简介及常用命令"><a href="#Docker-Compose-简介及常用命令" class="headerlink" title="Docker-Compose 简介及常用命令"></a>Docker-Compose 简介及常用命令</h2><h3 id="一-Docker-Compose-简介"><a href="#一-Docker-Compose-简介" class="headerlink" title="一. Docker-Compose 简介"></a>一. Docker-Compose 简介</h3><h4 id="1-Docker-Compose-简介"><a href="#1-Docker-Compose-简介" class="headerlink" title="1. Docker-Compose 简介"></a>1. Docker-Compose 简介</h4><p>​        Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。</p><ul><li>Docker-Compose将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。</li><li>Docker-Compose运行目录下的所有文件（docker-compose.yml，extends文件或环境变量文件等）组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像，参数，依赖。一个服务当中可包括多个容器实例，Docker-Compose并没有解决负载均衡的问题，因此需要借助其它工具实现服务发现及负载均衡。<br>   Docker-Compose的工程配置文件默认为docker-compose.yml，可通过环境变量COMPOSE_FILE或-f参数自定义配置文件，其定义了多个有依赖关系的服务及每个服务运行的容器。使用一个Dockerfile模板文件，可以让用户很方便的定义一个单独的应用容器。在工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个Web项目，除了Web服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。Docker-Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。<br>      Docker-Compose项目由Python编写，调用Docker服务提供的API来对容器进行管理。因此，只要所操作的平台支持Docker API，就可以在其上利用Compose来进行编排管理。</li></ul><h4 id="2-Docker-Compose安装"><a href="#2-Docker-Compose安装" class="headerlink" title="2. Docker-Compose安装"></a>2. Docker-Compose安装</h4><p>可以直接使用pip 进行安装</p><p>建议先更新pip 然后在进行安装</p><p>pip 更新命令</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs python">pip install --upgrade pip<br></code></pre></td></tr></table></figure><p>安装命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install docker-compose<br></code></pre></td></tr></table></figure><p>安装过后以下命令查看是否安装成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">docker-compose --version<br></code></pre></td></tr></table></figure><h4 id="3-Docker-Compose-卸载"><a href="#3-Docker-Compose-卸载" class="headerlink" title="3. Docker-Compose 卸载"></a>3. Docker-Compose 卸载</h4><p>卸载命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip uninstall docker-compose<br></code></pre></td></tr></table></figure><h3 id="二-Docker-Compose常用命令"><a href="#二-Docker-Compose常用命令" class="headerlink" title="二. Docker-Compose常用命令"></a>二. Docker-Compose常用命令</h3><h4 id="1-Docker-Compose-命令格式"><a href="#1-Docker-Compose-命令格式" class="headerlink" title="1. Docker-Compose 命令格式"></a>1. Docker-Compose 命令格式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker-compose <span class="hljs-selector-attr">[-f &lt;arg&gt;]</span> <span class="hljs-selector-attr">[options]</span><span class="hljs-selector-attr">[command]</span><span class="hljs-selector-attr">[args]</span><br></code></pre></td></tr></table></figure><p>常用命令选项如下：</p><p>-f  -file FILE 可指定Compose 模版文件，默认为 docker-compose.yml</p><p>-p -project-name  NAME指定项目名称，默认将使用所在目录名称为项目名</p><p>-v –version 打印版本并退出</p><p>-verbose 输出调试信息</p><p>-x-network-driver  使用 Docker 的可插拔网络后端特性(需要 Docker 1.9+版本，可操作性有待商榷)</p><p>-x-network-deover DRIVER指定网络后端的驱动，默认为 bridge(需要 Docker 1.9+版本)</p><h4 id="2-Docker-Compose-拉取服务镜像"><a href="#2-Docker-Compose-拉取服务镜像" class="headerlink" title="2. Docker-Compose 拉取服务镜像"></a>2. Docker-Compose 拉取服务镜像</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker-compose pull <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-attr">[SERVICE...]</span><br></code></pre></td></tr></table></figure><p>命令选项如下：</p><p>–ignore-pull-failures，忽略拉取镜像过程中的错误<br>–parallel，多个镜像同时拉取<br>–quiet，拉取镜像过程中不打印进度信息</p><p>拉取服务依赖的镜像</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose pull</span><br></code></pre></td></tr></table></figure><h4 id="3-Docker-Compose-构建服务"><a href="#3-Docker-Compose-构建服务" class="headerlink" title="3. Docker-Compose 构建服务"></a>3. Docker-Compose 构建服务</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker-compose build <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-attr">[--build-arg key=val...]</span> <span class="hljs-selector-attr">[SERVICE...]</span><br></code></pre></td></tr></table></figure><p>命令选项包括：<br>–compress 通过gzip压缩构建上下环境<br>–force-rm 删除构建过程中的临时容器<br>–no-cache 构建镜像过程中不使用缓存<br>–pull 始终尝试通过拉取操作来获取更新版本的镜像<br>-m, –memory MEM为构建的容器设置内存大小<br>–build-arg key&#x3D;val为服务设置build-time变量<br>服务容器一旦构建后，将会带上一个标记名。可以随时在项目目录下运行docker-compose build来重新构建服务</p><h4 id="4-Docker-Compose-启动容器"><a href="#4-Docker-Compose-启动容器" class="headerlink" title="4. Docker-Compose 启动容器"></a>4. Docker-Compose 启动容器</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span>-compose start<span class="hljs-meta"> [SERVICE...]</span><br></code></pre></td></tr></table></figure><p>启动已经存在的服务容器</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker-compose <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure><h4 id="5-Docker-compose-构建并启动容器"><a href="#5-Docker-compose-构建并启动容器" class="headerlink" title="5. Docker-compose  构建并启动容器"></a>5. Docker-compose  构建并启动容器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker-compose up <span class="hljs-selector-attr">[option]</span><span class="hljs-selector-attr">[--scale SERVICE=NUM...]</span><span class="hljs-selector-attr">[SERVICE...]</span><br></code></pre></td></tr></table></figure><p>常用命令选项如下：</p><p>-d 在后台运行服务器</p><p>-t -timeout TIMEOUT 停止容器是的超时(默认为 10 秒)</p><p>-f  -file FILE 可指定Compose 模版文件，默认为 docker-compose.yml</p><p>-build  在启动容器前自动构建服务镜像</p><p>-no-build 不自动构建缺失的镜像</p><p>常用命令实例</p><p>启动所有服务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose up</span><br></code></pre></td></tr></table></figure><p>在后台启动所有服务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose up -d</span><br></code></pre></td></tr></table></figure><p>重新构建镜像</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker-compose up -d <span class="hljs-comment">--build</span><br></code></pre></td></tr></table></figure><p>-f 使用指定的 Compose 模版文件启动服务,默认为 docker-compose.yml 文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker<span class="hljs-literal">-compose</span> <span class="hljs-operator">-f</span> docker<span class="hljs-literal">-compose</span>.yml up<br></code></pre></td></tr></table></figure><h4 id="6-Docker-Compose-查看容器"><a href="#6-Docker-Compose-查看容器" class="headerlink" title="6. Docker-Compose 查看容器"></a>6. Docker-Compose 查看容器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker-compose ps <span class="hljs-selector-attr">[options]</span><span class="hljs-selector-attr">[SERVICE...]</span><br></code></pre></td></tr></table></figure><p>查看项目中运行中的容器</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose ps</span><br></code></pre></td></tr></table></figure><p>查看当前项目中的所有容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker-compose ps -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><h4 id="7-Docker-Compose-停止容器"><a href="#7-Docker-Compose-停止容器" class="headerlink" title="7. Docker-Compose 停止容器"></a>7. Docker-Compose 停止容器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker-compose stop <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-attr">[SERVICE...]</span><br></code></pre></td></tr></table></figure><p>命令选项如下：</p><p>-t —timeout TIMEOUT停止容器时候的超时(默认为 10 秒)</p><p>停止正在运行的容器</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker-compose stop<br></code></pre></td></tr></table></figure><p>可使用以下命令再次启动</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker-compose <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure><p>通过发送 SIGKILL 信号强制停止服务容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker-compsoe kill <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-attr">[SERVICE]</span><br></code></pre></td></tr></table></figure><p>命令选项如下：</p><p>-s 指定发送的信号</p><h4 id="8-Docker-Compose-移除容器"><a href="#8-Docker-Compose-移除容器" class="headerlink" title="8. Docker-Compose 移除容器"></a>8. Docker-Compose 移除容器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker-compose rm <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-attr">[SERVICE...]</span><br></code></pre></td></tr></table></figure><p>命令选项如下：</p><p>–f, –force，强制直接删除，包括非停止状态的容器<br>-v  删除容器所挂载的数据卷</p><p>先停止容器</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker-compose stop<br></code></pre></td></tr></table></figure><p>删除所有停止状态下的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose <span class="hljs-built_in">rm</span><br></code></pre></td></tr></table></figure><h4 id="9-Docker-Compose-停用移除所有容器以及网络相关"><a href="#9-Docker-Compose-停用移除所有容器以及网络相关" class="headerlink" title="9. Docker-Compose 停用移除所有容器以及网络相关"></a>9. Docker-Compose 停用移除所有容器以及网络相关</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span>-compose down<span class="hljs-meta"> [options]</span><br></code></pre></td></tr></table></figure><p>命令选项如下：</p><p>-rmi type，删除镜像、类型必须是：all，删除 compose 文件中定义的所有镜像</p><p>​                                                              local， 删除镜像名为空的镜像</p><p>-v  -volumes 删除已经在 compose 文件中定义的和匿名的附在容器上的数据卷</p><p>-remove-orphans  删除服务中没有在 compose 中定义的容器</p><h4 id="10-Docker-Compose-查看输出日志"><a href="#10-Docker-Compose-查看输出日志" class="headerlink" title="10. Docker-Compose 查看输出日志"></a>10. Docker-Compose 查看输出日志</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker-compose logs <span class="hljs-selector-attr">[options]</span><span class="hljs-selector-attr">[SERVICE...]</span><br></code></pre></td></tr></table></figure><p>默认情况下，docker-compsoe 将对不同的服务输出使用不同的颜色用以区分，但是可以通过-no-color 关闭颜色</p><p>查看服务容器的输出</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose logs</span><br></code></pre></td></tr></table></figure><h4 id="11-Docker-Compose-重启服务"><a href="#11-Docker-Compose-重启服务" class="headerlink" title="11. Docker-Compose 重启服务"></a>11. Docker-Compose 重启服务</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker-compose restart <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-attr">[SERVICE...]</span><br></code></pre></td></tr></table></figure><p>命令选项如下：</p><p>-t  –timeout TIMEOUT 指定重启前停止容器的超时（默认为10秒）</p><p>重启项目服务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose restart</span><br></code></pre></td></tr></table></figure><h4 id="12-Docker-Compose-暂停、恢复容器"><a href="#12-Docker-Compose-暂停、恢复容器" class="headerlink" title="12. Docker-Compose 暂停、恢复容器"></a>12. Docker-Compose 暂停、恢复容器</h4><p>暂停容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker-compose <span class="hljs-attribute">pause</span> <span class="hljs-selector-attr">[SERVICE...]</span><br></code></pre></td></tr></table></figure><p>恢复处于暂停状态的容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span>-compsoe unpause<span class="hljs-meta"> [SERVICE...]</span><br></code></pre></td></tr></table></figure><h4 id="13-Docker-Compose-执行命令"><a href="#13-Docker-Compose-执行命令" class="headerlink" title="13. Docker-Compose 执行命令"></a>13. Docker-Compose 执行命令</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker-compose run <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-attr">[-v VOLUME...]</span> <span class="hljs-selector-attr">[-p PORT...]</span> <span class="hljs-selector-attr">[-e KEY=VAL...]</span> SERVICE <span class="hljs-selector-attr">[COMMAND]</span> <span class="hljs-selector-attr">[ARGS...]</span><br></code></pre></td></tr></table></figure><p>在指定容器执行 ping 命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker-compose <span class="hljs-built_in">run</span> Ubuntu<span class="hljs-built_in"> ping </span>www.baidu.com<br></code></pre></td></tr></table></figure><h4 id="14-Docker-Compose-指定运行容器数量"><a href="#14-Docker-Compose-指定运行容器数量" class="headerlink" title="14. Docker-Compose 指定运行容器数量"></a>14. Docker-Compose 指定运行容器数量</h4><p>设置指定服务运行的容器个数</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker-compose scale <span class="hljs-attribute">web</span>=3 <span class="hljs-attribute">db</span>=2<br></code></pre></td></tr></table></figure><h4 id="15-Docker-Compose-推送镜像"><a href="#15-Docker-Compose-推送镜像" class="headerlink" title="15. Docker-Compose 推送镜像"></a>15. Docker-Compose 推送镜像</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker-compsoe push <span class="hljs-selector-attr">[options]</span><span class="hljs-selector-attr">[SERVICE...]</span><br></code></pre></td></tr></table></figure><p>命令选项如下：</p><p>–ignore-push-failures 忽略推送镜像过程中的错误</p>]]></content>
    
    
    <categories>
      
      <category>容器化</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker-Compose</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 基础命令</title>
    <link href="/2018/12/15/MySQL%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/2018/12/15/MySQL%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>进入数据库：MySQL -u root -p<br>查看数据库：show databases<br>创建库：create database 库名称<br>使用数据库:use 数据库名字<br>查看正在使用的数据库：select database（）<br>查看表：show tables</p><p>创建表：create table 表名称（各字段及其类型和属性）<br>更改表的名字：alter table 表原名称 rename to 表新名称<br>插入数据：insert into 表名称（） values（数据）<br>查看表的创建信息：show create table 表名称<br>查看表的构造：desc 表名称<br>查看表的全部信息：select * from表名称</p><p>修改字段值：update 表名称 set 字段值&#x3D;新值 where 字段值&#x3D;旧值<br>删除字段值：delete from 表名称 where 字段值&#x3D;更新条件<br>增加字段：alter table 表名称 add 字段 字段类型 字段属性<br>删除字段：alter table 表名称 drop 字段<br>修改字段：alter table 表名称 change 字段旧名 字段新名 字段类型 字段属性<br>调整字段的顺序：alter table 表名称 modify 字段 字段类型 after 定位字段</p><p>字符集全部命令：<br>查看服务器支持的字符集：show character set<br>查看字符集的校对规则：show collation like ‘utf8’<br>查看当前库的字符集：show variables like ‘character%’<br>查看当前库的校对规则：show variables  like “collation%”<br>创建表的时候直接分配字符集和表类型：create table 表名称（各字段及其类型和属性）                        engine&#x3D;innodb defaultcharacter set gbk<br>修改库的字符集：alter database 库名称 default character set 新的字符集<br>修改表的字符集：alter table 表名称 convert to character set 新的字符集<br>修改字段的字符集：alter table 表名称 modify 字段 字段属性 character set 新的字符集</p><p>select全部命令：<br>查看表的全部信息：select * from 表名称<br>精确查询表的一个字段：select * from 表名称 where 定位信息<br>精确查询表的多个字段：select * from 表名称 where 字段 in 定位信息<br>精确显示和查询表的多个字段：select 列1，列2 from 表名称 where 字段 in 定位信息<br>运算符和逻辑查询:slect * from 表名称 where （ID&gt;1或者ID&#x3D;1+1或者ID&gt;2 and id&lt;10或者ID&gt;2 or ID&lt;10)<br>模糊查询：select * from  表名称 where 列 like 值（name like ‘%_’）<br>聚合查询：select (count（<em>）或者sum（<em>）或者max（</em>）或者min（<em>）或者avg（</em>））from 表名称<br>分组查询：select 展现的列 from 表名称 group by 参考列<br>      select name count（name）from 表名称 group by name<br>条件显示分组查询：select name count（name） from 表名称 group by name having count（name）&gt;5<br>顺序排列：select name count（</em>） from 表名称 group by name order by name asc<br>逆序排列：select name count（*） from 表名称 group by name order by name desc<br>左外连接：select 表1.列，表2.列  from 表名称 表1 left join 表2 on 表1.列&#x3D;表2.列<br>右外连接：select 表1.列，表2.列  from 表名称 表1 right join 表2 on 表1.列&#x3D;表2.列</p><p>添加外键约束<br>create table student（id int(100）not null primary key auto_increment,name char(100) not null default ‘’,age int not null default 0,birthday date not null default ‘2018-09-29’,address varchar(100) not null default ‘China’,salary double not null default 0.00,body text not null,foreign key student(sid) references school(id) ）</p><p>终极创建表：<br>create table student（id int(100）not null primary key auto_increment,name char(100) not null default ‘’,age int not null default 0,birthday date not null default ‘2018-09-29’,address varchar(100) not null default ‘China’,salary double not null default 0.00,body text not null,constarint w_key foreign key student(sid) references school(id) on delete cascade on update cascade）engine&#x3D;innodb default characset&#x3D;gbk;</p><p>创建唯一索引：create table 表名称（列，列属性，unique）<br>建表后添加唯一索引：create unique index 索引名 on 表名称（列）<br>建表后添加约束：alter table 表名称 add constraint 索引名 unique（列）from<br>创建普通索引：create index 索引名 on 表名称（列）<br>查看索引：show index from 表名称<br>删除索引：drop index 索引名 on 表名称<br>外键约束：foreign key（外键名） references 表名称（主键）</p><p>关闭自动提交：set autocommit&#x3D;1（默认）将1改成0  如果想手动彻底提交，commit<br>回滚：rollback    支持innodb表类型</p><p>用户管理：<br>进去mysql：use mysql<br>查看用户：select user，host，password from user<br>创建用户：create user 用户名@主机名（‘admin’@’localhost’） identified by 密码（‘admin’）<br>赋予权限：grant 权限（insert，update，delete，select） on （*.*或者库名称.<em>或者库名称.    表    名称）to 用户名@主机名（‘admin’@’localhost’）<br>修改收回权限：revoke 权限（insert，update，delete，select） on （</em>.*或者库名称.*或者库名称.    表名称） from  用户名@主机名（‘admin’@’localhost’）<br>设置密码：set password for 用户名@主机名（‘admin’@’localhost’）&#x3D;PASSWORD（‘新密码’）<br>修改密码：update 表名称 set password&#x3D;PASSWORD(‘admin’) where user&#x3D;’admin’ &amp;&amp;     host&#x3D;’localhost’<br>删除用户：delete from user where user&#x3D;‘admin’&amp;&amp; host&#x3D;‘localhost’<br>      drop user 用户名@主机名（‘admin’@’localhost’）</p><p>视图：<br>创建视图：create view 视图名（select_view） as 语句（select * from table）<br>查询视图：show create view 视图名（select_view）<br>创建具有外键约束的视图：create view see_view as select student.id,student.name,scores.python,scores.liuix from             student join scores on student.id&#x3D;scores.sid<br>删除视图：drop view 视图名（select_view）<br>使用视图：select * from 视图名（select_view）</p><p>备份数据库：mysqldump -u root -p 数据库（python）&gt;d:0806.sql<br>恢复数据库：mysql -u root -p 数据库（python）&lt;d:&#x2F;0806.sql</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
